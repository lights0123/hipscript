; ModuleID = 'build/lib/hip-device-lib/hipspv-spirv32.bc'
source_filename = "llvm-link"
target datalayout = "e-p:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024"
target triple = "spirv32"

%struct.uchar2Holder = type { %union.anon }
%union.anon = type { [2 x i32] }
%struct.redret = type { double, double, i32 }
%struct.scret = type { double, double }
%struct.redret.0 = type { float, i32 }
%struct.scret.1 = type { float, float }
%struct.redret.2 = type { half, i16 }
%struct.scret.3 = type { half, half }
%struct.redret.8 = type { double, i32 }

@.str = private unnamed_addr addrspace(2) constant [61 x i8] c"warning: Partial mask in __shfl_sync is not fully supported\0A\00", align 1
@.str.1 = private unnamed_addr addrspace(2) constant [64 x i8] c"warning: Partial mask in __shfl_up_sync is not fully supported\0A\00", align 1
@.str.2 = private unnamed_addr addrspace(2) constant [66 x i8] c"warning: Partial mask in __shfl_down_sync is not fully supported\0A\00", align 1
@.str.3 = private unnamed_addr addrspace(2) constant [65 x i8] c"warning: Partial mask in __shfl_xor_sync is not fully supported\0A\00", align 1
@.str.4 = private unnamed_addr addrspace(2) constant [63 x i8] c"warning: Partial mask in __ballot_sync is not fully supported\0A\00", align 1
@llvm.used = appending global [10 x ptr] [ptr @_cl_print_str, ptr @_chip_tex1df_impl, ptr @_chip_tex1dfetchf_impl, ptr @_chip_tex1dfetchi_impl, ptr @_chip_tex1dfetchu_impl, ptr @_chip_tex1di_impl, ptr @_chip_tex1du_impl, ptr @_chip_tex2df_impl, ptr @_chip_tex2di_impl, ptr @_chip_tex2du_impl], section "llvm.metadata"
@.str.5 = private unnamed_addr addrspace(2) constant [3 x i8] c"%c\00", align 1
@__ocmltbl_M32_J0 = protected local_unnamed_addr addrspace(2) constant [72 x float] [float 1.000000e+00, float 0x3E6816D220000000, float 0xBFD00002E0000000, float 0x3ED0910BC0000000, float 0x3F8FF9F9A0000000, float 0x3EF38BC460000000, float 0xBF3D965580000000, float 0x3EE3040C20000000, float 0x3ED360EDC0000000, float 0.000000e+00, float 0xBFE09CDB40000000, float 0x3FBBA1DEE0000000, float 0x3FACFAE7A0000000, float 0xBF81BB1C40000000, float 0xBF61F92680000000, float 0x3F31530480000000, float 0x3F069F1460000000, float 0xBED1EAAF60000000, float 0xBFD9C6CF60000000, float 0xBE1704E3C0000000, float 0x3FC9C6CF40000000, float 0xBF91F06B20000000, float 0xBF8B589020000000, float 0x3F50F855C0000000, float 0x3F385F27C0000000, float 0xBEF9BB9700000000, float 0xBED6DA5DE0000000, float 0.000000e+00, float 0x3FD5C6E600000000, float 0xBF9F8F72E0000000, float 0xBFAB214EE0000000, float 0x3F72F7FEA0000000, float 0x3F627D6020000000, float 0xBF26F55C80000000, float 0xBF07F2A640000000, float 0x3ECA684BC0000000, float 0x3FD33518C0000000, float 0x3E186B66E0000000, float 0xBFC33518A0000000, float 0x3F7D340A80000000, float 0x3F880C7CA0000000, float 0xBF44825AE0000000, float 0xBF36FCD020000000, float 0x3EF26BCC40000000, float 0x3ED6C3CD40000000, float 0.000000e+00, float 0xBFD15F7980000000, float 0x3F900F7FC0000000, float 0x3FA68B96C0000000, float 0xBF648E6200000000, float 0xBF60E02280000000, float 0x3F1D783220000000, float 0x3F0717D3C0000000, float 0xBEC2DEE220000000, float 0xBFCFF65460000000, float 0xBE1396A9E0000000, float 0x3FBFF65440000000, float 0xBF70C179C0000000, float 0xBF84B0C180000000, float 0x3F393F1FA0000000, float 0x3F34DF60C0000000, float 0xBEE95D7A20000000, float 0xBED5A7F7A0000000, float 0.000000e+00, float 0x3FCDC13E60000000, float 0xBF842FF0C0000000, float 0xBFA38D1C80000000, float 0x3F5A55E800000000, float 0x3F5E2CD860000000, float 0xBF13DEF6E0000000, float 0xBF056E8D80000000, float 0x3EBB39ADE0000000], align 4
@__ocmltbl_M32_J1 = protected local_unnamed_addr addrspace(2) constant [72 x float] [float 0.000000e+00, float 5.000000e-01, float 0x3E33DE0600000000, float 0xBFB0000180000000, float 0x3EA5B4D700000000, float 0x3F655074C0000000, float 0x3ED31A9A00000000, float 0xBF0F0C7740000000, float 0x3EC7E36D80000000, float 0x3FE29EA3E0000000, float 0xBDC7CA19E0000000, float 0xBFCA411140000000, float 0x3F78D14440000000, float 0x3F8C440A40000000, float 0xBF3865F680000000, float 0xBF39DCCE40000000, float 0x3EE30E4EE0000000, float 0x3ED8EE7240000000, float 0.000000e+00, float 0xBFD9C6CF60000000, float 0x3FAAE8A3A0000000, float 0x3FAB589780000000, float 0xBF75375280000000, float 0xBF62496BA0000000, float 0x3F26E5D980000000, float 0x3F0786BC40000000, float 0xBECA3971C0000000, float 0xBFD626EE80000000, float 0xBE175C9380000000, float 0x3FC55F6BE0000000, float 0xBF83D22F80000000, float 0xBF88C772A0000000, float 0x3F45CC7980000000, float 0x3F37325140000000, float 0xBEF1EB9180000000, float 0xBED6D4DDC0000000, float 0.000000e+00, float 0x3FD33518C0000000, float 0xBF95E70DC0000000, float 0xBFA80C8200000000, float 0x3F69A4B0C0000000, float 0x3F613EFC60000000, float 0xBF2072A300000000, float 0xBF072AFE60000000, float 0x3EC3C96C00000000, float 0x3FD17DBF00000000, float 0x3E1547ECC0000000, float 0xBFC1404BE0000000, float 0x3F74F4D880000000, float 0x3F85C62300000000, float 0xBF3D6658C0000000, float 0xBF35689DE0000000, float 0x3EEB74E880000000, float 0x3ED5D54FC0000000, float 0.000000e+00, float 0xBFCFF65440000000, float 0x3F89223FE0000000, float 0x3FA4B0C0E0000000, float 0xBF5F919F20000000, float 0xBF5F4EAD00000000, float 0x3F16B0C580000000, float 0x3F05A23A00000000, float 0xBEBCB23DA0000000, float 0xBFCDDCEB40000000, float 0xBE1169AB80000000, float 0x3FBDA52100000000, float 0xBF6A9D9980000000, float 0xBF8331E400000000, float 0x3F33E3EAE0000000, float 0x3F3386F480000000, float 0xBEE418A9C0000000, float 0xBED4969A60000000], align 4
@__ocmltbl_M64_J0 = protected local_unnamed_addr addrspace(2) constant [120 x double] [double 1.000000e+00, double 0xBCA4907401F4E73A, double 0xBFCFFFFFFFFFFF20, double 0xBD3E2AEB92C11928, double 0x3F90000000044077, double 0xBD971846E585E8C0, double 0xBF3C71C707FC64A5, double 0xBDC8D2E5CA2E7507, double 0x3EDC71DC58841F48, double 0xBDD9FB942A93AF21, double 0xBE722EA554940614, double 0xBDCC309762886108, double 0x3E00ECE316EB4BD4, double 0xBD99479286F572FD, double 0xBD7CBB10470436C0, double 0.000000e+00, double 0xBFE09CDB36551280, double 0x3FBBA1DEEA029494, double 0x3FACFAE864368D6B, double 0xBF81BB1CBE1A406D, double 0xBF61F992590D0897, double 0x3F315382BA06BF05, double 0x3F06ED3B9EEC933D, double 0xBED232C77D035520, double 0xBEA1CCE2DF6157CA, double 0x3E67FF98D2088A17, double 0x3E3294ED7209404C, double 0xBDF5C278F4188E72, double 0xBDBB9F73114AC14B, double 0x3D7C870190FB4FF7, double 0xBFD9C6CF582CBF7F, double 0xBC2340630BE882E1, double 0x3FC9C6CF582CBF7E, double 0xBF91F06D14E11DF9, double 0xBF8B589D1DA136E9, double 0x3F50F9103CF5A452, double 0x3F3864456219E47E, double 0xBEFA2A033CAECDFC, double 0xBED83A06DF50149A, double 0x3E96A4FD6F3E37BF, double 0x3E6EC03769300BBD, double 0xBE295D7532C9AE75, double 0xBDFB1AA7F95EB2B7, double 0x3DB3D0E8D4F46C36, double 0x3D809643D778859E, double 0.000000e+00, double 0x3FD5C6E60A097823, double 0xBF9F8F72E7A848E0, double 0xBFAB2150CB41E89B, double 0x3F72F7FFE90256AB, double 0x3F627E31FE9A6359, double 0xBF26F641F41949DF, double 0xBF0863F48139D08A, double 0x3ECAD77D74A4EB89, double 0x3EA32E6D3322F526, double 0xBE62DA3821A66401, double 0xBE341D0E8E78F041, double 0x3DF1D089C7B66E54, double 0x3DBDD03E1BC02C21, double 0xBD786CDF5A3F3B8F, double 0x3FD33518B3874E8A, double 0x3C42F912ABC5C301, double 0xBFC33518B3874E8A, double 0x3F7D34125D59D874, double 0x3F880C83BDEEE45B, double 0xBF4483C20F1C66BB, double 0xBF36FFA5FC8AE7CE, double 0x3EF2CCF7B1D72132, double 0x3ED796A74FB77CDA, double 0xBE91E8509B04B9CD, double 0xBE6E6A46B48901DC, double 0x3E254BF2843030AB, double 0x3DFB064CF4B52F16, double 0xBDB14A00318682F1, double 0xBD81036310530753, double 0.000000e+00, double 0xBFD15F7977A772D4, double 0x3F900F7FCF183E0D, double 0x3FA68B984EC64925, double 0xBF648E63600D8406, double 0xBF60E0D60385856B, double 0x3F1D796052772F54, double 0x3F07800BC50775C0, double 0xBEC3324842D019A1, double 0xBEA30E8C77C13527, double 0x3E5CEDA4325E2826, double 0x3E3457DC477E660A, double 0xBDECAD9A4A509C92, double 0xBDBE864D9617E1BC, double 0x3D741351FE093D3D, double 0xBFCFF654544EBCD1, double 0xBC44353ED972A55A, double 0x3FBFF654544EBCD0, double 0xBF70C17FF72AFA55, double 0xBF84B0C5D5DA66C1, double 0x3F394154BE70516B, double 0x3F34E12C3066B4A0, double 0xBEE9F32FC1C76819, double 0xBED63C5473EF99E9, double 0x3E8ADBAF4ECA4D0D, double 0x3E6D601B6216D4A4, double 0xBE20EE907FEE672B, double 0xBDFA83C5BBB08015, double 0x3DACA66D05214D85, double 0x3D810D9EF3F98BE2, double 0.000000e+00, double 0x3FCDC13E66AC2E77, double 0xBF842FF0CDC58463, double 0xBFA38D1DD8992DF2, double 0x3F5A55E9B346EDA9, double 0x3F5E2E16F97CD3DB, double 0xBF13DFC3782ACFE1, double 0xBF05CE7F4928AEAE, double 0x3EBBB178DA527278, double 0x3EA2346D3235A301, double 0xBE5612F29B5796E6, double 0xBE33D74F0F21F0AB, double 0x3DE6DB6FEDBDD2D3, double 0x3DBE380534E5B583, double 0xBD70827A2A754FB8], align 8
@__ocmltbl_M64_J1 = protected local_unnamed_addr addrspace(2) constant [120 x double] [double 0.000000e+00, double 5.000000e-01, double 0xBC37ED0E3B828B08, double 0xBFAFFFFFFFFFFFF5, double 0xBCE0293164FB7EB1, double 0x3F65555555561A43, double 0xBD4677D2FF1A71B8, double 0xBF0C71C715CC6962, double 0xBD855CABD8EBF8FC, double 0x3EA6C1780F921557, double 0xBDA2ED5069AAC6FE, double 0xBE383B4470480845, double 0xBDA01864213FB0F9, double 0x3DC4844C536D3A2C, double 0xBD735A9C5CC3AB06, double 0x3FE29EA3D19F035F, double 0xBC59E62CC35EC1BE, double 0xBFCA41115C5DF242, double 0x3F78D1448E6FEE77, double 0x3F8C441A2F9DDF5D, double 0xBF386671C18BFE53, double 0xBF39E2504DD90DCF, double 0x3EE34CCBCAB07EC9, double 0x3EDA4973743766EE, double 0xBE810453841038E8, double 0xBE70FADE42A46CB3, double 0x3E135494D664AEE3, double 0x3DFE5B866C453F65, double 0xBD9EB2970ACB8068, double 0xBD82FAF08AAFB901, double 0.000000e+00, double 0xBFD9C6CF582CBF7F, double 0x3FAAE8A39F51AD04, double 0x3FAB589D1DA13AA3, double 0xBF7537544C331CD2, double 0xBF624B3409976AC2, double 0x3F26E4C2D52DAE44, double 0x3F083A06E62D9F8F, double 0xBEC9799D369B7229, double 0xBEA338283463A4EE, double 0x3E6170516F7C85EE, double 0x3E34584933FDDD86, double 0xBDF026119D7F08AF, double 0xBDBF9000DA3A4471, double 0x3D5F7332C56D63D2, double 0xBFD626EE83500BF2, double 0xBC40432466D6E3F3, double 0x3FC55F6BEC9EF961, double 0xBF83D23336FD10A9, double 0xBF88C77A983A068D, double 0x3F45CDC98DB18C8C, double 0x3F373576FF44EF39, double 0xBEF24614479A1346, double 0xBED7B85342EA7515, double 0x3E90ABFC294C82A1, double 0x3E6EA79EAB269916, double 0xBE235BBE38F3529C, double 0xBDFB5A33186E7193, double 0x3DAEFC264AA83BF3, double 0x3D8145CBB6E8A3A0, double 0.000000e+00, double 0x3FD33518B3874E8A, double 0xBF95E70DC60362BF, double 0xBFA80C83BDEEE593, double 0x3F69A4B292E3DE28, double 0x3F613FBC7D695936, double 0xBF207358BBDBE512, double 0xBF0796A751A29AC8, double 0x3EC4255B013502CF, double 0x3EA3026DB6F0DBC4, double 0xBE5D48DCA8C5FC90, double 0xBE3445E1DA91DBCA, double 0x3DEC62A36E1968D3, double 0x3DBE721272D8248E, double 0xBD739F923D874246, double 0x3FD17DBF09D40D25, double 0x3C44967F4F7FC629, double 0xBFC1404BF647C28F, double 0x3F74F4DF2769F79D, double 0x3F85C6285429B55E, double 0xBF3D68AB7227E79D, double 0xBF356ACB64517694, double 0x3EEC10B47C6794FC, double 0x3ED67EAAE7C19EC8, double 0xBE8BB65280097FDB, double 0xBE6D871DDEB2DB00, double 0x3E20F432B5F8846E, double 0x3DFA96B19CBA8298, double 0xBDAC2077A86562A4, double 0xBD810893DC905EFB, double 0.000000e+00, double 0xBFCFF654544EBCD0, double 0x3F89223FF2C0785A, double 0x3FA4B0C5D5DA65D1, double 0xBF5F91A9EE0D218C, double 0xBF5F51C24898187F, double 0x3F16B4C9CA04065C, double 0x3F063C547294C80D, double 0xBEBE3725C3BED76A, double 0xBEA25C1053590F28, double 0x3E57485BC4AFFD32, double 0x3E33E27187DB1B90, double 0xBDE77B93FF00A8D9, double 0xBDBDB9D1890C1963, double 0x3D69BC7332D23C98, double 0xBFCDDCEB4CE1BF4A, double 0xBC44E6F0FF2BE5DA, double 0x3FBDA52116C0A63F, double 0xBF6A9DA4603B66C1, double 0xBF8331E74EA59A28, double 0x3F33E5CB6EB9D4D2, double 0x3F33885FE9AEE88D, double 0xBEE494C0F422BE24, double 0xBED512B9D2882A32, double 0x3E85A86081766E10, double 0x3E6C323D60D5C85A, double 0xBE1BCC0C4C6C296F, double 0xBDF9BBB359D527C1, double 0x3DA7E38DB953D46D, double 0x3D80C831B59F5952], align 8
@PIBITS_TBL = internal unnamed_addr addrspace(1) constant [158 x i8] c"\E0\F1\1B\C1\0CX!t5~\C4~\ED\AF\A9KJ)\DE\E7\1C\F4\EC\C5\97\AF\1F\EB\9E\D4\B5\A8\7Fy\9A\FD\18=\DD&,\9F<\FB\D9\B4}\B4)h-F\BC\BC?`\16x\FF_\E2\7F\EC\A0\E4\F7.~\11r\D2\E7L\0D\E6XG\E6\04\F9}\D1\9A\C0q\A6\13\12\ED\BA\D4\D7\08\A2\FB\9C\A6\C4r\ACw\F8sHF'\A8\BB$\19\80K7\09\E9\B8\91\DC\86\15\EFz\AF\8EE\F9\07A\0E\F1dV\8Am\03w\D3\D4G_\9D\F0\A7T\109\B9\0D\E6\8B\02\00\00\00\00\00\00\00", align 1
@__ocmltbl_M64_Y0 = protected local_unnamed_addr addrspace(2) constant [270 x double] [double 0xBFB2E4D699CBD01F, double 0x3FC6BBCB41034286, double 0xBF9075B1BBF41364, double 0x3F41A6206B7B973D, double 0xBEE3E99794203BBD, double 0x3E7BCE4A600D3EA5, double 0xBE0A6EE796B871B6, double 0x3D92393D82C6B2E4, double 0xBD131085DA82054C, double 0x3C8F4ED4B492EBCC, double 0xBC04B7AC8A1B15C6, double 0x3B769201941CC7B8, double 0xBAE4987E57338156, double 0x3A4FF18D4705632D, double 0xB9B5416ACD087D02, double 0xBFE8EEA0AE99A033, double 0x4001B052CD42754E, double 0xC0092F7D329697CF, double 0x401B0D7849D94041, double 0xC0308F108854A13F, double 0x4045473065287973, double 0xC05C69A8813D10E8, double 0x40737EC167E18FEC, double 0xC08B44127A0228E4, double 0x40A33A1CF6A241C7, double 0xC0BAAD0C98BDB9B5, double 0x40D134629471039B, double 0xC0E29C65CCF79BA0, double 0x40EC922FBC085C32, double 0xC0E655B619071060, double 0xBFE15659A787357B, double 0x3FFA6174D29845E5, double 0xBFF9D0A5F4831145, double 0x40031F12941F635B, double 0xC0111BB0813976D0, double 0x401F8B042CA17533, double 0xC02E1EB9D27B3826, double 0x403D8CB662FA6DF2, double 0xC04D9175A3310C79, double 0x405DFCEE0E45019E, double 0xC06E7481FB9E5F61, double 0x407DEB3BB4DC60CE, double 0xC08A25FAB23792B8, double 0x4091402BBFBAED82, double 0xC0885DB459E00D9B, double 0xBFD6DA72F31DCA44, double 0x3FF54DFD34C830F7, double 0xBFF014AF25DC721E, double 0x3FF13366C90BEC01, double 0xBFF8C024B43A4764, double 0x4001E294A410A304, double 0xC00A97F320B0EA96, double 0x40144F870B1AC185, double 0xC01FA37C80EA46F7, double 0x402900DA91537E82, double 0xC033E7DBEAB87589, double 0x403F3EC6D4CF71AA, double 0xC046A7ABA5D5442A, double 0x404A0C08542C3074, double 0xC040C45498A8B8A5, double 0xBFCA2F2E18B92A4F, double 0x3FF1EEDD9C1F2BD8, double 0xBFE6CFB9ABA1D4A6, double 0x3FE1BABA8B2960D8, double 0xBFE5C9A23CECFEFA, double 0x3FEA201BB93EBE9B, double 0xBFEFCCEF9C6DB67B, double 0x3FF3E3D322601093, double 0xBFF95E86CAD83531, double 0x40006B019FB826FC, double 0xC005748824585339, double 0x400BE6F54263D628, double 0xC0112AC8AC6925DF, double 0x40116432C5740749, double 0xC0048433915014EF, double 0.000000e+00, double 0x3FEC24371844B88A, double 0xBFDF7E38A46D7102, double 0x3FCC3B1338AF433E, double 0xBFCCF18E6A4B4233, double 0x3FCC068086AD19C8, double 0xBFCA396A800CBB37, double 0x3FC9424BB759C9A8, double 0xBFC8D35C00975F04, double 0x3FC8C0719FB178F7, double 0xBFC8F72DA405DE4E, double 0x3FC976EB13434CF9, double 0xBFCA693E0695B82E, double 0x3FCA39AAEEEE6DCF, double 0xBFC041222B5CF46E, double 0x3FB6980226F358DF, double 0x3FE8FFB207D66B94, double 0xBFDBD2B24CB4D65A, double 0x3FC28C76DDCD8EBF, double 0xBFC19B76C6C2D753, double 0x3FBFE1A296CE781F, double 0xBFBAA16D38B246FE, double 0x3FB6E7C77660784E, double 0xBFB4223FD6F63950, double 0x3FB1EDE638013F16, double 0xBFB00C129CF3FA8E, double 0x3FAC25552887122D, double 0xBFA6828823344907, double 0x3F9C0732C7410916, double 0xBF8330C8D93428FF, double 0x3FD0869FF937FA12, double 0x3FE2B31C35470A4A, double 0xBFD73900273B3659, double 0x3FAF970ACB313F75, double 0xBFA76B24758C6A51, double 0x3FA4D6F05A2F473B, double 0xBF9BE8DF6D1412D3, double 0x3F93098C63847DDA, double 0xBF8AD67D917F84EF, double 0x3F8320B5B7AB98E4, double 0xBF7B39DAFCF12CCD, double 0x3F72AC1299BE4543, double 0xBF66A630582D99DD, double 0x3F5497F4183F528F, double 0xBF33EB6AA5DA7D32, double 0x3FDB7362A42DD8FF, double 0x3FD53A7B3F0DFB71, double 0xBFD441D73E1B39CB, double 0x3F9F505223BE8C30, double 0xBF7371CA702291B7, double 0x3F8599BA9529FF05, double 0xBF7813569BE4AC1D, double 0x3F67E92DAC4148AD, double 0xBF59ED66DC5A6048, double 0x3F4CA8CC8B2B25B1, double 0xBF3FB5D5D524368A, double 0x3F313E17D93243DC, double 0xBF214016505428D9, double 0x3F0B3531E22732F6, double 0xBEE7E3F31E3D1EFF, double 0x3FE0AA48442F014B, double 0xBC42FC44B41B87DF, double 0xBFD0AA48442F014C, double 0x3FA439FAC165269B, double 0x3F80D2AF4E933A41, double 0x3F4F71646BCF7F6C, double 0xBF5444BDA8E8462D, double 0x3F384C22162349FD, double 0xBF217AB499428EEF, double 0x3F0DAFA7E064BEAA, double 0xBEF8BB68BE4D8127, double 0x3EE490083E101288, double 0xBED1512541C86FB3, double 0x3EBC67C5BE2B19CF, double 0xBEA0AEF1EDF4C84C, double 0x3FDF922E9B7FCFF3, double 0xBFC46AE4B2D59FBA, double 0xBFCB89B5949E4E6B, double 0x3FA9FE2B318DC766, double 0x3F80AA736E5F234E, double 0xBF4C32FC82583918, double 0xBF4582F115E796B3, double 0x3F25CA419D5397D0, double 0xBF04CCBF0F49A3CD, double 0x3EEFEB1F3C777328, double 0xBED7D81115E556B5, double 0x3EC0DC1871A64FAA, double 0xBEA690F94672B956, double 0x3E88DE4474FFF121, double 0xBE5FD1F6321A642B, double 0x3FD81E4F8120242A, double 0xBFD4C7773D150462, double 0xBFC13127C21922B4, double 0x3FB0224F7EBCB4E0, double 0x3F7240000575C220, double 0xBF6135AA20D0A769, double 0xBF3161CE7505EB62, double 0x3F17B51BEC1F5E5A, double 0xBEE3290B9A006192, double 0x3EC677BE1FC5D2EA, double 0xBEB15E4F8FA357F4, double 0x3E9505E7DE49AD7F, double 0xBE77D76C65326B71, double 0x3E572BD064DB5810, double 0xBE2AEEAE21C65C13, double 0.000000e+00, double 0xBFD9C34256A12A0C, double 0x3FAA09C9290367EF, double 0x3FADF6D59BF50FE5, double 0xBF7C116FDC598542, double 0xBF61E32BC4F26DBB, double 0x3F299827653EFC95, double 0x3F0AB2C209548FE9, double 0xBED4863787F98471, double 0xBE93B2382F029E6C, double 0xBE57737C6A81E739, double 0x3E545853FA20E785, double 0xBE2FD2A529AAB5E4, double 0x3E0A42DDAD39AD95, double 0xBDE112E48FB82CD5, double 0xBFD5C7C556F0C19A, double 0x3C65B2C3F10BB869, double 0x3FC5C7C556F0C19C, double 0xBF8564D4B1ED0EB7, double 0xBF8A15D92DFE4293, double 0x3F4B43843047ED3C, double 0x3F37A8924CC88CC3, double 0xBEF5F69B4BC9EDFD, double 0xBED85B94153D61E4, double 0x3E955AC235B60413, double 0x3E6D56458C85B80D, double 0xBE23EC1EA0457428, double 0xBE000934B9FDA092, double 0x3DC0AE48DC572273, double 0xBD45950B4CA3EF99, double 0.000000e+00, double 0x3FD334CCA0697A5A, double 0xBF95AEF611FC4D57, double 0xBFA8969C64CBF437, double 0x3F6B2F14A95527B4, double 0x3F61D35E85FDBC6F, double 0xBF226DD71E3904D7, double 0xBF08177E4F94CE0E, double 0x3EC6A92273315BA3, double 0x3EA34AA706E77DBB, double 0xBE60A281377E8B1E, double 0xBE344251968BE3C8, double 0x3DEFA6A0D37C6134, double 0x3DBEC1D47EAB32BB, double 0xBD76FB9A346B2386, double 0x3FD15F993FCEAB5C, double 0x3C474335059E1F4E, double 0xBFC15F993FCEAB5B, double 0x3F758EF6EFBED6F1, double 0x3F86395DFE49FBA8, double 0xBF3FB15104A36E0F, double 0xBF35F88A11D3D03A, double 0x3EEF37D226054DAE, double 0x3ED6F7BAAF1EB952, double 0xBE8F0C45054039D9, double 0xBE6DFE0F689FE34D, double 0x3E23115A93B5A609, double 0x3DFAD1AAE15A8F0E, double 0xBDAF829CBACA6BC1, double 0xBD81191EAEAD7D7C, double 0.000000e+00, double 0xBFCFF635CC72B9F1, double 0x3F89036451FF57C5, double 0x3FA4E667A7155698, double 0xBF60325EE41E90FC, double 0xBF5FE23914FB4DAA, double 0x3F17F84D7C50BFF4, double 0x3F06AFDD5774B982, double 0xBEC04053ABD359B6, double 0xBEA2AEA9A040B3BE, double 0x3E593EB9B7C33886, double 0x3E342852D79837DC, double 0xBDE99D5155505D29, double 0xBDBE747D553E2BE7, double 0x3D723DD8D96219F9, double 0xBFCDC14EA14E89F9, double 0xBC42890A10AF0448, double 0x3FBDC14EA14E89F8, double 0xBF6B037FE9CF2945, double 0xBF8367D7D608E3FF, double 0x3F34ABEF563655FD, double 0x3F33D8A66121994D, double 0xBEE5CFE92992EDFE, double 0xBED5718148DC24EF, double 0x3E87414DAF653481, double 0x3E6CA704F47D3C94, double 0xBE1E0AAEA47F3944, double 0xBDFA14B5AF307E06, double 0x3DA9E7E5CCBE0C5A, double 0x3D80E377F8A6A708], align 8
@__ocmltbl_M32_Y0 = protected local_unnamed_addr addrspace(2) constant [162 x float] [float 0xBFB2E4D6A0000000, float 0x3FC6BBCB40000000, float 0xBF9075B1C0000000, float 0x3F41A62060000000, float 0xBEE3E997A0000000, float 0x3E7BCE4A60000000, float 0xBE0A6EE780000000, float 0x3D92392FA0000000, float 0xBD12F9C860000000, float 0xBFE8EEA0A0000000, float 0x4001B052C0000000, float 0xC0092F7820000000, float 0x401B0CA4E0000000, float 0xC030864B60000000, float 0x4044DC6660000000, float 0xC0595311A0000000, float 0x4068BFD040000000, float 0xC06AA68BE0000000, float 0xBFE15659A0000000, float 0x3FFA6174E0000000, float 0xBFF9D0A540000000, float 0x40031EF460000000, float 0xC011193900000000, float 0x401F503AE0000000, float 0xC02C78A9A0000000, float 0x40364F3B00000000, float 0xC034C8FA80000000, float 0xBFD6DA7300000000, float 0x3FF54DFD40000000, float 0xBFF014AF00000000, float 0x3FF1335EA0000000, float 0xBFF8BED780000000, float 0x4001D355A0000000, float 0xC009C1A580000000, float 0x4010BF0BC0000000, float 0xC00B7C1960000000, float 0xBFCA2F2E20000000, float 0x3FF1EEDDA0000000, float 0xBFE6CFB9A0000000, float 0x3FE1BAB720000000, float 0xBFE5C91B40000000, float 0x3FEA141220000000, float 0xBFEF2823E0000000, float 0x3FF13B6AE0000000, float 0xBFE93195A0000000, float 0.000000e+00, float 0x3FEC243720000000, float 0xBFDF7E38A0000000, float 0x3FCC3B1520000000, float 0xBFCCF190E0000000, float 0x3FCC03F760000000, float 0xBFCA34BAC0000000, float 0x3FCA3DABA0000000, float 0xBFCADC6900000000, float 0x3FB6980220000000, float 0x3FE8FFB200000000, float 0xBFDBD2B220000000, float 0x3FC28C6860000000, float 0xBFC19A2C60000000, float 0x3FBFC0B220000000, float 0xBFB9A82100000000, float 0x3FB2790420000000, float 0xBFA081D660000000, float 0x3FD086A000000000, float 0x3FE2B31C40000000, float 0xBFD738FFC0000000, float 0x3FAF96B5C0000000, float 0xBFA7664060000000, float 0x3FA4AE3160000000, float 0xBF9A526CA0000000, float 0x3F8C6DB9A0000000, float 0xBF72629E00000000, float 0x3FDB7362A0000000, float 0x3FD53A7B40000000, float 0xBFD441D740000000, float 0x3F9F503C60000000, float 0xBF736CEE20000000, float 0x3F85860D60000000, float 0xBF77550C20000000, float 0x3F6391C8C0000000, float 0xBF45FE06C0000000, float 0x3FE0AA4840000000, float 0x3DC162EDC0000000, float 0xBFD0AA4840000000, float 0x3FA439FAA0000000, float 0x3F80D2B8E0000000, float 0x3F4F72CDE0000000, float 0xBF544F2E40000000, float 0x3F385BD280000000, float 0xBF1BB9F460000000, float 0x3FDF922EA0000000, float 0xBFC46AE4C0000000, float 0xBFCB89B5A0000000, float 0x3FA9FE2A40000000, float 0x3F80AA9B00000000, float 0xBF4C429AA0000000, float 0xBF4547FD60000000, float 0x3F23B1DF00000000, float 0xBEF35AD160000000, float 0x3FD81E4F80000000, float 0xBFD4C77740000000, float 0xBFC13127C0000000, float 0x3FB0224F60000000, float 0x3F72400F40000000, float 0xBF613662A0000000, float 0xBF314CBB20000000, float 0x3F16F9C7A0000000, float 0xBED6EBD660000000, float 0.000000e+00, float 0xBFD9C34260000000, float 0x3FAA09C920000000, float 0x3FADF6D260000000, float 0xBF7C1164A0000000, float 0xBF61E12F60000000, float 0x3F2981AA80000000, float 0x3F0970F060000000, float 0xBEC69BDE60000000, float 0xBFD5C7C560000000, float 0xBE1E3E2120000000, float 0x3FC5C7C540000000, float 0xBF8564CFE0000000, float 0xBF8A15CFA0000000, float 0x3F4B41D360000000, float 0x3F37A4E7E0000000, float 0xBEF5824B80000000, float 0xBED75CA060000000, float 0.000000e+00, float 0x3FD334CCA0000000, float 0xBF95AEF620000000, float 0xBFA8969AA0000000, float 0x3F6B2F12C0000000, float 0x3F61D29B00000000, float 0xBF226D16A0000000, float 0xBF07AA0BA0000000, float 0x3EC6449D80000000, float 0x3FD15F9940000000, float 0x3E17E8E1C0000000, float 0xBFC15F9940000000, float 0x3F758EEF60000000, float 0x3F86395820000000, float 0xBF3FAEB600000000, float 0xBF35F635A0000000, float 0x3EEE8933A0000000, float 0x3ED64513E0000000, float 0.000000e+00, float 0xBFCFF635C0000000, float 0x3F89036460000000, float 0x3FA4E66620000000, float 0xBF60325DC0000000, float 0xBF5FE0D880000000, float 0x3F17F74C80000000, float 0x3F0649A000000000, float 0xBEBFF10BA0000000, float 0xBFCDC14EA0000000, float 0xBE10ED55E0000000, float 0x3FBDC14EA0000000, float 0xBF6B037520000000, float 0xBF8367D3E0000000, float 0x3F34AA0660000000, float 0x3F33D6FC40000000, float 0xBEE54E58A0000000, float 0xBED4E5C1E0000000], align 4
@__ocmltbl_M64_Y1 = protected local_unnamed_addr addrspace(2) constant [270 x double] [double 0xBFC91866143CBC8A, double 0x3FABD3975C75B4A7, double 0xBF6835B97894BE5B, double 0x3F12C7DBFFCDE97D, double 0xBEB0A780AC776EAC, double 0x3E432E5A4DDEEA30, double 0xBDCF0CE34D2066A6, double 0x3D52A4E1AEA45C18, double 0xBCD1474ADE9154AC, double 0x3C4978BA84F218C0, double 0xBBBE9598C0163788, double 0x3B2E7E5FCFC49D52, double 0xBA99A6C125CD4A4B, double 0x3A0273872098881C, double 0xB966E9D99D76D143, double 0xBFF78B26A2B7C4DF, double 0x4003FCC6CC40CDC8, double 0xC012D291E3254D05, double 0x4023F3A228303640, double 0xC0342F25541834D5, double 0x40443F9C12BF4AB6, double 0xC05449BFBBF62991, double 0x40644FB5451116BC, double 0xC0745269AC3FA0DB, double 0x40844BA4401F2779, double 0xC09414D76E7B7997, double 0x40A320F5FE16F70A, double 0xC0B03E4B57E41DF5, double 0x40B4F69E69A4F4FB, double 0xC0AD2DBB0F5B271A, double 0xBFF3797262D3470D, double 0x3FFAB7E1EDEFAFA8, double 0xC0024846FB79F39A, double 0x40101BF3F4FA0318, double 0xC01A594EAB7356D8, double 0x402529F452075247, double 0xC030FAE25FDC4E3B, double 0x403B37934724E423, double 0xC045CC0DE6C9E845, double 0x4051708D1A40185C, double 0xC05BC7F31A7D6E5C, double 0x4065A379BA1401C8, double 0xC06F0B0AD21C1A88, double 0x4071AE75EDD45DEB, double 0xC066A3BB6C3BC030, double 0xBFF099FCBE60FD83, double 0x3FF3F0CA40455E64, double 0xBFF3BFF758706437, double 0x3FFE635F86EB952C, double 0xC00518FB90840D37, double 0x400C3F8901B6B53E, double 0xC012E70C7140D7A2, double 0x401944BBA4AE4A2A, double 0xC020DE9423C41CB2, double 0x40267A063C3E4E1F, double 0xC02DAA214568B0F7, double 0x4032D7AF68B5B7BB, double 0xC03555C5991EB83A, double 0x40325AD3BCD1C212, double 0xC021074C12C09791, double 0xBFEACBF57F2DDCA8, double 0x3FEDCA17107B904E, double 0xBFE1BBD2B0457CDF, double 0x3FE77A8F333CCBB2, double 0xBFEB89C1B814324B, double 0x3FED760AF4FFB08B, double 0xBFEF8CF4A5A36F58, double 0x3FF0E518D641E18F, double 0xBFF20E81208FA7BC, double 0x3FF3376B177DAD58, double 0xBFF41C66D0E0C209, double 0x3FF3E3FED2BA82A1, double 0xBFF1009BEF1C1ED4, double 0x3FE551AD045B2B05, double 0xBFCBF968FB74C1F5, double 0xBFE36E6B6B7643F7, double 0x3FE79C5F275090C0, double 0xBFCA0C195B672E36, double 0x3FCAE3C79B655957, double 0xBFCD944BFBB59E94, double 0x3FC859BA5C97B008, double 0xBFC3E9C794C4910B, double 0x3FC073CBE8A621FB, double 0xBFBB1CF7A1D06A0B, double 0x3FB64331589B8D85, double 0xBFB214CBE1D92F45, double 0x3FAC3017799BA518, double 0xBFA37C91F275A49C, double 0x3F945A0EE3E461F4, double 0xBF76CE6DB619DFCB, double 0xBFD9145D558C1484, double 0x3FE4D465C2CC8BB9, double 0xBFB9A53A6FC4F8D2, double 0x3FA5A04EF5B3BE17, double 0xBFB2870DCA6BBBA8, double 0x3FA959DC1B5CA22F, double 0xBF9FD1701AF4F6C8, double 0x3F94F4669C520714, double 0xBF8B9C51B6264199, double 0x3F821867B6956ED4, double 0xBF7793000339B970, double 0x3F6DF65915265695, double 0xBF6174D53E085260, double 0x3F500D917DBC1489, double 0xBF307F689E7C1FF8, double 0xBFC9482110CE7907, double 0x3FE300298C4BC6DB, double 0xBFB760867541F31A, double 0xBF8C1C01516C919F, double 0xBF99CE754717084F, double 0x3F92149F4F3E4A7D, double 0xBF8141D386A70A68, double 0x3F7298E689470B8F, double 0xBF6493304450D3E1, double 0x3F5678E25A319117, double 0xBF4872DA1BCE2DFB, double 0x3F3A677FB40DBF50, double 0xBF2B726429D57741, double 0x3F188B8A000DDEB3, double 0xBEFB11671433A545, double 0.000000e+00, double 0x3FE0AA48442F014B, double 0xBFBE56F82217B8F1, double 0xBFA0D2AF4E932386, double 0xBF73A6DEC37290AA, double 0x3F7E671C7D1198C2, double 0xBF65429DC5A4571B, double 0x3F517AB4AFA1770F, double 0xBF40B2D877CEC32A, double 0x3F2EEA7BF7A3AF87, double 0xBF1C3FAE660AEEFB, double 0x3F09D11D21C2ECE2, double 0xBEF79526605F9903, double 0x3EE5C5B6BEE7147F, double 0xBED3D818ACF4319F, double 0x3FADED04EB2F8F23, double 0x3FDF7EB2F74619DB, double 0xBFC0A92031647ABD, double 0xBFA17D0AAC12CAF8, double 0xBF501B12268FC3BE, double 0x3F781B3A8783D65C, double 0xBF5F13C3971E1240, double 0x3F46AF0F6BAFEEB3, double 0xBF34DF6F71C51090, double 0x3F227DE227AF4204, double 0xBF0FFDDD56E31177, double 0x3EFB3F437408AF5D, double 0xBEE5AEEF5A8D616E, double 0x3ECC00D34BE2E087, double 0xBEA4C7F0E4847DB1, double 0x3FCEC444C4C077CA, double 0x3FD754D9F5EBEE6E, double 0xBFC5DBC72A6FCD06, double 0xBF9C45318021591E, double 0x3F7F6232AD13A468, double 0x3F6675FB15DD65CC, double 0xBF4B70DC1DFAB822, double 0x3F25178509C8DFFD, double 0xBF10FBA65912DFAD, double 0x3EFB97B9CAB9DD89, double 0xBEE42DF3752F458B, double 0x3ECD263C5A2A0CF3, double 0xBEB419A6ED1F3133, double 0x3E9722448D6C6B4D, double 0xBE6F968C1760EA44, double 0x3FDAABB4011ED330, double 0x3C97623D98C40FBF, double 0xBFC8B45BABE797C1, double 0x3F8E147099A6D924, double 0x3F88C5AF1EEB4695, double 0xBF4133FA47A23C24, double 0xBF3BF8AF944ED4C6, double 0x3F021D6483F67C2F, double 0x3EB44D30D299B6F7, double 0x3EB14C792DD315F1, double 0xBE9B8F5A5B07796D, double 0x3E7A741606128773, double 0xBE5BDE8E4E6A28D8, double 0x3E40CB2C5BA5E6B9, double 0xBE22967744B15F9C, double 0x3FD7843613523E7F, double 0xBFC75654A46B95C5, double 0xBFC368BC54BE4F06, double 0x3FA31BFBC9CB82A3, double 0x3F82CC37920F76A3, double 0xBF5AF2C8815E3FE3, double 0xBF32A7121C69428C, double 0x3F075298ECB8C751, double 0x3EC63DED0744F6F9, double 0xBE8754D788CB6020, double 0xBE8027347B18E32A, double 0x3E597C5ADCDAC214, double 0xBE322680B0FBE186, double 0x3E0E64B283A65579, double 0xBDE02608B566F8D5, double 0.000000e+00, double 0xBFD5C7C556F0C199, double 0x3FA00B9F8571CA1F, double 0x3FAA15D92DFE3DD1, double 0xBF710A329E2C23B2, double 0xBF61BE6DB991A919, double 0x3F2337C7E137E72D, double 0x3F085B940D416677, double 0xBEC806191189D631, double 0xBEA255E5098A01B5, double 0x3E5B62C536F9E018, double 0x3E3808E3D2AC8FCA, double 0xBDFA799F4759A3E7, double 0x3D94EC0A14B5CDF4, double 0xBD95412530847C52, double 0xBFD36732D4B96094, double 0xBC3CEEF52886C58E, double 0x3FC3001C8002CAF7, double 0xBF7BF5A03BAB4931, double 0xBF8751EA028C1873, double 0x3F423874CD8CCDA2, double 0x3F364F6610D5226E, double 0xBEF02978DE052C61, double 0xBED72F07655A8EB0, double 0x3E8F208123BB6540, double 0x3E6DEFD3E8ED0235, double 0xBE2205926B336E7E, double 0xBDFB62D4804FB244, double 0x3DB00C025FDA5D77, double 0x3D800419AC68AAE1, double 0.000000e+00, double 0x3FD15F993FCEAB5C, double 0xBF902B3933CF21B1, double 0xBFA6395DFE49FCBD, double 0x3F63CED2A2E6916F, double 0x3F607A678D5FDF7B, double 0xBF1B50D7E1D2F596, double 0xBF06F7BAB0BC8947, double 0x3EC176E72BD30AF3, double 0x3EA2BECAE04D97FC, double 0xBE5A384EA928E49A, double 0xBE341E2AA12C9A44, double 0x3DE9E2E75967AAC7, double 0x3DBE6FCC09518560, double 0xBD7243FBE2456B83, double 0x3FD00EF3745E0E3C, double 0x3C4354A449398E41, double 0xBFBFCDACDDA138F1, double 0x3F706CC34CD82970, double 0x3F84641BB10C15C9, double 0xBF37FAC943E210BA, double 0xBF34769ED32CC451, double 0x3EE80608EC528CBD, double 0x3ED5CC824132DB1A, double 0xBE888C8EA16EFD07, double 0xBE6CE58E67A63C4A, double 0x3E1ED0D7B94D1E27, double 0x3DFA2F65AC967F11, double 0xBDAA05857D61E344, double 0xBD80DDB4C7A5B2C2, double 0.000000e+00, double 0xBFCDC14EA14E89F9, double 0x3F84429FEF5B5FBD, double 0x3FA367D7D608E4A3, double 0xBF59D6EB2BC49E17, double 0xBF5DC4F991B39911, double 0x3F1315EC04D6BD38, double 0x3F05718149D2AC24, double 0xBEBA2977F9ED10D6, double 0xBEA1E863D8AC307D, double 0x3E54A7B7D8AF34A1, double 0x3E339017071CB777, double 0xBDE549934363D75D, double 0xBDBDDF663C0D3F53, double 0x3D6EA9D18ACB267F], align 8
@__ocmltbl_M32_Y1 = protected local_unnamed_addr addrspace(2) constant [162 x float] [float 0xBFC9186620000000, float 0x3FABD39760000000, float 0xBF6835B980000000, float 0x3F12C7DC00000000, float 0xBEB0A780A0000000, float 0x3E432E5A40000000, float 0xBDCF0CE340000000, float 0x3D52A4DB00000000, float 0xBCD138F580000000, float 0xBFF78B26A0000000, float 0x4003FCC6C0000000, float 0xC012D290E0000000, float 0x4023F37A40000000, float 0xC0342BDB20000000, float 0x4044180B60000000, float 0xC0532B9980000000, float 0x405EC1C700000000, float 0xC05CF9D7E0000000, float 0xBFF3797260000000, float 0x3FFAB7E1E0000000, float 0xC0024846C0000000, float 0x40101BE9A0000000, float 0xC01A579C00000000, float 0x402515B300000000, float 0xC0306A4880000000, float 0x4036576E40000000, float 0xC032D598A0000000, float 0xBFF099FCC0000000, float 0x3FF3F0CA40000000, float 0xBFF3BFF640000000, float 0x3FFE632060000000, float 0xC005158360000000, float 0x400C07F420000000, float 0xC011DB4B20000000, float 0x40131E5640000000, float 0xC008054CA0000000, float 0xBFEACBF580000000, float 0x3FEDCA1700000000, float 0xBFE1BBCF20000000, float 0x3FE77A0D20000000, float 0xBFEB803640000000, float 0x3FED0F9CE0000000, float 0xBFECF446A0000000, float 0x3FE767D5E0000000, float 0xBFD5432780000000, float 0xBFE36E6B60000000, float 0x3FE79C5F20000000, float 0xBFCA0C16C0000000, float 0x3FCAE37220000000, float 0xBFCD8EB880000000, float 0x3FC8249700000000, float 0xBFC2B895C0000000, float 0x3FB8868240000000, float 0xBFA2B014A0000000, float 0xBFD9145D60000000, float 0x3FE4D465C0000000, float 0xBFB9A539C0000000, float 0x3FA5A02220000000, float 0xBFB2859EE0000000, float 0x3FA93F1AE0000000, float 0xBF9EA56860000000, float 0x3F90F78100000000, float 0xBF771F8600000000, float 0xBFC9482120000000, float 0x3FE3002980000000, float 0xBFB7608660000000, float 0xBF8C1C08C0000000, float 0xBF99CE26A0000000, float 0x3F9210EBE0000000, float 0xBF810C8B80000000, float 0x3F70CD08C0000000, float 0xBF575FAE60000000, float 0.000000e+00, float 0x3FE0AA4840000000, float 0xBFBE56F820000000, float 0xBFA0D2AF40000000, float 0xBF73A6DEC0000000, float 0x3F7E6708C0000000, float 0xBF65429040000000, float 0x3F5199FB20000000, float 0xBF40CBD4E0000000, float 0x3FADED04E0000000, float 0x3FDF7EB300000000, float 0xBFC0A92020000000, float 0xBFA17D0DA0000000, float 0xBF501611A0000000, float 0x3F7811AA80000000, float 0xBF5E679C00000000, float 0x3F43148880000000, float 0xBF23719880000000, float 0x3FCEC444C0000000, float 0x3FD754DA00000000, float 0xBFC5DBC720000000, float 0xBF9C453300000000, float 0x3F7F628220000000, float 0x3F667180C0000000, float 0xBF4B243F80000000, float 0x3F2208B6A0000000, float 0xBF000028A0000000, float 0x3FDAABB400000000, float 0xBDF1BFFF80000000, float 0xBFC8B45BA0000000, float 0x3F8E147240000000, float 0x3F88C5ADA0000000, float 0xBF41353A20000000, float 0xBF3BF71C80000000, float 0x3F0279AD20000000, float 0x3EAD70C9C0000000, float 0x3FD7843620000000, float 0xBFC75654A0000000, float 0xBFC368BC60000000, float 0x3FA31BFBE0000000, float 0x3F82CC3500000000, float 0xBF5AF253E0000000, float 0xBF32AD2B80000000, float 0x3F07AFBD00000000, float 0x3EC0A355E0000000, float 0.000000e+00, float 0xBFD5C7C560000000, float 0x3FA00B9F80000000, float 0x3FAA15D840000000, float 0xBF710A3200000000, float 0xBF61BDED20000000, float 0x3F23373980000000, float 0x3F08051460000000, float 0xBEC7B60500000000, float 0xBFD36732E0000000, float 0xBE17EECEC0000000, float 0x3FC3001C80000000, float 0xBF7BF598C0000000, float 0xBF8751E440000000, float 0x3F42372680000000, float 0x3F364D1280000000, float 0xBEEFA3D5A0000000, float 0xBED67C9A40000000, float 0.000000e+00, float 0x3FD15F9940000000, float 0xBF902B3940000000, float 0xBFA6395C80000000, float 0x3F63CED140000000, float 0x3F6079B740000000, float 0xBF1B4FB8A0000000, float 0xBF069150A0000000, float 0x3EC1295E40000000, float 0x3FD00EF380000000, float 0x3E12D41000000000, float 0xBFBFCDACC0000000, float 0x3F706CBD60000000, float 0x3F846416C0000000, float 0xBF37F8BAC0000000, float 0xBF34749720000000, float 0x3EE77C14E0000000, float 0x3ED52C8640000000, float 0.000000e+00, float 0xBFCDC14EA0000000, float 0x3F84429FE0000000, float 0x3FA367D660000000, float 0xBF59D6E940000000, float 0xBF5DC3A5E0000000, float 0x3F13151660000000, float 0x3F050F4060000000, float 0xBEB9B30800000000], align 4
@__oclc_finite_only_opt = protected local_unnamed_addr addrspace(2) constant i8 0, align 1
@__oclc_unsafe_math_opt = protected local_unnamed_addr addrspace(2) constant i8 0, align 1
@__oclc_correctly_rounded_sqrt32 = protected local_unnamed_addr addrspace(2) constant i8 0, align 1
@__oclc_daz_opt = protected local_unnamed_addr addrspace(2) constant i8 0, align 1
@__oclc_ISA_version = protected local_unnamed_addr addrspace(2) constant i32 8003, align 4

; Function Attrs: convergent noinline norecurse nounwind optnone
define spir_func ptr addrspace(4) @device_malloc(i32 noundef %0) local_unnamed_addr #0 {
  %2 = alloca i32, align 4
  store i32 %0, ptr %2, align 4, !tbaa !4
  ret ptr addrspace(4) null
}

; Function Attrs: convergent noinline norecurse nounwind optnone
define spir_func void @device_free(ptr addrspace(4) noundef %0) local_unnamed_addr #0 {
  %2 = alloca ptr addrspace(4), align 4
  store ptr addrspace(4) %0, ptr %2, align 4, !tbaa !8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func i32 @__chip__fns64(i64 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #1 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %5, label %10

5:                                                ; preds = %3
  %6 = and i32 %1, 31
  %7 = shl nuw i32 1, %6
  %8 = sext i32 %7 to i64
  %9 = and i64 %8, %0
  br label %16

10:                                               ; preds = %3
  %11 = icmp slt i32 %2, 0
  br i1 %11, label %12, label %16

12:                                               ; preds = %10
  %13 = tail call i64 @llvm.bitreverse.i64(i64 %0)
  %14 = sub i32 63, %1
  %15 = sub nsw i32 0, %2
  br label %16

16:                                               ; preds = %10, %12, %5
  %17 = phi i64 [ %9, %5 ], [ %13, %12 ], [ %0, %10 ]
  %18 = phi i32 [ 1, %5 ], [ %15, %12 ], [ %2, %10 ]
  %19 = phi i32 [ %1, %5 ], [ %14, %12 ], [ %1, %10 ]
  %20 = and i32 %19, 127
  %21 = zext nneg i32 %20 to i128
  %22 = shl nsw i128 -1, %21
  %23 = trunc i128 %22 to i64
  %24 = and i64 %17, %23
  %25 = tail call i64 @llvm.ctpop.i64(i64 %24), !range !10
  %26 = trunc i64 %25 to i32
  %27 = icmp ugt i32 %18, %26
  br i1 %27, label %85, label %28

28:                                               ; preds = %16
  %29 = and i64 %24, 4294967295
  %30 = tail call i64 @llvm.ctpop.i64(i64 %29), !range !11
  %31 = trunc i64 %30 to i32
  %32 = lshr i64 %24, 32
  %33 = icmp ugt i32 %18, %31
  %34 = select i1 %33, i64 %32, i64 %29
  %35 = select i1 %33, i32 %31, i32 0
  %36 = sub nsw i32 %18, %35
  %37 = and i64 %34, 65535
  %38 = tail call i64 @llvm.ctpop.i64(i64 %37), !range !11
  %39 = trunc i64 %38 to i32
  %40 = icmp sgt i32 %36, %39
  %41 = lshr i64 %34, 16
  %42 = select i1 %40, i64 %41, i64 %37
  %43 = select i1 %40, i32 %39, i32 0
  %44 = sub nsw i32 %36, %43
  %45 = and i64 %42, 255
  %46 = tail call i64 @llvm.ctpop.i64(i64 %45), !range !11
  %47 = trunc i64 %46 to i32
  %48 = icmp sgt i32 %44, %47
  %49 = lshr i64 %42, 8
  %50 = select i1 %48, i64 %49, i64 %45
  %51 = select i1 %48, i32 %47, i32 0
  %52 = sub nsw i32 %44, %51
  %53 = and i64 %50, 15
  %54 = tail call i64 @llvm.ctpop.i64(i64 %53), !range !11
  %55 = trunc i64 %54 to i32
  %56 = icmp sgt i32 %52, %55
  %57 = insertelement <4 x i1> poison, i1 %33, i64 0
  %58 = insertelement <4 x i1> %57, i1 %40, i64 1
  %59 = insertelement <4 x i1> %58, i1 %48, i64 2
  %60 = insertelement <4 x i1> %59, i1 %56, i64 3
  %61 = select <4 x i1> %60, <4 x i32> <i32 32, i32 16, i32 8, i32 4>, <4 x i32> zeroinitializer
  %62 = lshr i64 %50, 4
  %63 = select i1 %56, i64 %62, i64 %53
  %64 = select i1 %56, i32 %55, i32 0
  %65 = sub nsw i32 %52, %64
  %66 = and i64 %63, 3
  %67 = tail call i64 @llvm.ctpop.i64(i64 %66), !range !11
  %68 = trunc i64 %67 to i32
  %69 = icmp sgt i32 %65, %68
  %70 = lshr i64 %63, 2
  %71 = select i1 %69, i64 %70, i64 %63
  %72 = select i1 %69, i32 %68, i32 0
  %73 = sub nsw i32 %65, %72
  %74 = select i1 %69, i32 2, i32 0
  %75 = trunc i64 %71 to i32
  %76 = and i32 %75, 1
  %77 = icmp sgt i32 %73, %76
  %78 = zext i1 %77 to i32
  %79 = tail call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %61)
  %80 = or disjoint i32 %79, %74
  %81 = or disjoint i32 %80, %78
  %82 = icmp slt i32 %2, 0
  %83 = xor i32 %81, 63
  %84 = select i1 %82, i32 %83, i32 %81
  br label %85

85:                                               ; preds = %16, %28
  %86 = phi i32 [ %84, %28 ], [ -1, %16 ]
  ret i32 %86
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.bitreverse.i64(i64) #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.ctpop.i64(i64) #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func i32 @__chip__fns32(i64 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #1 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %5, label %10

5:                                                ; preds = %3
  %6 = and i32 %1, 31
  %7 = shl nuw i32 1, %6
  %8 = sext i32 %7 to i64
  %9 = and i64 %8, %0
  br label %16

10:                                               ; preds = %3
  %11 = icmp slt i32 %2, 0
  br i1 %11, label %12, label %16

12:                                               ; preds = %10
  %13 = tail call i64 @llvm.bitreverse.i64(i64 %0)
  %14 = sub i32 63, %1
  %15 = sub nsw i32 0, %2
  br label %16

16:                                               ; preds = %10, %12, %5
  %17 = phi i64 [ %9, %5 ], [ %13, %12 ], [ %0, %10 ]
  %18 = phi i32 [ 1, %5 ], [ %15, %12 ], [ %2, %10 ]
  %19 = phi i32 [ %1, %5 ], [ %14, %12 ], [ %1, %10 ]
  %20 = and i32 %19, 127
  %21 = zext nneg i32 %20 to i128
  %22 = shl nsw i128 -1, %21
  %23 = trunc i128 %22 to i64
  %24 = and i64 %17, %23
  %25 = tail call i64 @llvm.ctpop.i64(i64 %24), !range !10
  %26 = trunc i64 %25 to i32
  %27 = icmp ugt i32 %18, %26
  br i1 %27, label %85, label %28

28:                                               ; preds = %16
  %29 = and i64 %24, 4294967295
  %30 = tail call i64 @llvm.ctpop.i64(i64 %29), !range !11
  %31 = trunc i64 %30 to i32
  %32 = lshr i64 %24, 32
  %33 = icmp ugt i32 %18, %31
  %34 = select i1 %33, i64 %32, i64 %29
  %35 = select i1 %33, i32 %31, i32 0
  %36 = sub nsw i32 %18, %35
  %37 = and i64 %34, 65535
  %38 = tail call i64 @llvm.ctpop.i64(i64 %37), !range !11
  %39 = trunc i64 %38 to i32
  %40 = icmp sgt i32 %36, %39
  %41 = lshr i64 %34, 16
  %42 = select i1 %40, i64 %41, i64 %37
  %43 = select i1 %40, i32 %39, i32 0
  %44 = sub nsw i32 %36, %43
  %45 = and i64 %42, 255
  %46 = tail call i64 @llvm.ctpop.i64(i64 %45), !range !11
  %47 = trunc i64 %46 to i32
  %48 = icmp sgt i32 %44, %47
  %49 = lshr i64 %42, 8
  %50 = select i1 %48, i64 %49, i64 %45
  %51 = select i1 %48, i32 %47, i32 0
  %52 = sub nsw i32 %44, %51
  %53 = and i64 %50, 15
  %54 = tail call i64 @llvm.ctpop.i64(i64 %53), !range !11
  %55 = trunc i64 %54 to i32
  %56 = icmp sgt i32 %52, %55
  %57 = insertelement <4 x i1> poison, i1 %33, i64 0
  %58 = insertelement <4 x i1> %57, i1 %40, i64 1
  %59 = insertelement <4 x i1> %58, i1 %48, i64 2
  %60 = insertelement <4 x i1> %59, i1 %56, i64 3
  %61 = select <4 x i1> %60, <4 x i32> <i32 32, i32 16, i32 8, i32 4>, <4 x i32> zeroinitializer
  %62 = lshr i64 %50, 4
  %63 = select i1 %56, i64 %62, i64 %53
  %64 = select i1 %56, i32 %55, i32 0
  %65 = sub nsw i32 %52, %64
  %66 = and i64 %63, 3
  %67 = tail call i64 @llvm.ctpop.i64(i64 %66), !range !11
  %68 = trunc i64 %67 to i32
  %69 = icmp sgt i32 %65, %68
  %70 = lshr i64 %63, 2
  %71 = select i1 %69, i64 %70, i64 %63
  %72 = select i1 %69, i32 %68, i32 0
  %73 = sub nsw i32 %65, %72
  %74 = select i1 %69, i32 2, i32 0
  %75 = trunc i64 %71 to i32
  %76 = and i32 %75, 1
  %77 = icmp sgt i32 %73, %76
  %78 = zext i1 %77 to i32
  %79 = tail call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %61)
  %80 = or disjoint i32 %79, %74
  %81 = or disjoint i32 %80, %78
  %82 = icmp slt i32 %2, 0
  %83 = xor i32 %81, 63
  %84 = select i1 %82, i32 %83, i32 %81
  br label %85

85:                                               ; preds = %16, %28
  %86 = phi i32 [ %84, %28 ], [ -1, %16 ]
  ret i32 %86
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func noundef i64 @__chip_umul64hi(i64 noundef %0, i64 noundef %1) local_unnamed_addr #1 {
  %3 = mul i64 %1, %0
  ret i64 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func noundef i64 @__chip_mul64hi(i64 noundef %0, i64 noundef %1) local_unnamed_addr #1 {
  %3 = mul i64 %1, %0
  ret i64 %3
}

; Function Attrs: convergent nofree norecurse nounwind memory(none)
define spir_func i32 @__chip_sad(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #3 {
  br label %6

4:                                                ; preds = %6
  %5 = add i32 %16, %2
  ret i32 %5

6:                                                ; preds = %3, %6
  %7 = phi i32 [ 0, %3 ], [ %16, %6 ]
  %8 = phi i32 [ 0, %3 ], [ %17, %6 ]
  %9 = lshr i32 %0, %8
  %10 = and i32 %9, 1
  %11 = lshr i32 %1, %8
  %12 = and i32 %11, 1
  %13 = sub nsw i32 %10, %12
  %14 = tail call spir_func i32 @_Z3absi(i32 noundef %13) #38
  %15 = shl i32 %14, %8
  %16 = add i32 %15, %7
  %17 = add nuw nsw i32 %8, 1
  %18 = icmp ult i32 %8, 31
  br i1 %18, label %6, label %4
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func i32 @_Z3absi(i32 noundef) local_unnamed_addr #4

; Function Attrs: convergent nofree norecurse nounwind memory(none)
define spir_func i32 @__chip_usad(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #3 {
  br label %6

4:                                                ; preds = %6
  %5 = add i32 %16, %2
  ret i32 %5

6:                                                ; preds = %3, %6
  %7 = phi i32 [ 0, %3 ], [ %16, %6 ]
  %8 = phi i32 [ 0, %3 ], [ %17, %6 ]
  %9 = lshr i32 %0, %8
  %10 = and i32 %9, 1
  %11 = lshr i32 %1, %8
  %12 = and i32 %11, 1
  %13 = sub nsw i32 %10, %12
  %14 = tail call spir_func i32 @_Z3absi(i32 noundef %13) #38
  %15 = shl i32 %14, %8
  %16 = add i32 %15, %7
  %17 = add nuw nsw i32 %8, 1
  %18 = icmp ult i32 %8, 31
  br i1 %18, label %6, label %4
}

; Function Attrs: convergent noinline norecurse nounwind optnone
define spir_func i32 @__chip_brev(i32 noundef %0) local_unnamed_addr #0 {
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  store i32 %0, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 4, ptr %3) #39
  %4 = load i32, ptr %2, align 4, !tbaa !4
  %5 = lshr i32 %4, 16
  %6 = load i32, ptr %2, align 4, !tbaa !4
  %7 = shl i32 %6, 16
  %8 = or i32 %5, %7
  store i32 %8, ptr %2, align 4, !tbaa !4
  store i32 16711935, ptr %3, align 4, !tbaa !4
  %9 = load i32, ptr %2, align 4, !tbaa !4
  %10 = lshr i32 %9, 8
  %11 = load i32, ptr %3, align 4, !tbaa !4
  %12 = and i32 %10, %11
  %13 = load i32, ptr %2, align 4, !tbaa !4
  %14 = shl i32 %13, 8
  %15 = load i32, ptr %3, align 4, !tbaa !4
  %16 = xor i32 %15, -1
  %17 = and i32 %14, %16
  %18 = or i32 %12, %17
  store i32 %18, ptr %2, align 4, !tbaa !4
  %19 = load i32, ptr %3, align 4, !tbaa !4
  %20 = load i32, ptr %3, align 4, !tbaa !4
  %21 = shl i32 %20, 4
  %22 = xor i32 %19, %21
  store i32 %22, ptr %3, align 4, !tbaa !4
  %23 = load i32, ptr %2, align 4, !tbaa !4
  %24 = lshr i32 %23, 4
  %25 = load i32, ptr %3, align 4, !tbaa !4
  %26 = and i32 %24, %25
  %27 = load i32, ptr %2, align 4, !tbaa !4
  %28 = shl i32 %27, 4
  %29 = load i32, ptr %3, align 4, !tbaa !4
  %30 = xor i32 %29, -1
  %31 = and i32 %28, %30
  %32 = or i32 %26, %31
  store i32 %32, ptr %2, align 4, !tbaa !4
  %33 = load i32, ptr %3, align 4, !tbaa !4
  %34 = load i32, ptr %3, align 4, !tbaa !4
  %35 = shl i32 %34, 2
  %36 = xor i32 %33, %35
  store i32 %36, ptr %3, align 4, !tbaa !4
  %37 = load i32, ptr %2, align 4, !tbaa !4
  %38 = lshr i32 %37, 2
  %39 = load i32, ptr %3, align 4, !tbaa !4
  %40 = and i32 %38, %39
  %41 = load i32, ptr %2, align 4, !tbaa !4
  %42 = shl i32 %41, 2
  %43 = load i32, ptr %3, align 4, !tbaa !4
  %44 = xor i32 %43, -1
  %45 = and i32 %42, %44
  %46 = or i32 %40, %45
  store i32 %46, ptr %2, align 4, !tbaa !4
  %47 = load i32, ptr %3, align 4, !tbaa !4
  %48 = load i32, ptr %3, align 4, !tbaa !4
  %49 = shl i32 %48, 1
  %50 = xor i32 %47, %49
  store i32 %50, ptr %3, align 4, !tbaa !4
  %51 = load i32, ptr %2, align 4, !tbaa !4
  %52 = lshr i32 %51, 1
  %53 = load i32, ptr %3, align 4, !tbaa !4
  %54 = and i32 %52, %53
  %55 = load i32, ptr %2, align 4, !tbaa !4
  %56 = shl i32 %55, 1
  %57 = load i32, ptr %3, align 4, !tbaa !4
  %58 = xor i32 %57, -1
  %59 = and i32 %56, %58
  %60 = or i32 %54, %59
  store i32 %60, ptr %2, align 4, !tbaa !4
  %61 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr %3) #39
  ret i32 %61
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: convergent noinline norecurse nounwind optnone
define spir_func i64 @__chip_brevll(i64 noundef %0) local_unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  store i64 %0, ptr %2, align 8, !tbaa !12
  call void @llvm.lifetime.start.p0(i64 8, ptr %3) #39
  %4 = load i64, ptr %2, align 8, !tbaa !12
  %5 = lshr i64 %4, 32
  %6 = load i64, ptr %2, align 8, !tbaa !12
  %7 = shl i64 %6, 32
  %8 = or i64 %5, %7
  store i64 %8, ptr %2, align 8, !tbaa !12
  store i64 281470681808895, ptr %3, align 8, !tbaa !12
  %9 = load i64, ptr %2, align 8, !tbaa !12
  %10 = lshr i64 %9, 16
  %11 = load i64, ptr %3, align 8, !tbaa !12
  %12 = and i64 %10, %11
  %13 = load i64, ptr %2, align 8, !tbaa !12
  %14 = shl i64 %13, 16
  %15 = load i64, ptr %3, align 8, !tbaa !12
  %16 = xor i64 %15, -1
  %17 = and i64 %14, %16
  %18 = or i64 %12, %17
  store i64 %18, ptr %2, align 8, !tbaa !12
  %19 = load i64, ptr %3, align 8, !tbaa !12
  %20 = load i64, ptr %3, align 8, !tbaa !12
  %21 = shl i64 %20, 8
  %22 = xor i64 %19, %21
  store i64 %22, ptr %3, align 8, !tbaa !12
  %23 = load i64, ptr %2, align 8, !tbaa !12
  %24 = lshr i64 %23, 8
  %25 = load i64, ptr %3, align 8, !tbaa !12
  %26 = and i64 %24, %25
  %27 = load i64, ptr %2, align 8, !tbaa !12
  %28 = shl i64 %27, 8
  %29 = load i64, ptr %3, align 8, !tbaa !12
  %30 = xor i64 %29, -1
  %31 = and i64 %28, %30
  %32 = or i64 %26, %31
  store i64 %32, ptr %2, align 8, !tbaa !12
  %33 = load i64, ptr %3, align 8, !tbaa !12
  %34 = load i64, ptr %3, align 8, !tbaa !12
  %35 = shl i64 %34, 4
  %36 = xor i64 %33, %35
  store i64 %36, ptr %3, align 8, !tbaa !12
  %37 = load i64, ptr %2, align 8, !tbaa !12
  %38 = lshr i64 %37, 4
  %39 = load i64, ptr %3, align 8, !tbaa !12
  %40 = and i64 %38, %39
  %41 = load i64, ptr %2, align 8, !tbaa !12
  %42 = shl i64 %41, 4
  %43 = load i64, ptr %3, align 8, !tbaa !12
  %44 = xor i64 %43, -1
  %45 = and i64 %42, %44
  %46 = or i64 %40, %45
  store i64 %46, ptr %2, align 8, !tbaa !12
  %47 = load i64, ptr %3, align 8, !tbaa !12
  %48 = load i64, ptr %3, align 8, !tbaa !12
  %49 = shl i64 %48, 2
  %50 = xor i64 %47, %49
  store i64 %50, ptr %3, align 8, !tbaa !12
  %51 = load i64, ptr %2, align 8, !tbaa !12
  %52 = lshr i64 %51, 2
  %53 = load i64, ptr %3, align 8, !tbaa !12
  %54 = and i64 %52, %53
  %55 = load i64, ptr %2, align 8, !tbaa !12
  %56 = shl i64 %55, 2
  %57 = load i64, ptr %3, align 8, !tbaa !12
  %58 = xor i64 %57, -1
  %59 = and i64 %56, %58
  %60 = or i64 %54, %59
  store i64 %60, ptr %2, align 8, !tbaa !12
  %61 = load i64, ptr %3, align 8, !tbaa !12
  %62 = load i64, ptr %3, align 8, !tbaa !12
  %63 = shl i64 %62, 1
  %64 = xor i64 %61, %63
  store i64 %64, ptr %3, align 8, !tbaa !12
  %65 = load i64, ptr %2, align 8, !tbaa !12
  %66 = lshr i64 %65, 1
  %67 = load i64, ptr %3, align 8, !tbaa !12
  %68 = and i64 %66, %67
  %69 = load i64, ptr %2, align 8, !tbaa !12
  %70 = shl i64 %69, 1
  %71 = load i64, ptr %3, align 8, !tbaa !12
  %72 = xor i64 %71, -1
  %73 = and i64 %70, %72
  %74 = or i64 %68, %73
  store i64 %74, ptr %2, align 8, !tbaa !12
  %75 = load i64, ptr %2, align 8, !tbaa !12
  call void @llvm.lifetime.end.p0(i64 8, ptr %3) #39
  ret i64 %75
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func i32 @__chip_byte_perm(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #1 {
  %4 = alloca %struct.uchar2Holder, align 4
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #39
  %5 = lshr i32 %2, 8
  %6 = lshr i32 %2, 16
  %7 = lshr i32 %2, 24
  store i32 %0, ptr %4, align 4, !tbaa !14
  %8 = getelementptr inbounds [2 x i32], ptr %4, i32 0, i32 1
  store i32 %1, ptr %8, align 4, !tbaa !14
  %9 = and i32 %2, 255
  %10 = getelementptr inbounds [8 x i8], ptr %4, i32 0, i32 %9
  %11 = load i8, ptr %10, align 1, !tbaa !14
  %12 = and i32 %5, 255
  %13 = getelementptr inbounds [8 x i8], ptr %4, i32 0, i32 %12
  %14 = load i8, ptr %13, align 1, !tbaa !14
  %15 = and i32 %6, 255
  %16 = getelementptr inbounds [8 x i8], ptr %4, i32 0, i32 %15
  %17 = load i8, ptr %16, align 1, !tbaa !14
  %18 = getelementptr inbounds [8 x i8], ptr %4, i32 0, i32 %7
  %19 = load i8, ptr %18, align 1, !tbaa !14
  %20 = zext i8 %19 to i32
  %21 = shl nuw i32 %20, 24
  %22 = zext i8 %17 to i32
  %23 = shl nuw nsw i32 %22, 16
  %24 = zext i8 %14 to i32
  %25 = shl nuw nsw i32 %24, 8
  %26 = zext i8 %11 to i32
  %27 = or disjoint i32 %25, %26
  %28 = or disjoint i32 %27, %23
  %29 = or disjoint i32 %28, %21
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #39
  ret i32 %29
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i32 @__chip_ffs(i32 noundef %0) local_unnamed_addr #6 {
  %2 = icmp eq i32 %0, 0
  br i1 %2, label %6, label %3

3:                                                ; preds = %1
  %4 = tail call spir_func i32 @_Z3ctzj(i32 noundef %0) #38
  %5 = add i32 %4, 1
  br label %6

6:                                                ; preds = %1, %3
  %7 = phi i32 [ %5, %3 ], [ 0, %1 ]
  ret i32 %7
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func i32 @_Z3ctzj(i32 noundef) local_unnamed_addr #4

; Function Attrs: nofree norecurse nosync nounwind memory(none)
define spir_func i32 @__chip_ctzll(i64 noundef %0) local_unnamed_addr #7 {
  %2 = icmp eq i64 %0, 0
  br i1 %2, label %13, label %3

3:                                                ; preds = %1
  %4 = and i64 %0, 1
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %6, label %13

6:                                                ; preds = %3, %6
  %7 = phi i32 [ %10, %6 ], [ 0, %3 ]
  %8 = phi i64 [ %9, %6 ], [ %0, %3 ]
  %9 = ashr exact i64 %8, 1
  %10 = add nuw nsw i32 %7, 1
  %11 = and i64 %8, 2
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %6, label %13

13:                                               ; preds = %6, %3, %1
  %14 = phi i32 [ 64, %1 ], [ 0, %3 ], [ %10, %6 ]
  ret i32 %14
}

; Function Attrs: nofree norecurse nosync nounwind memory(none)
define spir_func i32 @__chip_ffsll(i64 noundef %0) local_unnamed_addr #7 {
  %2 = icmp eq i64 %0, 0
  br i1 %2, label %15, label %3

3:                                                ; preds = %1
  %4 = and i64 %0, 1
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %6, label %15

6:                                                ; preds = %3, %6
  %7 = phi i32 [ %10, %6 ], [ 0, %3 ]
  %8 = phi i64 [ %9, %6 ], [ %0, %3 ]
  %9 = ashr exact i64 %8, 1
  %10 = add nuw nsw i32 %7, 1
  %11 = and i64 %8, 2
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %6, label %13

13:                                               ; preds = %6
  %14 = add nuw nsw i32 %7, 2
  br label %15

15:                                               ; preds = %3, %13, %1
  %16 = phi i32 [ 0, %1 ], [ 1, %3 ], [ %14, %13 ]
  ret i32 %16
}

; Function Attrs: nofree norecurse nosync nounwind memory(none)
define spir_func i32 @__lastbit_u32_u64(i64 noundef %0) local_unnamed_addr #7 {
  %2 = icmp eq i64 %0, 0
  br i1 %2, label %13, label %3

3:                                                ; preds = %1
  %4 = and i64 %0, 1
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %6, label %13

6:                                                ; preds = %3, %6
  %7 = phi i32 [ %10, %6 ], [ 0, %3 ]
  %8 = phi i64 [ %9, %6 ], [ %0, %3 ]
  %9 = ashr exact i64 %8, 1
  %10 = add nuw nsw i32 %7, 1
  %11 = and i64 %8, 2
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %6, label %13

13:                                               ; preds = %6, %3, %1
  %14 = phi i32 [ -1, %1 ], [ 0, %3 ], [ %10, %6 ]
  ret i32 %14
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func i32 @__bitextract_u32(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #1 {
  %4 = and i32 %2, 31
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %14, label %6

6:                                                ; preds = %3
  %7 = add i32 %1, %2
  %8 = sub i32 0, %7
  %9 = and i32 %8, 31
  %10 = shl i32 %0, %9
  %11 = sub i32 0, %2
  %12 = and i32 %11, 31
  %13 = lshr i32 %10, %12
  br label %14

14:                                               ; preds = %3, %6
  %15 = phi i32 [ %13, %6 ], [ 0, %3 ]
  ret i32 %15
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func i64 @__bitextract_u64(i64 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #1 {
  %4 = and i32 %2, 63
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %16, label %6

6:                                                ; preds = %3
  %7 = zext nneg i32 %4 to i64
  %8 = sub i32 0, %1
  %9 = zext i32 %8 to i64
  %10 = sub nsw i64 %9, %7
  %11 = and i64 %10, 63
  %12 = shl i64 %0, %11
  %13 = sub nsw i64 0, %7
  %14 = and i64 %13, 63
  %15 = lshr i64 %12, %14
  br label %16

16:                                               ; preds = %3, %6
  %17 = phi i64 [ %15, %6 ], [ 0, %3 ]
  ret i64 %17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func i32 @__chip_bitinsert_u32(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #1 {
  %5 = and i32 %2, 31
  %6 = and i32 %3, 31
  %7 = shl nsw i32 -1, %6
  %8 = xor i32 %7, -1
  %9 = shl i32 %8, %5
  %10 = xor i32 %9, -1
  %11 = and i32 %10, %0
  %12 = and i32 %8, %1
  %13 = shl i32 %12, %5
  %14 = or i32 %11, %13
  ret i32 %14
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func i64 @__chip_bitinsert_u64(i64 noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3) local_unnamed_addr #1 {
  %5 = and i64 %2, 63
  %6 = and i64 %3, 63
  %7 = shl nsw i64 -1, %6
  %8 = xor i64 %7, -1
  %9 = shl i64 %8, %5
  %10 = xor i64 %9, -1
  %11 = and i64 %10, %0
  %12 = and i64 %8, %1
  %13 = shl i64 %12, %5
  %14 = or i64 %11, %13
  ret i64 %14
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func i32 @__chip_funnelshift_l(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #1 {
  %4 = and i32 %2, 31
  %5 = shl i32 %0, %4
  ret i32 %5
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func i32 @__chip_funnelshift_lc(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #1 {
  %4 = and i32 %2, 31
  %5 = shl i32 %0, %4
  %6 = tail call i32 @llvm.usub.sat.i32(i32 32, i32 %2)
  %7 = and i32 %6, 31
  %8 = lshr i32 %5, %7
  ret i32 %8
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.usub.sat.i32(i32, i32) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func i32 @__chip_funnelshift_r(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #1 {
  %4 = zext i32 %1 to i64
  %5 = shl nuw i64 %4, 32
  %6 = zext i32 %0 to i64
  %7 = or disjoint i64 %5, %6
  %8 = and i32 %2, 31
  %9 = zext nneg i32 %8 to i64
  %10 = lshr i64 %7, %9
  %11 = trunc i64 %10 to i32
  ret i32 %11
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func i32 @__chip_funnelshift_rc(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #1 {
  %4 = zext i32 %1 to i64
  %5 = shl nuw i64 %4, 32
  %6 = zext i32 %0 to i64
  %7 = or disjoint i64 %5, %6
  %8 = and i32 %2, 31
  %9 = zext nneg i32 %8 to i64
  %10 = lshr i64 %7, %9
  %11 = trunc i64 %10 to i32
  %12 = tail call i32 @llvm.usub.sat.i32(i32 32, i32 %2)
  %13 = and i32 %12, 31
  %14 = shl i32 %11, %13
  ret i32 %14
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func noundef float @__chip_saturate_f32(float noundef %0) local_unnamed_addr #1 {
  %2 = fcmp olt float %0, 0.000000e+00
  %3 = fcmp ogt float %0, 1.000000e+00
  %4 = select i1 %3, float 1.000000e+00, float %0
  %5 = select i1 %2, float 0.000000e+00, float %4
  ret float %5
}

; Function Attrs: convergent nofree norecurse nounwind memory(none)
define spir_func float @__chip_jn_f32(i32 noundef %0, float noundef %1) local_unnamed_addr #3 {
  switch i32 %0, label %7 [
    i32 0, label %3
    i32 1, label %5
  ]

3:                                                ; preds = %2
  %4 = tail call spir_func float @__ocml_j0_f32(float noundef %1) #38
  br label %22

5:                                                ; preds = %2
  %6 = tail call spir_func float @__ocml_j1_f32(float noundef %1) #38
  br label %22

7:                                                ; preds = %2
  %8 = tail call spir_func float @__ocml_j0_f32(float noundef %1) #38
  %9 = tail call spir_func float @__ocml_j1_f32(float noundef %1) #38
  %10 = icmp sgt i32 %0, 1
  br i1 %10, label %11, label %22

11:                                               ; preds = %7, %11
  %12 = phi i32 [ %20, %11 ], [ 1, %7 ]
  %13 = phi float [ %19, %11 ], [ %9, %7 ]
  %14 = phi float [ %13, %11 ], [ %8, %7 ]
  %15 = shl nuw nsw i32 %12, 1
  %16 = sitofp i32 %15 to float
  %17 = fdiv float %16, %1, !fpmath !15
  %18 = fneg float %14
  %19 = tail call float @llvm.fmuladd.f32(float %17, float %13, float %18)
  %20 = add nuw nsw i32 %12, 1
  %21 = icmp slt i32 %20, %0
  br i1 %21, label %11, label %22

22:                                               ; preds = %11, %7, %5, %3
  %23 = phi float [ %4, %3 ], [ %6, %5 ], [ %9, %7 ], [ %19, %11 ]
  ret float %23
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float) #2

; Function Attrs: convergent nofree norecurse nounwind memory(none)
define spir_func double @__chip_jn_f64(i32 noundef %0, double noundef %1) local_unnamed_addr #3 {
  switch i32 %0, label %7 [
    i32 0, label %3
    i32 1, label %5
  ]

3:                                                ; preds = %2
  %4 = tail call spir_func double @__ocml_j0_f64(double noundef %1) #38
  br label %22

5:                                                ; preds = %2
  %6 = tail call spir_func double @__ocml_j1_f64(double noundef %1) #38
  br label %22

7:                                                ; preds = %2
  %8 = tail call spir_func double @__ocml_j0_f64(double noundef %1) #38
  %9 = tail call spir_func double @__ocml_j1_f64(double noundef %1) #38
  %10 = icmp sgt i32 %0, 1
  br i1 %10, label %11, label %22

11:                                               ; preds = %7, %11
  %12 = phi i32 [ %20, %11 ], [ 1, %7 ]
  %13 = phi double [ %19, %11 ], [ %9, %7 ]
  %14 = phi double [ %13, %11 ], [ %8, %7 ]
  %15 = shl nuw nsw i32 %12, 1
  %16 = sitofp i32 %15 to double
  %17 = fdiv double %16, %1
  %18 = fneg double %14
  %19 = tail call double @llvm.fmuladd.f64(double %17, double %13, double %18)
  %20 = add nuw nsw i32 %12, 1
  %21 = icmp slt i32 %20, %0
  br i1 %21, label %11, label %22

22:                                               ; preds = %11, %7, %5, %3
  %23 = phi double [ %4, %3 ], [ %6, %5 ], [ %9, %7 ], [ %19, %11 ]
  ret double %23
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fmuladd.f64(double, double, double) #2

; Function Attrs: convergent nofree norecurse nounwind memory(none)
define spir_func float @__chip_yn_f32(i32 noundef %0, float noundef %1) local_unnamed_addr #3 {
  switch i32 %0, label %7 [
    i32 0, label %3
    i32 1, label %5
  ]

3:                                                ; preds = %2
  %4 = tail call spir_func float @__ocml_y0_f32(float noundef %1) #38
  br label %22

5:                                                ; preds = %2
  %6 = tail call spir_func float @__ocml_y1_f32(float noundef %1) #38
  br label %22

7:                                                ; preds = %2
  %8 = tail call spir_func float @__ocml_y0_f32(float noundef %1) #38
  %9 = tail call spir_func float @__ocml_y1_f32(float noundef %1) #38
  %10 = icmp sgt i32 %0, 1
  br i1 %10, label %11, label %22

11:                                               ; preds = %7, %11
  %12 = phi i32 [ %20, %11 ], [ 1, %7 ]
  %13 = phi float [ %19, %11 ], [ %9, %7 ]
  %14 = phi float [ %13, %11 ], [ %8, %7 ]
  %15 = shl nuw nsw i32 %12, 1
  %16 = sitofp i32 %15 to float
  %17 = fdiv float %16, %1, !fpmath !15
  %18 = fneg float %14
  %19 = tail call float @llvm.fmuladd.f32(float %17, float %13, float %18)
  %20 = add nuw nsw i32 %12, 1
  %21 = icmp slt i32 %20, %0
  br i1 %21, label %11, label %22

22:                                               ; preds = %11, %7, %5, %3
  %23 = phi float [ %4, %3 ], [ %6, %5 ], [ %9, %7 ], [ %19, %11 ]
  ret float %23
}

; Function Attrs: convergent nofree norecurse nounwind memory(none)
define spir_func double @__chip_yn_f64(i32 noundef %0, double noundef %1) local_unnamed_addr #3 {
  switch i32 %0, label %7 [
    i32 0, label %3
    i32 1, label %5
  ]

3:                                                ; preds = %2
  %4 = tail call spir_func double @__ocml_y0_f64(double noundef %1) #38
  br label %22

5:                                                ; preds = %2
  %6 = tail call spir_func double @__ocml_y1_f64(double noundef %1) #38
  br label %22

7:                                                ; preds = %2
  %8 = tail call spir_func double @__ocml_y0_f64(double noundef %1) #38
  %9 = tail call spir_func double @__ocml_y1_f64(double noundef %1) #38
  %10 = icmp sgt i32 %0, 1
  br i1 %10, label %11, label %22

11:                                               ; preds = %7, %11
  %12 = phi i32 [ %20, %11 ], [ 1, %7 ]
  %13 = phi double [ %19, %11 ], [ %9, %7 ]
  %14 = phi double [ %13, %11 ], [ %8, %7 ]
  %15 = shl nuw nsw i32 %12, 1
  %16 = sitofp i32 %15 to double
  %17 = fdiv double %16, %1
  %18 = fneg double %14
  %19 = tail call double @llvm.fmuladd.f64(double %17, double %13, double %18)
  %20 = add nuw nsw i32 %12, 1
  %21 = icmp slt i32 %20, %0
  br i1 %21, label %11, label %22

22:                                               ; preds = %11, %7, %5, %3
  %23 = phi double [ %4, %3 ], [ %6, %5 ], [ %9, %7 ], [ %19, %11 ]
  ret double %23
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i64 @__chip_llrint_f32(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4rintf(float noundef %0) #38
  %3 = fptosi float %2 to i64
  ret i64 %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4rintf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i64 @__chip_llrint_f64(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4rintd(double noundef %0) #38
  %3 = fptosi double %2 to i64
  ret i64 %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4rintd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i64 @__chip_llround_f32(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z5roundf(float noundef %0) #38
  %3 = fptosi float %2 to i64
  ret i64 %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z5roundf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i64 @__chip_llround_f64(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z5roundd(double noundef %0) #38
  %3 = fptosi double %2 to i64
  ret i64 %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z5roundd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i64 @__chip_lrint_f32(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4rintf(float noundef %0) #38
  %3 = fptosi float %2 to i64
  ret i64 %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i64 @__chip_lrint_f64(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4rintd(double noundef %0) #38
  %3 = fptosi double %2 to i64
  ret i64 %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i64 @__chip_lround_f32(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z5roundf(float noundef %0) #38
  %3 = fptosi float %2 to i64
  ret i64 %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i64 @__chip_lround_f64(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z5roundd(double noundef %0) #38
  %3 = fptosi double %2 to i64
  ret i64 %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_norm4d_f32(float noundef %0, float noundef %1, float noundef %2, float noundef %3) local_unnamed_addr #6 {
  %5 = insertelement <4 x float> poison, float %0, i64 0
  %6 = insertelement <4 x float> %5, float %1, i64 1
  %7 = insertelement <4 x float> %6, float %2, i64 2
  %8 = insertelement <4 x float> %7, float %3, i64 3
  %9 = tail call spir_func float @_Z6lengthDv4_f(<4 x float> noundef %8) #38
  ret float %9
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z6lengthDv4_f(<4 x float> noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_norm4d_f64(double noundef %0, double noundef %1, double noundef %2, double noundef %3) local_unnamed_addr #6 {
  %5 = insertelement <4 x double> poison, double %0, i64 0
  %6 = insertelement <4 x double> %5, double %1, i64 1
  %7 = insertelement <4 x double> %6, double %2, i64 2
  %8 = insertelement <4 x double> %7, double %3, i64 3
  %9 = tail call spir_func double @_Z6lengthDv4_d(<4 x double> noundef %8) #38
  ret double %9
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z6lengthDv4_d(<4 x double> noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_norm3d_f32(float noundef %0, float noundef %1, float noundef %2) local_unnamed_addr #6 {
  %4 = insertelement <4 x float> <float poison, float poison, float poison, float 0.000000e+00>, float %0, i64 0
  %5 = insertelement <4 x float> %4, float %1, i64 1
  %6 = insertelement <4 x float> %5, float %2, i64 2
  %7 = tail call spir_func float @_Z6lengthDv4_f(<4 x float> noundef %6) #38
  ret float %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_norm3d_f64(double noundef %0, double noundef %1, double noundef %2) local_unnamed_addr #6 {
  %4 = insertelement <4 x double> <double poison, double poison, double poison, double 0.000000e+00>, double %0, i64 0
  %5 = insertelement <4 x double> %4, double %1, i64 1
  %6 = insertelement <4 x double> %5, double %2, i64 2
  %7 = tail call spir_func double @_Z6lengthDv4_d(<4 x double> noundef %6) #38
  ret double %7
}

; Function Attrs: convergent nofree norecurse nounwind memory(read, inaccessiblemem: none)
define spir_func float @__chip_norm_f32(i32 noundef %0, ptr addrspace(4) nocapture noundef readonly %1) local_unnamed_addr #8 {
  %3 = icmp eq i32 %0, 0
  br i1 %3, label %13, label %4

4:                                                ; preds = %2, %4
  %5 = phi float [ %10, %4 ], [ 0.000000e+00, %2 ]
  %6 = phi ptr addrspace(4) [ %11, %4 ], [ %1, %2 ]
  %7 = phi i32 [ %8, %4 ], [ %0, %2 ]
  %8 = add nsw i32 %7, -1
  %9 = load float, ptr addrspace(4) %6, align 4, !tbaa !16
  %10 = tail call float @llvm.fmuladd.f32(float %9, float %9, float %5)
  %11 = getelementptr inbounds float, ptr addrspace(4) %6, i32 1
  %12 = icmp eq i32 %8, 0
  br i1 %12, label %13, label %4

13:                                               ; preds = %4, %2
  %14 = phi float [ 0.000000e+00, %2 ], [ %10, %4 ]
  %15 = tail call spir_func float @_Z4sqrtf(float noundef %14) #38, !fpmath !18
  ret float %15
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4sqrtf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent nofree norecurse nounwind memory(read, inaccessiblemem: none)
define spir_func double @__chip_norm_f64(i32 noundef %0, ptr addrspace(4) nocapture noundef readonly %1) local_unnamed_addr #8 {
  %3 = icmp eq i32 %0, 0
  br i1 %3, label %15, label %4

4:                                                ; preds = %2, %4
  %5 = phi float [ %12, %4 ], [ 0.000000e+00, %2 ]
  %6 = phi ptr addrspace(4) [ %13, %4 ], [ %1, %2 ]
  %7 = phi i32 [ %8, %4 ], [ %0, %2 ]
  %8 = add nsw i32 %7, -1
  %9 = load double, ptr addrspace(4) %6, align 8, !tbaa !19
  %10 = fpext float %5 to double
  %11 = tail call double @llvm.fmuladd.f64(double %9, double %9, double %10)
  %12 = fptrunc double %11 to float
  %13 = getelementptr inbounds double, ptr addrspace(4) %6, i32 1
  %14 = icmp eq i32 %8, 0
  br i1 %14, label %15, label %4

15:                                               ; preds = %4, %2
  %16 = phi float [ 0.000000e+00, %2 ], [ %12, %4 ]
  %17 = tail call spir_func float @_Z4sqrtf(float noundef %16) #38, !fpmath !18
  %18 = fpext float %17 to double
  ret double %18
}

; Function Attrs: convergent nofree norecurse nounwind memory(read, inaccessiblemem: none)
define spir_func float @__chip_rnorm_f32(i32 noundef %0, ptr addrspace(4) nocapture noundef readonly %1) local_unnamed_addr #8 {
  %3 = icmp eq i32 %0, 0
  br i1 %3, label %13, label %4

4:                                                ; preds = %2, %4
  %5 = phi float [ %10, %4 ], [ 0.000000e+00, %2 ]
  %6 = phi ptr addrspace(4) [ %11, %4 ], [ %1, %2 ]
  %7 = phi i32 [ %8, %4 ], [ %0, %2 ]
  %8 = add nsw i32 %7, -1
  %9 = load float, ptr addrspace(4) %6, align 4, !tbaa !16
  %10 = tail call float @llvm.fmuladd.f32(float %9, float %9, float %5)
  %11 = getelementptr inbounds float, ptr addrspace(4) %6, i32 1
  %12 = icmp eq i32 %8, 0
  br i1 %12, label %13, label %4

13:                                               ; preds = %4, %2
  %14 = phi float [ 0.000000e+00, %2 ], [ %10, %4 ]
  %15 = tail call spir_func float @_Z4sqrtf(float noundef %14) #38, !fpmath !18
  ret float %15
}

; Function Attrs: convergent nofree norecurse nounwind memory(read, inaccessiblemem: none)
define spir_func double @__chip_rnorm_f64(i32 noundef %0, ptr addrspace(4) nocapture noundef readonly %1) local_unnamed_addr #8 {
  %3 = icmp eq i32 %0, 0
  br i1 %3, label %13, label %4

4:                                                ; preds = %2, %4
  %5 = phi double [ %10, %4 ], [ 0.000000e+00, %2 ]
  %6 = phi ptr addrspace(4) [ %11, %4 ], [ %1, %2 ]
  %7 = phi i32 [ %8, %4 ], [ %0, %2 ]
  %8 = add nsw i32 %7, -1
  %9 = load double, ptr addrspace(4) %6, align 8, !tbaa !19
  %10 = tail call double @llvm.fmuladd.f64(double %9, double %9, double %5)
  %11 = getelementptr inbounds double, ptr addrspace(4) %6, i32 1
  %12 = icmp eq i32 %8, 0
  br i1 %12, label %13, label %4

13:                                               ; preds = %4, %2
  %14 = phi double [ 0.000000e+00, %2 ], [ %10, %4 ]
  %15 = tail call spir_func double @_Z4sqrtd(double noundef %14) #38
  ret double %15
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4sqrtd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write)
define spir_func void @__chip_sincospi_f32(float noundef %0, ptr addrspace(4) nocapture noundef writeonly %1, ptr addrspace(4) nocapture noundef writeonly %2) local_unnamed_addr #9 {
  %4 = tail call spir_func float @_Z5sinpif(float noundef %0) #38
  store float %4, ptr addrspace(4) %1, align 4, !tbaa !16
  %5 = tail call spir_func float @_Z5cospif(float noundef %0) #38
  store float %5, ptr addrspace(4) %2, align 4, !tbaa !16
  ret void
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z5sinpif(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z5cospif(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write)
define spir_func void @__chip_sincospi_f64(double noundef %0, ptr addrspace(4) nocapture noundef writeonly %1, ptr addrspace(4) nocapture noundef writeonly %2) local_unnamed_addr #9 {
  %4 = tail call spir_func double @_Z5sinpid(double noundef %0) #38
  store double %4, ptr addrspace(4) %1, align 8, !tbaa !19
  %5 = tail call spir_func double @_Z5cospid(double noundef %0) #38
  store double %5, ptr addrspace(4) %2, align 8, !tbaa !19
  ret void
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z5sinpid(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z5cospid(double noundef) local_unnamed_addr #4

; Function Attrs: convergent norecurse nounwind
define spir_func float @__chip_frexp_f32(float noundef %0, ptr addrspace(4) nocapture noundef writeonly %1) local_unnamed_addr #10 {
  %3 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %4 = addrspacecast ptr %3 to ptr addrspace(4)
  %5 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %0, ptr addrspace(4) noundef %4) #40
  %6 = load i32, ptr %3, align 4, !tbaa !4
  store i32 %6, ptr addrspace(4) %1, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  ret float %5
}

; Function Attrs: convergent nounwind
declare spir_func float @_Z5frexpfPU3AS4i(float noundef, ptr addrspace(4) noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func double @__chip_frexp_f64(double noundef %0, ptr addrspace(4) nocapture noundef writeonly %1) local_unnamed_addr #10 {
  %3 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %4 = addrspacecast ptr %3 to ptr addrspace(4)
  %5 = call spir_func double @_Z5frexpdPU3AS4i(double noundef %0, ptr addrspace(4) noundef %4) #40
  %6 = load i32, ptr %3, align 4, !tbaa !4
  store i32 %6, ptr addrspace(4) %1, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  ret double %5
}

; Function Attrs: convergent nounwind
declare spir_func double @_Z5frexpdPU3AS4i(double noundef, ptr addrspace(4) noundef) local_unnamed_addr #11

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_ldexp_f32(float noundef %0, i32 noundef %1) local_unnamed_addr #6 {
  %3 = tail call spir_func float @_Z5ldexpfi(float noundef %0, i32 noundef %1) #38
  ret float %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z5ldexpfi(float noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_ldexp_f64(double noundef %0, i32 noundef %1) local_unnamed_addr #6 {
  %3 = tail call spir_func double @_Z5ldexpdi(double noundef %0, i32 noundef %1) #38
  ret double %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z5ldexpdi(double noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: convergent norecurse nounwind
define spir_func float @__chip_modf_f32(float noundef %0, ptr addrspace(4) nocapture noundef writeonly %1) local_unnamed_addr #10 {
  %3 = alloca float, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %4 = addrspacecast ptr %3 to ptr addrspace(4)
  %5 = call spir_func float @_Z4modffPU3AS4f(float noundef %0, ptr addrspace(4) noundef %4) #40
  %6 = load float, ptr %3, align 4, !tbaa !16
  store float %6, ptr addrspace(4) %1, align 4, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  ret float %5
}

; Function Attrs: convergent nounwind
declare spir_func float @_Z4modffPU3AS4f(float noundef, ptr addrspace(4) noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func double @__chip_modf_f64(double noundef %0, ptr addrspace(4) nocapture noundef writeonly %1) local_unnamed_addr #10 {
  %3 = alloca double, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #39
  %4 = addrspacecast ptr %3 to ptr addrspace(4)
  %5 = call spir_func double @_Z4modfdPU3AS4d(double noundef %0, ptr addrspace(4) noundef %4) #40
  %6 = load double, ptr %3, align 8, !tbaa !19
  store double %6, ptr addrspace(4) %1, align 8, !tbaa !19
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #39
  ret double %5
}

; Function Attrs: convergent nounwind
declare spir_func double @_Z4modfdPU3AS4d(double noundef, ptr addrspace(4) noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func float @__chip_remquo_f32(float noundef %0, float noundef %1, ptr addrspace(4) nocapture noundef writeonly %2) local_unnamed_addr #10 {
  %4 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %5 = addrspacecast ptr %4 to ptr addrspace(4)
  %6 = call spir_func float @_Z6remquoffPU3AS4i(float noundef %0, float noundef %1, ptr addrspace(4) noundef %5) #40
  %7 = load i32, ptr %4, align 4, !tbaa !4
  store i32 %7, ptr addrspace(4) %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  ret float %6
}

; Function Attrs: convergent nounwind
declare spir_func float @_Z6remquoffPU3AS4i(float noundef, float noundef, ptr addrspace(4) noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func double @__chip_remquo_f64(double noundef %0, double noundef %1, ptr addrspace(4) nocapture noundef writeonly %2) local_unnamed_addr #10 {
  %4 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %5 = addrspacecast ptr %4 to ptr addrspace(4)
  %6 = call spir_func double @_Z6remquoddPU3AS4i(double noundef %0, double noundef %1, ptr addrspace(4) noundef %5) #40
  %7 = load i32, ptr %4, align 4, !tbaa !4
  store i32 %7, ptr addrspace(4) %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  ret double %6
}

; Function Attrs: convergent nounwind
declare spir_func double @_Z6remquoddPU3AS4i(double noundef, double noundef, ptr addrspace(4) noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func float @__chip_sincos_f32(float noundef %0, ptr addrspace(4) nocapture noundef writeonly %1) local_unnamed_addr #10 {
  %3 = alloca float, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %4 = addrspacecast ptr %3 to ptr addrspace(4)
  %5 = call spir_func float @_Z6sincosfPU3AS4f(float noundef %0, ptr addrspace(4) noundef %4) #40
  %6 = load float, ptr %3, align 4, !tbaa !16
  store float %6, ptr addrspace(4) %1, align 4, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  ret float %5
}

; Function Attrs: convergent nounwind
declare spir_func float @_Z6sincosfPU3AS4f(float noundef, ptr addrspace(4) noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func double @__chip_sincos_f64(double noundef %0, ptr addrspace(4) nocapture noundef writeonly %1) local_unnamed_addr #10 {
  %3 = alloca double, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #39
  %4 = addrspacecast ptr %3 to ptr addrspace(4)
  %5 = call spir_func double @_Z6sincosdPU3AS4d(double noundef %0, ptr addrspace(4) noundef %4) #40
  %6 = load double, ptr %3, align 8, !tbaa !19
  store double %6, ptr addrspace(4) %1, align 8, !tbaa !19
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #39
  ret double %5
}

; Function Attrs: convergent nounwind
declare spir_func double @_Z6sincosdPU3AS4d(double noundef, ptr addrspace(4) noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func void @__chip_syncthreads() local_unnamed_addr #10 {
  tail call spir_func void @_Z7barrierj(i32 noundef 1) #40
  ret void
}

; Function Attrs: convergent nounwind
declare spir_func void @_Z7barrierj(i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func void @__chip_threadfence_block() local_unnamed_addr #10 {
  tail call spir_func void @_Z9mem_fencej(i32 noundef 1) #40
  ret void
}

; Function Attrs: convergent nounwind
declare spir_func void @_Z9mem_fencej(i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func void @__chip_threadfence() local_unnamed_addr #10 {
  tail call spir_func void @_Z9mem_fencej(i32 noundef 3) #40
  ret void
}

; Function Attrs: convergent norecurse nounwind
define spir_func void @__chip_threadfence_system() local_unnamed_addr #10 {
  tail call spir_func void @_Z9mem_fencej(i32 noundef 3) #40
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define spir_func noundef ptr addrspace(4) @__chip_memset(ptr addrspace(4) noundef returned writeonly %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #12 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:                                                ; preds = %3
  %6 = trunc i32 %1 to i8
  tail call void @llvm.memset.p4.i32(ptr addrspace(4) align 1 %0, i8 %6, i32 %2, i1 false), !tbaa !14
  br label %7

7:                                                ; preds = %5, %3
  ret ptr addrspace(4) %0
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p4.i32(ptr addrspace(4) nocapture writeonly, i8, i32, i1 immarg) #13

; Function Attrs: nofree norecurse nosync nounwind memory(argmem: readwrite)
define spir_func noundef ptr addrspace(4) @__chip_memcpy(ptr addrspace(4) noundef returned writeonly %0, ptr addrspace(4) nocapture noundef readonly %1, i32 noundef %2) local_unnamed_addr #14 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %25, label %5

5:                                                ; preds = %3
  %6 = ptrtoint ptr addrspace(4) %0 to i32
  %7 = ptrtoint ptr addrspace(4) %1 to i32
  %8 = icmp ult i32 %2, 4
  %9 = sub i32 %6, %7
  %10 = icmp ult i32 %9, 4
  %11 = or i1 %8, %10
  br i1 %11, label %23, label %12

12:                                               ; preds = %5
  %13 = and i32 %2, -4
  br label %14

14:                                               ; preds = %14, %12
  %15 = phi i32 [ 0, %12 ], [ %19, %14 ]
  %16 = getelementptr inbounds i8, ptr addrspace(4) %1, i32 %15
  %17 = load <4 x i8>, ptr addrspace(4) %16, align 1, !tbaa !14
  %18 = getelementptr inbounds i8, ptr addrspace(4) %0, i32 %15
  store <4 x i8> %17, ptr addrspace(4) %18, align 1, !tbaa !14
  %19 = add nuw i32 %15, 4
  %20 = icmp eq i32 %19, %13
  br i1 %20, label %21, label %14, !llvm.loop !21

21:                                               ; preds = %14
  %22 = icmp eq i32 %13, %2
  br i1 %22, label %25, label %23

23:                                               ; preds = %5, %21
  %24 = phi i32 [ 0, %5 ], [ %13, %21 ]
  br label %26

25:                                               ; preds = %26, %21, %3
  ret ptr addrspace(4) %0

26:                                               ; preds = %23, %26
  %27 = phi i32 [ %31, %26 ], [ %24, %23 ]
  %28 = getelementptr inbounds i8, ptr addrspace(4) %1, i32 %27
  %29 = load i8, ptr addrspace(4) %28, align 1, !tbaa !14
  %30 = getelementptr inbounds i8, ptr addrspace(4) %0, i32 %27
  store i8 %29, ptr addrspace(4) %30, align 1, !tbaa !14
  %31 = add nuw nsw i32 %27, 1
  %32 = icmp ult i32 %31, %2
  br i1 %32, label %26, label %25, !llvm.loop !24
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i32 @__chip_clz_i(i32 noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func i32 @_Z3clzi(i32 noundef %0) #38
  ret i32 %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func i32 @_Z3clzi(i32 noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i64 @__chip_clz_li(i64 noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func i64 @_Z3clzl(i64 noundef %0) #38
  ret i64 %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func i64 @_Z3clzl(i64 noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i32 @__chip_ctz_i(i32 noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func i32 @_Z3ctzi(i32 noundef %0) #38
  ret i32 %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func i32 @_Z3ctzi(i32 noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func i64 @__chip_ctz_li(i64 noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func i64 @_Z3ctzl(i64 noundef %0) #38
  ret i64 %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func i64 @_Z3ctzl(i64 noundef) local_unnamed_addr #4

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_add_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_add_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_add_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_add_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i64 %3
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z25atomic_fetch_add_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef, i64 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_add_system_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_add_system_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_add_system_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_add_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_add_block_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_add_block_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_add_block_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_add_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_sub_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_sub_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_sub_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_sub_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i64 %3
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z25atomic_fetch_sub_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef, i64 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_sub_system_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_sub_system_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_sub_system_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_sub_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_sub_block_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_sub_block_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_sub_block_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_sub_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_min_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_min_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z25atomic_fetch_min_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_min_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_min_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z25atomic_fetch_min_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_min_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_min_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i64 %3
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z25atomic_fetch_min_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef, i64 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_min_system_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_min_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_min_system_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_min_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_min_system_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_min_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_min_block_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_min_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_min_block_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_min_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_min_block_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_min_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_max_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_max_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z25atomic_fetch_max_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_max_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_max_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z25atomic_fetch_max_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_max_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_max_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i64 %3
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z25atomic_fetch_max_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef, i64 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_max_system_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_max_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_max_system_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_max_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_max_system_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_max_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_max_block_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_max_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_max_block_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_max_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_max_block_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_max_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_and_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_and_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z25atomic_fetch_and_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_and_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_and_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z25atomic_fetch_and_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_and_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_and_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i64 %3
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z25atomic_fetch_and_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef, i64 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_and_system_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_and_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_and_system_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_and_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_and_system_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_and_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_and_block_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_and_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_and_block_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_and_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_and_block_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_and_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_or_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z24atomic_fetch_or_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z24atomic_fetch_or_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_or_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z24atomic_fetch_or_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z24atomic_fetch_or_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_or_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z24atomic_fetch_or_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i64 %3
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z24atomic_fetch_or_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef, i64 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_or_system_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z24atomic_fetch_or_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_or_system_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z24atomic_fetch_or_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_or_system_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z24atomic_fetch_or_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_or_block_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z24atomic_fetch_or_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_or_block_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z24atomic_fetch_or_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_or_block_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z24atomic_fetch_or_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_xor_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_xor_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z25atomic_fetch_xor_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_xor_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_xor_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z25atomic_fetch_xor_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_xor_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_xor_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i64 %3
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z25atomic_fetch_xor_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef, i64 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_xor_system_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_xor_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_xor_system_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_xor_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_xor_system_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_xor_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_xor_block_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_xor_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_xor_block_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z25atomic_fetch_xor_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_xor_block_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z25atomic_fetch_xor_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_exch_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z24atomic_exchange_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z24atomic_exchange_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_exch_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z24atomic_exchange_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %3
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z24atomic_exchange_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_exch_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z24atomic_exchange_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret i64 %3
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z24atomic_exchange_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef, i64 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_exch_system_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z24atomic_exchange_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_exch_system_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z24atomic_exchange_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_exch_system_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z24atomic_exchange_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_exch_block_i(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z24atomic_exchange_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_exch_block_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i32 @_Z24atomic_exchange_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_exch_block_l(ptr addrspace(4) noundef %0, i64 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func i64 @_Z24atomic_exchange_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret i64 %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_inc_i(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef 1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_inc_u(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef 1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_inc_l(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i64 @_Z25atomic_fetch_add_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef 1, i32 noundef 0, i32 noundef 2) #40
  ret i64 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_inc_system_i(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef 1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_inc_system_u(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef 1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_inc_system_l(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i64 @_Z25atomic_fetch_add_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef 1, i32 noundef 0, i32 noundef 3) #40
  ret i64 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_inc_block_i(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef 1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_inc_block_u(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i32 @_Z25atomic_fetch_add_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef 1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_inc_block_l(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i64 @_Z25atomic_fetch_add_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef 1, i32 noundef 0, i32 noundef 1) #40
  ret i64 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_dec_i(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef 1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_dec_u(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef 1, i32 noundef 0, i32 noundef 2) #40
  ret i32 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_dec_l(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i64 @_Z25atomic_fetch_sub_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef 1, i32 noundef 0, i32 noundef 2) #40
  ret i64 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_dec_system_i(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef 1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_dec_system_u(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef 1, i32 noundef 0, i32 noundef 3) #40
  ret i32 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_dec_system_l(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i64 @_Z25atomic_fetch_sub_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef 1, i32 noundef 0, i32 noundef 3) #40
  ret i64 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_dec_block_i(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vii12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef 1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_dec_block_u(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i32 @_Z25atomic_fetch_sub_explicitPU3AS4Vjj12memory_order12memory_scope(ptr addrspace(4) noundef %0, i32 noundef 1, i32 noundef 0, i32 noundef 1) #40
  ret i32 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_dec_block_l(ptr addrspace(4) noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i64 @_Z25atomic_fetch_sub_explicitPU3AS4Vmm12memory_order12memory_scope(ptr addrspace(4) noundef %0, i64 noundef 1, i32 noundef 0, i32 noundef 1) #40
  ret i64 %2
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_cmpxchg_i(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = alloca i32, align 4
  store i32 %1, ptr %4, align 4, !tbaa !4
  %5 = addrspacecast ptr %4 to ptr addrspace(4)
  %6 = call spir_func zeroext i1 @_Z39atomic_compare_exchange_strong_explicitPU3AS4VU7_AtomiciPU3AS4ii12memory_orderS4_12memory_scope(ptr addrspace(4) noundef %0, ptr addrspace(4) noundef %5, i32 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 2) #40
  %7 = load i32, ptr %4, align 4, !tbaa !4
  ret i32 %7
}

; Function Attrs: convergent nounwind
declare spir_func zeroext i1 @_Z39atomic_compare_exchange_strong_explicitPU3AS4VU7_AtomiciPU3AS4ii12memory_orderS4_12memory_scope(ptr addrspace(4) noundef, ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_cmpxchg_u(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = alloca i32, align 4
  store i32 %1, ptr %4, align 4, !tbaa !4
  %5 = addrspacecast ptr %4 to ptr addrspace(4)
  %6 = call spir_func zeroext i1 @_Z39atomic_compare_exchange_strong_explicitPU3AS4VU7_AtomicjPU3AS4jj12memory_orderS4_12memory_scope(ptr addrspace(4) noundef %0, ptr addrspace(4) noundef %5, i32 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 2) #40
  %7 = load i32, ptr %4, align 4, !tbaa !4
  ret i32 %7
}

; Function Attrs: convergent nounwind
declare spir_func zeroext i1 @_Z39atomic_compare_exchange_strong_explicitPU3AS4VU7_AtomicjPU3AS4jj12memory_orderS4_12memory_scope(ptr addrspace(4) noundef, ptr addrspace(4) noundef, i32 noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_cmpxchg_l(ptr addrspace(4) noundef %0, i64 noundef %1, i64 noundef %2) local_unnamed_addr #10 {
  %4 = alloca i64, align 8
  store i64 %1, ptr %4, align 8, !tbaa !12
  %5 = addrspacecast ptr %4 to ptr addrspace(4)
  %6 = call spir_func zeroext i1 @_Z39atomic_compare_exchange_strong_explicitPU3AS4VU7_AtomicmPU3AS4mm12memory_orderS4_12memory_scope(ptr addrspace(4) noundef %0, ptr addrspace(4) noundef %5, i64 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 2) #40
  %7 = load i64, ptr %4, align 8, !tbaa !12
  ret i64 %7
}

; Function Attrs: convergent nounwind
declare spir_func zeroext i1 @_Z39atomic_compare_exchange_strong_explicitPU3AS4VU7_AtomicmPU3AS4mm12memory_orderS4_12memory_scope(ptr addrspace(4) noundef, ptr addrspace(4) noundef, i64 noundef, i32 noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_cmpxchg_system_i(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = alloca i32, align 4
  store i32 %1, ptr %4, align 4, !tbaa !4
  %5 = addrspacecast ptr %4 to ptr addrspace(4)
  %6 = call spir_func zeroext i1 @_Z39atomic_compare_exchange_strong_explicitPU3AS4VU7_AtomiciPU3AS4ii12memory_orderS4_12memory_scope(ptr addrspace(4) noundef %0, ptr addrspace(4) noundef %5, i32 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 3) #40
  %7 = load i32, ptr %4, align 4, !tbaa !4
  ret i32 %7
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_cmpxchg_system_u(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = alloca i32, align 4
  store i32 %1, ptr %4, align 4, !tbaa !4
  %5 = addrspacecast ptr %4 to ptr addrspace(4)
  %6 = call spir_func zeroext i1 @_Z39atomic_compare_exchange_strong_explicitPU3AS4VU7_AtomicjPU3AS4jj12memory_orderS4_12memory_scope(ptr addrspace(4) noundef %0, ptr addrspace(4) noundef %5, i32 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 3) #40
  %7 = load i32, ptr %4, align 4, !tbaa !4
  ret i32 %7
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_cmpxchg_system_l(ptr addrspace(4) noundef %0, i64 noundef %1, i64 noundef %2) local_unnamed_addr #10 {
  %4 = alloca i64, align 8
  store i64 %1, ptr %4, align 8, !tbaa !12
  %5 = addrspacecast ptr %4 to ptr addrspace(4)
  %6 = call spir_func zeroext i1 @_Z39atomic_compare_exchange_strong_explicitPU3AS4VU7_AtomicmPU3AS4mm12memory_orderS4_12memory_scope(ptr addrspace(4) noundef %0, ptr addrspace(4) noundef %5, i64 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 3) #40
  %7 = load i64, ptr %4, align 8, !tbaa !12
  ret i64 %7
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_cmpxchg_block_i(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = alloca i32, align 4
  store i32 %1, ptr %4, align 4, !tbaa !4
  %5 = addrspacecast ptr %4 to ptr addrspace(4)
  %6 = call spir_func zeroext i1 @_Z39atomic_compare_exchange_strong_explicitPU3AS4VU7_AtomiciPU3AS4ii12memory_orderS4_12memory_scope(ptr addrspace(4) noundef %0, ptr addrspace(4) noundef %5, i32 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 1) #40
  %7 = load i32, ptr %4, align 4, !tbaa !4
  ret i32 %7
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @__chip_atomic_cmpxchg_block_u(ptr addrspace(4) noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = alloca i32, align 4
  store i32 %1, ptr %4, align 4, !tbaa !4
  %5 = addrspacecast ptr %4 to ptr addrspace(4)
  %6 = call spir_func zeroext i1 @_Z39atomic_compare_exchange_strong_explicitPU3AS4VU7_AtomicjPU3AS4jj12memory_orderS4_12memory_scope(ptr addrspace(4) noundef %0, ptr addrspace(4) noundef %5, i32 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 1) #40
  %7 = load i32, ptr %4, align 4, !tbaa !4
  ret i32 %7
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @__chip_atomic_cmpxchg_block_l(ptr addrspace(4) noundef %0, i64 noundef %1, i64 noundef %2) local_unnamed_addr #10 {
  %4 = alloca i64, align 8
  store i64 %1, ptr %4, align 8, !tbaa !12
  %5 = addrspacecast ptr %4 to ptr addrspace(4)
  %6 = call spir_func zeroext i1 @_Z39atomic_compare_exchange_strong_explicitPU3AS4VU7_AtomicmPU3AS4mm12memory_orderS4_12memory_scope(ptr addrspace(4) noundef %0, ptr addrspace(4) noundef %5, i64 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 1) #40
  %7 = load i64, ptr %4, align 8, !tbaa !12
  ret i64 %7
}

; Function Attrs: convergent norecurse nounwind
define spir_func float @__chip_atomic_exch_f32(ptr addrspace(4) noundef %0, float noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func float @_Z24atomic_exchange_explicitPU3AS4Vff12memory_order12memory_scope(ptr addrspace(4) noundef %0, float noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret float %3
}

; Function Attrs: convergent nounwind
declare spir_func float @_Z24atomic_exchange_explicitPU3AS4Vff12memory_order12memory_scope(ptr addrspace(4) noundef, float noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func double @__chip_atomic_exch_f64(ptr addrspace(4) noundef %0, double noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func double @_Z24atomic_exchange_explicitPU3AS4Vdd12memory_order12memory_scope(ptr addrspace(4) noundef %0, double noundef %1, i32 noundef 0, i32 noundef 2) #40
  ret double %3
}

; Function Attrs: convergent nounwind
declare spir_func double @_Z24atomic_exchange_explicitPU3AS4Vdd12memory_order12memory_scope(ptr addrspace(4) noundef, double noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func float @__chip_atomic_exch_system_f32(ptr addrspace(4) noundef %0, float noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func float @_Z24atomic_exchange_explicitPU3AS4Vff12memory_order12memory_scope(ptr addrspace(4) noundef %0, float noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret float %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func double @__chip_atomic_exch_system_f64(ptr addrspace(4) noundef %0, double noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func double @_Z24atomic_exchange_explicitPU3AS4Vdd12memory_order12memory_scope(ptr addrspace(4) noundef %0, double noundef %1, i32 noundef 0, i32 noundef 3) #40
  ret double %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func float @__chip_atomic_exch_block_f32(ptr addrspace(4) noundef %0, float noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func float @_Z24atomic_exchange_explicitPU3AS4Vff12memory_order12memory_scope(ptr addrspace(4) noundef %0, float noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret float %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func double @__chip_atomic_exch_block_f64(ptr addrspace(4) noundef %0, double noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func double @_Z24atomic_exchange_explicitPU3AS4Vdd12memory_order12memory_scope(ptr addrspace(4) noundef %0, double noundef %1, i32 noundef 0, i32 noundef 1) #40
  ret double %3
}

; Function Attrs: convergent norecurse nounwind
define spir_func noundef i32 @__chip_atomic_inc2_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func ptr addrspace(1) @__to_global(ptr addrspace(4) %0) #39
  %4 = icmp eq ptr addrspace(1) %3, null
  br i1 %4, label %14, label %5

5:                                                ; preds = %2
  %6 = load volatile i32, ptr addrspace(1) %3, align 4, !tbaa !4
  br label %7

7:                                                ; preds = %7, %5
  %8 = phi i32 [ %6, %5 ], [ %12, %7 ]
  %9 = icmp ult i32 %8, %1
  %10 = add i32 %8, 1
  %11 = select i1 %9, i32 %10, i32 0
  %12 = tail call spir_func i32 @_Z12atom_cmpxchgPU3AS1Vjjj(ptr addrspace(1) noundef nonnull %3, i32 noundef %8, i32 noundef %11) #40
  %13 = icmp eq i32 %8, %12
  br i1 %13, label %26, label %7

14:                                               ; preds = %2
  %15 = tail call spir_func ptr addrspace(3) @__to_local(ptr addrspace(4) %0) #39
  %16 = icmp eq ptr addrspace(3) %15, null
  br i1 %16, label %26, label %17

17:                                               ; preds = %14
  %18 = load volatile i32, ptr addrspace(3) %15, align 4, !tbaa !4
  br label %19

19:                                               ; preds = %19, %17
  %20 = phi i32 [ %18, %17 ], [ %24, %19 ]
  %21 = icmp ult i32 %20, %1
  %22 = add i32 %20, 1
  %23 = select i1 %21, i32 %22, i32 0
  %24 = tail call spir_func i32 @_Z12atom_cmpxchgPU3AS3Vjjj(ptr addrspace(3) noundef nonnull %15, i32 noundef %20, i32 noundef %23) #40
  %25 = icmp eq i32 %20, %24
  br i1 %25, label %26, label %19

26:                                               ; preds = %7, %19, %14
  %27 = phi i32 [ 0, %14 ], [ %20, %19 ], [ %8, %7 ]
  ret i32 %27
}

declare spir_func ptr addrspace(1) @__to_global(ptr addrspace(4)) local_unnamed_addr

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z12atom_cmpxchgPU3AS1Vjjj(ptr addrspace(1) noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

declare spir_func ptr addrspace(3) @__to_local(ptr addrspace(4)) local_unnamed_addr

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z12atom_cmpxchgPU3AS3Vjjj(ptr addrspace(3) noundef, i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func noundef i32 @__chip_atomic_dec2_u(ptr addrspace(4) noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  %3 = tail call spir_func ptr addrspace(1) @__to_global(ptr addrspace(4) %0) #39
  %4 = icmp eq ptr addrspace(1) %3, null
  br i1 %4, label %13, label %5

5:                                                ; preds = %2
  %6 = load volatile i32, ptr addrspace(1) %3, align 4, !tbaa !4
  br label %7

7:                                                ; preds = %7, %5
  %8 = phi i32 [ %6, %5 ], [ %11, %7 ]
  %9 = add i32 %8, -1
  %10 = tail call i32 @llvm.umin.i32(i32 %9, i32 %1)
  %11 = tail call spir_func i32 @_Z12atom_cmpxchgPU3AS1Vjjj(ptr addrspace(1) noundef nonnull %3, i32 noundef %8, i32 noundef %10) #40
  %12 = icmp eq i32 %8, %11
  br i1 %12, label %24, label %7

13:                                               ; preds = %2
  %14 = tail call spir_func ptr addrspace(3) @__to_local(ptr addrspace(4) %0) #39
  %15 = icmp eq ptr addrspace(3) %14, null
  br i1 %15, label %24, label %16

16:                                               ; preds = %13
  %17 = load volatile i32, ptr addrspace(3) %14, align 4, !tbaa !4
  br label %18

18:                                               ; preds = %18, %16
  %19 = phi i32 [ %17, %16 ], [ %22, %18 ]
  %20 = add i32 %19, -1
  %21 = tail call i32 @llvm.umin.i32(i32 %20, i32 %1)
  %22 = tail call spir_func i32 @_Z12atom_cmpxchgPU3AS3Vjjj(ptr addrspace(3) noundef nonnull %14, i32 noundef %19, i32 noundef %21) #40
  %23 = icmp eq i32 %19, %22
  br i1 %23, label %24, label %18

24:                                               ; preds = %7, %18, %13
  %25 = phi i32 [ 0, %13 ], [ %19, %18 ], [ %8, %7 ]
  ret i32 %25
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.umin.i32(i32, i32) #2

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z6__shfliii(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = icmp eq i32 %2, 32
  br i1 %5, label %12, label %6

6:                                                ; preds = %3
  %7 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %8 = freeze i32 %7
  %9 = urem i32 %8, %2
  %10 = sub i32 %1, %9
  %11 = add i32 %10, %8
  br label %12

12:                                               ; preds = %3, %6
  %13 = phi i32 [ %11, %6 ], [ %1, %3 ]
  %14 = tail call spir_func i32 @_Z23intel_sub_group_shuffleij(i32 noundef %0, i32 noundef %13) #40
  ret i32 %14
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z22get_sub_group_local_idv() local_unnamed_addr #11

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z23intel_sub_group_shuffleij(i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z6__shfljii(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = icmp eq i32 %2, 32
  br i1 %5, label %12, label %6

6:                                                ; preds = %3
  %7 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %8 = freeze i32 %7
  %9 = urem i32 %8, %2
  %10 = sub i32 %1, %9
  %11 = add i32 %10, %8
  br label %12

12:                                               ; preds = %3, %6
  %13 = phi i32 [ %11, %6 ], [ %1, %3 ]
  %14 = tail call spir_func i32 @_Z23intel_sub_group_shufflejj(i32 noundef %0, i32 noundef %13) #40
  ret i32 %14
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z23intel_sub_group_shufflejj(i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z6__shfllii(i64 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = icmp eq i32 %2, 32
  br i1 %5, label %12, label %6

6:                                                ; preds = %3
  %7 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %8 = freeze i32 %7
  %9 = urem i32 %8, %2
  %10 = sub i32 %1, %9
  %11 = add i32 %10, %8
  br label %12

12:                                               ; preds = %3, %6
  %13 = phi i32 [ %11, %6 ], [ %1, %3 ]
  %14 = tail call spir_func i64 @_Z23intel_sub_group_shufflelj(i64 noundef %0, i32 noundef %13) #40
  ret i64 %14
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z23intel_sub_group_shufflelj(i64 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z6__shflmii(i64 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = icmp eq i32 %2, 32
  br i1 %5, label %12, label %6

6:                                                ; preds = %3
  %7 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %8 = freeze i32 %7
  %9 = urem i32 %8, %2
  %10 = sub i32 %1, %9
  %11 = add i32 %10, %8
  br label %12

12:                                               ; preds = %3, %6
  %13 = phi i32 [ %11, %6 ], [ %1, %3 ]
  %14 = tail call spir_func i64 @_Z23intel_sub_group_shufflemj(i64 noundef %0, i32 noundef %13) #40
  ret i64 %14
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z23intel_sub_group_shufflemj(i64 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func float @_Z6__shflfii(float noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = icmp eq i32 %2, 32
  br i1 %5, label %12, label %6

6:                                                ; preds = %3
  %7 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %8 = freeze i32 %7
  %9 = urem i32 %8, %2
  %10 = sub i32 %1, %9
  %11 = add i32 %10, %8
  br label %12

12:                                               ; preds = %3, %6
  %13 = phi i32 [ %11, %6 ], [ %1, %3 ]
  %14 = tail call spir_func float @_Z23intel_sub_group_shufflefj(float noundef %0, i32 noundef %13) #40
  ret float %14
}

; Function Attrs: convergent nounwind
declare spir_func float @_Z23intel_sub_group_shufflefj(float noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func double @_Z6__shfldii(double noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = icmp eq i32 %2, 32
  br i1 %5, label %12, label %6

6:                                                ; preds = %3
  %7 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %8 = freeze i32 %7
  %9 = urem i32 %8, %2
  %10 = sub i32 %1, %9
  %11 = add i32 %10, %8
  br label %12

12:                                               ; preds = %3, %6
  %13 = phi i32 [ %11, %6 ], [ %1, %3 ]
  %14 = tail call spir_func double @_Z23intel_sub_group_shuffledj(double noundef %0, i32 noundef %13) #40
  ret double %14
}

; Function Attrs: convergent nounwind
declare spir_func double @_Z23intel_sub_group_shuffledj(double noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z10__shfl_xoriii(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z27intel_sub_group_shuffle_xorij(i32 noundef %0, i32 noundef %1) #40
  ret i32 %4
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z27intel_sub_group_shuffle_xorij(i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z10__shfl_xorjii(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z27intel_sub_group_shuffle_xorjj(i32 noundef %0, i32 noundef %1) #40
  ret i32 %4
}

; Function Attrs: convergent nounwind
declare spir_func i32 @_Z27intel_sub_group_shuffle_xorjj(i32 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z10__shfl_xorlii(i64 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i64 @_Z27intel_sub_group_shuffle_xorlj(i64 noundef %0, i32 noundef %1) #40
  ret i64 %4
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z27intel_sub_group_shuffle_xorlj(i64 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z10__shfl_xormii(i64 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i64 @_Z27intel_sub_group_shuffle_xormj(i64 noundef %0, i32 noundef %1) #40
  ret i64 %4
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z27intel_sub_group_shuffle_xormj(i64 noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func float @_Z10__shfl_xorfii(float noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func float @_Z27intel_sub_group_shuffle_xorfj(float noundef %0, i32 noundef %1) #40
  ret float %4
}

; Function Attrs: convergent nounwind
declare spir_func float @_Z27intel_sub_group_shuffle_xorfj(float noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func double @_Z10__shfl_xordii(double noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func double @_Z27intel_sub_group_shuffle_xordj(double noundef %0, i32 noundef %1) #40
  ret double %4
}

; Function Attrs: convergent nounwind
declare spir_func double @_Z27intel_sub_group_shuffle_xordj(double noundef, i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z9__shfl_upiji(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = freeze i32 %4
  %6 = srem i32 %5, %2
  %7 = sub i32 %6, %1
  %8 = icmp slt i32 %7, 0
  %9 = select i1 %8, i32 %6, i32 %7
  %10 = sub nsw i32 %5, %6
  %11 = add nsw i32 %10, %9
  %12 = tail call spir_func i32 @_Z23intel_sub_group_shuffleij(i32 noundef %0, i32 noundef %11) #40
  ret i32 %12
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z9__shfl_upjji(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = freeze i32 %4
  %6 = srem i32 %5, %2
  %7 = sub i32 %6, %1
  %8 = icmp slt i32 %7, 0
  %9 = select i1 %8, i32 %6, i32 %7
  %10 = sub nsw i32 %5, %6
  %11 = add nsw i32 %10, %9
  %12 = tail call spir_func i32 @_Z23intel_sub_group_shufflejj(i32 noundef %0, i32 noundef %11) #40
  ret i32 %12
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z9__shfl_uplji(i64 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = freeze i32 %4
  %6 = srem i32 %5, %2
  %7 = sub i32 %6, %1
  %8 = icmp slt i32 %7, 0
  %9 = select i1 %8, i32 %6, i32 %7
  %10 = sub nsw i32 %5, %6
  %11 = add nsw i32 %10, %9
  %12 = tail call spir_func i64 @_Z23intel_sub_group_shufflelj(i64 noundef %0, i32 noundef %11) #40
  ret i64 %12
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z9__shfl_upmji(i64 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = freeze i32 %4
  %6 = srem i32 %5, %2
  %7 = sub i32 %6, %1
  %8 = icmp slt i32 %7, 0
  %9 = select i1 %8, i32 %6, i32 %7
  %10 = sub nsw i32 %5, %6
  %11 = add nsw i32 %10, %9
  %12 = tail call spir_func i64 @_Z23intel_sub_group_shufflemj(i64 noundef %0, i32 noundef %11) #40
  ret i64 %12
}

; Function Attrs: convergent norecurse nounwind
define spir_func float @_Z9__shfl_upfji(float noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = freeze i32 %4
  %6 = srem i32 %5, %2
  %7 = sub i32 %6, %1
  %8 = icmp slt i32 %7, 0
  %9 = select i1 %8, i32 %6, i32 %7
  %10 = sub nsw i32 %5, %6
  %11 = add nsw i32 %10, %9
  %12 = tail call spir_func float @_Z23intel_sub_group_shufflefj(float noundef %0, i32 noundef %11) #40
  ret float %12
}

; Function Attrs: convergent norecurse nounwind
define spir_func double @_Z9__shfl_updji(double noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = freeze i32 %4
  %6 = srem i32 %5, %2
  %7 = sub i32 %6, %1
  %8 = icmp slt i32 %7, 0
  %9 = select i1 %8, i32 %6, i32 %7
  %10 = sub nsw i32 %5, %6
  %11 = add nsw i32 %10, %9
  %12 = tail call spir_func double @_Z23intel_sub_group_shuffledj(double noundef %0, i32 noundef %11) #40
  ret double %12
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z11__shfl_downiji(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = freeze i32 %4
  %6 = srem i32 %5, %2
  %7 = add i32 %6, %1
  %8 = icmp slt i32 %7, %2
  %9 = select i1 %8, i32 %7, i32 %6
  %10 = sub nsw i32 %5, %6
  %11 = add nsw i32 %10, %9
  %12 = tail call spir_func i32 @_Z23intel_sub_group_shuffleij(i32 noundef %0, i32 noundef %11) #40
  ret i32 %12
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z11__shfl_downjji(i32 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = freeze i32 %4
  %6 = srem i32 %5, %2
  %7 = add i32 %6, %1
  %8 = icmp slt i32 %7, %2
  %9 = select i1 %8, i32 %7, i32 %6
  %10 = sub nsw i32 %5, %6
  %11 = add nsw i32 %10, %9
  %12 = tail call spir_func i32 @_Z23intel_sub_group_shufflejj(i32 noundef %0, i32 noundef %11) #40
  ret i32 %12
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z11__shfl_downlji(i64 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = freeze i32 %4
  %6 = srem i32 %5, %2
  %7 = add i32 %6, %1
  %8 = icmp slt i32 %7, %2
  %9 = select i1 %8, i32 %7, i32 %6
  %10 = sub nsw i32 %5, %6
  %11 = add nsw i32 %10, %9
  %12 = tail call spir_func i64 @_Z23intel_sub_group_shufflelj(i64 noundef %0, i32 noundef %11) #40
  ret i64 %12
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z11__shfl_downmji(i64 noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = freeze i32 %4
  %6 = srem i32 %5, %2
  %7 = add i32 %6, %1
  %8 = icmp slt i32 %7, %2
  %9 = select i1 %8, i32 %7, i32 %6
  %10 = sub nsw i32 %5, %6
  %11 = add nsw i32 %10, %9
  %12 = tail call spir_func i64 @_Z23intel_sub_group_shufflemj(i64 noundef %0, i32 noundef %11) #40
  ret i64 %12
}

; Function Attrs: convergent norecurse nounwind
define spir_func float @_Z11__shfl_downfji(float noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = freeze i32 %4
  %6 = srem i32 %5, %2
  %7 = add i32 %6, %1
  %8 = icmp slt i32 %7, %2
  %9 = select i1 %8, i32 %7, i32 %6
  %10 = sub nsw i32 %5, %6
  %11 = add nsw i32 %10, %9
  %12 = tail call spir_func float @_Z23intel_sub_group_shufflefj(float noundef %0, i32 noundef %11) #40
  ret float %12
}

; Function Attrs: convergent norecurse nounwind
define spir_func double @_Z11__shfl_downdji(double noundef %0, i32 noundef %1, i32 noundef %2) local_unnamed_addr #10 {
  %4 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %5 = freeze i32 %4
  %6 = srem i32 %5, %2
  %7 = add i32 %6, %1
  %8 = icmp slt i32 %7, %2
  %9 = select i1 %8, i32 %7, i32 %6
  %10 = sub nsw i32 %5, %6
  %11 = add nsw i32 %10, %9
  %12 = tail call spir_func double @_Z23intel_sub_group_shuffledj(double noundef %0, i32 noundef %11) #40
  ret double %12
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z11__shfl_syncjiii(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %17 [
    i32 0, label %34
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = icmp eq i32 %3, 32
  br i1 %7, label %14, label %8

8:                                                ; preds = %5
  %9 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %10 = freeze i32 %9
  %11 = urem i32 %10, %3
  %12 = sub i32 %2, %11
  %13 = add i32 %12, %10
  br label %14

14:                                               ; preds = %5, %8
  %15 = phi i32 [ %13, %8 ], [ %2, %5 ]
  %16 = tail call spir_func i32 @_Z23intel_sub_group_shuffleij(i32 noundef %1, i32 noundef %15) #40
  br label %34

17:                                               ; preds = %4
  %18 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %22

20:                                               ; preds = %17
  %21 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str) #40
  br label %22

22:                                               ; preds = %20, %17
  %23 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %24 = icmp eq i32 %3, 32
  br i1 %24, label %31, label %25

25:                                               ; preds = %22
  %26 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %27 = freeze i32 %26
  %28 = urem i32 %27, %3
  %29 = sub i32 %2, %28
  %30 = add i32 %29, %27
  br label %31

31:                                               ; preds = %22, %25
  %32 = phi i32 [ %30, %25 ], [ %2, %22 ]
  %33 = tail call spir_func i32 @_Z23intel_sub_group_shuffleij(i32 noundef %1, i32 noundef %32) #40
  br label %34

34:                                               ; preds = %4, %31, %14
  %35 = phi i32 [ %16, %14 ], [ %33, %31 ], [ %0, %4 ]
  ret i32 %35
}

; Function Attrs: convergent nofree nounwind
declare spir_func noundef i32 @printf(ptr addrspace(2) nocapture noundef readonly, ...) local_unnamed_addr #15

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z11__shfl_syncjjii(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %17 [
    i32 0, label %34
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = icmp eq i32 %3, 32
  br i1 %7, label %14, label %8

8:                                                ; preds = %5
  %9 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %10 = freeze i32 %9
  %11 = urem i32 %10, %3
  %12 = sub i32 %2, %11
  %13 = add i32 %12, %10
  br label %14

14:                                               ; preds = %5, %8
  %15 = phi i32 [ %13, %8 ], [ %2, %5 ]
  %16 = tail call spir_func i32 @_Z23intel_sub_group_shufflejj(i32 noundef %1, i32 noundef %15) #40
  br label %34

17:                                               ; preds = %4
  %18 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %22

20:                                               ; preds = %17
  %21 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str) #40
  br label %22

22:                                               ; preds = %20, %17
  %23 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %24 = icmp eq i32 %3, 32
  br i1 %24, label %31, label %25

25:                                               ; preds = %22
  %26 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %27 = freeze i32 %26
  %28 = urem i32 %27, %3
  %29 = sub i32 %2, %28
  %30 = add i32 %29, %27
  br label %31

31:                                               ; preds = %22, %25
  %32 = phi i32 [ %30, %25 ], [ %2, %22 ]
  %33 = tail call spir_func i32 @_Z23intel_sub_group_shufflejj(i32 noundef %1, i32 noundef %32) #40
  br label %34

34:                                               ; preds = %4, %31, %14
  %35 = phi i32 [ %16, %14 ], [ %33, %31 ], [ %0, %4 ]
  ret i32 %35
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z11__shfl_syncjlii(i32 noundef %0, i64 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %17 [
    i32 0, label %34
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = icmp eq i32 %3, 32
  br i1 %7, label %14, label %8

8:                                                ; preds = %5
  %9 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %10 = freeze i32 %9
  %11 = urem i32 %10, %3
  %12 = sub i32 %2, %11
  %13 = add i32 %12, %10
  br label %14

14:                                               ; preds = %5, %8
  %15 = phi i32 [ %13, %8 ], [ %2, %5 ]
  %16 = tail call spir_func i64 @_Z23intel_sub_group_shufflelj(i64 noundef %1, i32 noundef %15) #40
  br label %34

17:                                               ; preds = %4
  %18 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %22

20:                                               ; preds = %17
  %21 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str) #40
  br label %22

22:                                               ; preds = %20, %17
  %23 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %24 = icmp eq i32 %3, 32
  br i1 %24, label %31, label %25

25:                                               ; preds = %22
  %26 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %27 = freeze i32 %26
  %28 = urem i32 %27, %3
  %29 = sub i32 %2, %28
  %30 = add i32 %29, %27
  br label %31

31:                                               ; preds = %22, %25
  %32 = phi i32 [ %30, %25 ], [ %2, %22 ]
  %33 = tail call spir_func i64 @_Z23intel_sub_group_shufflelj(i64 noundef %1, i32 noundef %32) #40
  br label %34

34:                                               ; preds = %4, %31, %14
  %35 = phi i64 [ %16, %14 ], [ %33, %31 ], [ 0, %4 ]
  ret i64 %35
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z11__shfl_syncjmii(i32 noundef %0, i64 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %17 [
    i32 0, label %34
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = icmp eq i32 %3, 32
  br i1 %7, label %14, label %8

8:                                                ; preds = %5
  %9 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %10 = freeze i32 %9
  %11 = urem i32 %10, %3
  %12 = sub i32 %2, %11
  %13 = add i32 %12, %10
  br label %14

14:                                               ; preds = %5, %8
  %15 = phi i32 [ %13, %8 ], [ %2, %5 ]
  %16 = tail call spir_func i64 @_Z23intel_sub_group_shufflemj(i64 noundef %1, i32 noundef %15) #40
  br label %34

17:                                               ; preds = %4
  %18 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %22

20:                                               ; preds = %17
  %21 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str) #40
  br label %22

22:                                               ; preds = %20, %17
  %23 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %24 = icmp eq i32 %3, 32
  br i1 %24, label %31, label %25

25:                                               ; preds = %22
  %26 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %27 = freeze i32 %26
  %28 = urem i32 %27, %3
  %29 = sub i32 %2, %28
  %30 = add i32 %29, %27
  br label %31

31:                                               ; preds = %22, %25
  %32 = phi i32 [ %30, %25 ], [ %2, %22 ]
  %33 = tail call spir_func i64 @_Z23intel_sub_group_shufflemj(i64 noundef %1, i32 noundef %32) #40
  br label %34

34:                                               ; preds = %4, %31, %14
  %35 = phi i64 [ %16, %14 ], [ %33, %31 ], [ 0, %4 ]
  ret i64 %35
}

; Function Attrs: convergent norecurse nounwind
define spir_func float @_Z11__shfl_syncjfii(i32 noundef %0, float noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %17 [
    i32 0, label %34
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = icmp eq i32 %3, 32
  br i1 %7, label %14, label %8

8:                                                ; preds = %5
  %9 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %10 = freeze i32 %9
  %11 = urem i32 %10, %3
  %12 = sub i32 %2, %11
  %13 = add i32 %12, %10
  br label %14

14:                                               ; preds = %5, %8
  %15 = phi i32 [ %13, %8 ], [ %2, %5 ]
  %16 = tail call spir_func float @_Z23intel_sub_group_shufflefj(float noundef %1, i32 noundef %15) #40
  br label %34

17:                                               ; preds = %4
  %18 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %22

20:                                               ; preds = %17
  %21 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str) #40
  br label %22

22:                                               ; preds = %20, %17
  %23 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %24 = icmp eq i32 %3, 32
  br i1 %24, label %31, label %25

25:                                               ; preds = %22
  %26 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %27 = freeze i32 %26
  %28 = urem i32 %27, %3
  %29 = sub i32 %2, %28
  %30 = add i32 %29, %27
  br label %31

31:                                               ; preds = %22, %25
  %32 = phi i32 [ %30, %25 ], [ %2, %22 ]
  %33 = tail call spir_func float @_Z23intel_sub_group_shufflefj(float noundef %1, i32 noundef %32) #40
  br label %34

34:                                               ; preds = %4, %31, %14
  %35 = phi float [ %16, %14 ], [ %33, %31 ], [ 0.000000e+00, %4 ]
  ret float %35
}

; Function Attrs: convergent norecurse nounwind
define spir_func double @_Z11__shfl_syncjdii(i32 noundef %0, double noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %17 [
    i32 0, label %34
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = icmp eq i32 %3, 32
  br i1 %7, label %14, label %8

8:                                                ; preds = %5
  %9 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %10 = freeze i32 %9
  %11 = urem i32 %10, %3
  %12 = sub i32 %2, %11
  %13 = add i32 %12, %10
  br label %14

14:                                               ; preds = %5, %8
  %15 = phi i32 [ %13, %8 ], [ %2, %5 ]
  %16 = tail call spir_func double @_Z23intel_sub_group_shuffledj(double noundef %1, i32 noundef %15) #40
  br label %34

17:                                               ; preds = %4
  %18 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %22

20:                                               ; preds = %17
  %21 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str) #40
  br label %22

22:                                               ; preds = %20, %17
  %23 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %24 = icmp eq i32 %3, 32
  br i1 %24, label %31, label %25

25:                                               ; preds = %22
  %26 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %27 = freeze i32 %26
  %28 = urem i32 %27, %3
  %29 = sub i32 %2, %28
  %30 = add i32 %29, %27
  br label %31

31:                                               ; preds = %22, %25
  %32 = phi i32 [ %30, %25 ], [ %2, %22 ]
  %33 = tail call spir_func double @_Z23intel_sub_group_shuffledj(double noundef %1, i32 noundef %32) #40
  br label %34

34:                                               ; preds = %4, %31, %14
  %35 = phi double [ %16, %14 ], [ %33, %31 ], [ 0.000000e+00, %4 ]
  ret double %35
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z14__shfl_up_syncjiji(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %15 [
    i32 0, label %30
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = freeze i32 %6
  %8 = srem i32 %7, %3
  %9 = sub i32 %8, %2
  %10 = icmp slt i32 %9, 0
  %11 = select i1 %10, i32 %8, i32 %9
  %12 = sub nsw i32 %7, %8
  %13 = add nsw i32 %12, %11
  %14 = tail call spir_func i32 @_Z23intel_sub_group_shuffleij(i32 noundef %1, i32 noundef %13) #40
  br label %30

15:                                               ; preds = %4
  %16 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %20

18:                                               ; preds = %15
  %19 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.1) #40
  br label %20

20:                                               ; preds = %18, %15
  %21 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %22 = freeze i32 %21
  %23 = srem i32 %22, %3
  %24 = sub i32 %23, %2
  %25 = icmp slt i32 %24, 0
  %26 = select i1 %25, i32 %23, i32 %24
  %27 = sub nsw i32 %22, %23
  %28 = add nsw i32 %27, %26
  %29 = tail call spir_func i32 @_Z23intel_sub_group_shuffleij(i32 noundef %1, i32 noundef %28) #40
  br label %30

30:                                               ; preds = %4, %20, %5
  %31 = phi i32 [ %14, %5 ], [ %29, %20 ], [ %0, %4 ]
  ret i32 %31
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z14__shfl_up_syncjjji(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %15 [
    i32 0, label %30
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = freeze i32 %6
  %8 = srem i32 %7, %3
  %9 = sub i32 %8, %2
  %10 = icmp slt i32 %9, 0
  %11 = select i1 %10, i32 %8, i32 %9
  %12 = sub nsw i32 %7, %8
  %13 = add nsw i32 %12, %11
  %14 = tail call spir_func i32 @_Z23intel_sub_group_shufflejj(i32 noundef %1, i32 noundef %13) #40
  br label %30

15:                                               ; preds = %4
  %16 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %20

18:                                               ; preds = %15
  %19 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.1) #40
  br label %20

20:                                               ; preds = %18, %15
  %21 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %22 = freeze i32 %21
  %23 = srem i32 %22, %3
  %24 = sub i32 %23, %2
  %25 = icmp slt i32 %24, 0
  %26 = select i1 %25, i32 %23, i32 %24
  %27 = sub nsw i32 %22, %23
  %28 = add nsw i32 %27, %26
  %29 = tail call spir_func i32 @_Z23intel_sub_group_shufflejj(i32 noundef %1, i32 noundef %28) #40
  br label %30

30:                                               ; preds = %4, %20, %5
  %31 = phi i32 [ %14, %5 ], [ %29, %20 ], [ %0, %4 ]
  ret i32 %31
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z14__shfl_up_syncjlji(i32 noundef %0, i64 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %15 [
    i32 0, label %30
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = freeze i32 %6
  %8 = srem i32 %7, %3
  %9 = sub i32 %8, %2
  %10 = icmp slt i32 %9, 0
  %11 = select i1 %10, i32 %8, i32 %9
  %12 = sub nsw i32 %7, %8
  %13 = add nsw i32 %12, %11
  %14 = tail call spir_func i64 @_Z23intel_sub_group_shufflelj(i64 noundef %1, i32 noundef %13) #40
  br label %30

15:                                               ; preds = %4
  %16 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %20

18:                                               ; preds = %15
  %19 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.1) #40
  br label %20

20:                                               ; preds = %18, %15
  %21 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %22 = freeze i32 %21
  %23 = srem i32 %22, %3
  %24 = sub i32 %23, %2
  %25 = icmp slt i32 %24, 0
  %26 = select i1 %25, i32 %23, i32 %24
  %27 = sub nsw i32 %22, %23
  %28 = add nsw i32 %27, %26
  %29 = tail call spir_func i64 @_Z23intel_sub_group_shufflelj(i64 noundef %1, i32 noundef %28) #40
  br label %30

30:                                               ; preds = %4, %20, %5
  %31 = phi i64 [ %14, %5 ], [ %29, %20 ], [ 0, %4 ]
  ret i64 %31
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z14__shfl_up_syncjmji(i32 noundef %0, i64 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %15 [
    i32 0, label %30
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = freeze i32 %6
  %8 = srem i32 %7, %3
  %9 = sub i32 %8, %2
  %10 = icmp slt i32 %9, 0
  %11 = select i1 %10, i32 %8, i32 %9
  %12 = sub nsw i32 %7, %8
  %13 = add nsw i32 %12, %11
  %14 = tail call spir_func i64 @_Z23intel_sub_group_shufflemj(i64 noundef %1, i32 noundef %13) #40
  br label %30

15:                                               ; preds = %4
  %16 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %20

18:                                               ; preds = %15
  %19 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.1) #40
  br label %20

20:                                               ; preds = %18, %15
  %21 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %22 = freeze i32 %21
  %23 = srem i32 %22, %3
  %24 = sub i32 %23, %2
  %25 = icmp slt i32 %24, 0
  %26 = select i1 %25, i32 %23, i32 %24
  %27 = sub nsw i32 %22, %23
  %28 = add nsw i32 %27, %26
  %29 = tail call spir_func i64 @_Z23intel_sub_group_shufflemj(i64 noundef %1, i32 noundef %28) #40
  br label %30

30:                                               ; preds = %4, %20, %5
  %31 = phi i64 [ %14, %5 ], [ %29, %20 ], [ 0, %4 ]
  ret i64 %31
}

; Function Attrs: convergent norecurse nounwind
define spir_func float @_Z14__shfl_up_syncjfji(i32 noundef %0, float noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %15 [
    i32 0, label %30
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = freeze i32 %6
  %8 = srem i32 %7, %3
  %9 = sub i32 %8, %2
  %10 = icmp slt i32 %9, 0
  %11 = select i1 %10, i32 %8, i32 %9
  %12 = sub nsw i32 %7, %8
  %13 = add nsw i32 %12, %11
  %14 = tail call spir_func float @_Z23intel_sub_group_shufflefj(float noundef %1, i32 noundef %13) #40
  br label %30

15:                                               ; preds = %4
  %16 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %20

18:                                               ; preds = %15
  %19 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.1) #40
  br label %20

20:                                               ; preds = %18, %15
  %21 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %22 = freeze i32 %21
  %23 = srem i32 %22, %3
  %24 = sub i32 %23, %2
  %25 = icmp slt i32 %24, 0
  %26 = select i1 %25, i32 %23, i32 %24
  %27 = sub nsw i32 %22, %23
  %28 = add nsw i32 %27, %26
  %29 = tail call spir_func float @_Z23intel_sub_group_shufflefj(float noundef %1, i32 noundef %28) #40
  br label %30

30:                                               ; preds = %4, %20, %5
  %31 = phi float [ %14, %5 ], [ %29, %20 ], [ 0.000000e+00, %4 ]
  ret float %31
}

; Function Attrs: convergent norecurse nounwind
define spir_func double @_Z14__shfl_up_syncjdji(i32 noundef %0, double noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %15 [
    i32 0, label %30
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = freeze i32 %6
  %8 = srem i32 %7, %3
  %9 = sub i32 %8, %2
  %10 = icmp slt i32 %9, 0
  %11 = select i1 %10, i32 %8, i32 %9
  %12 = sub nsw i32 %7, %8
  %13 = add nsw i32 %12, %11
  %14 = tail call spir_func double @_Z23intel_sub_group_shuffledj(double noundef %1, i32 noundef %13) #40
  br label %30

15:                                               ; preds = %4
  %16 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %20

18:                                               ; preds = %15
  %19 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.1) #40
  br label %20

20:                                               ; preds = %18, %15
  %21 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %22 = freeze i32 %21
  %23 = srem i32 %22, %3
  %24 = sub i32 %23, %2
  %25 = icmp slt i32 %24, 0
  %26 = select i1 %25, i32 %23, i32 %24
  %27 = sub nsw i32 %22, %23
  %28 = add nsw i32 %27, %26
  %29 = tail call spir_func double @_Z23intel_sub_group_shuffledj(double noundef %1, i32 noundef %28) #40
  br label %30

30:                                               ; preds = %4, %20, %5
  %31 = phi double [ %14, %5 ], [ %29, %20 ], [ 0.000000e+00, %4 ]
  ret double %31
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z16__shfl_down_syncjiji(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %15 [
    i32 0, label %30
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = freeze i32 %6
  %8 = srem i32 %7, %3
  %9 = add i32 %8, %2
  %10 = icmp slt i32 %9, %3
  %11 = select i1 %10, i32 %9, i32 %8
  %12 = sub nsw i32 %7, %8
  %13 = add nsw i32 %12, %11
  %14 = tail call spir_func i32 @_Z23intel_sub_group_shuffleij(i32 noundef %1, i32 noundef %13) #40
  br label %30

15:                                               ; preds = %4
  %16 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %20

18:                                               ; preds = %15
  %19 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.2) #40
  br label %20

20:                                               ; preds = %18, %15
  %21 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %22 = freeze i32 %21
  %23 = srem i32 %22, %3
  %24 = add i32 %23, %2
  %25 = icmp slt i32 %24, %3
  %26 = select i1 %25, i32 %24, i32 %23
  %27 = sub nsw i32 %22, %23
  %28 = add nsw i32 %27, %26
  %29 = tail call spir_func i32 @_Z23intel_sub_group_shuffleij(i32 noundef %1, i32 noundef %28) #40
  br label %30

30:                                               ; preds = %4, %20, %5
  %31 = phi i32 [ %14, %5 ], [ %29, %20 ], [ %0, %4 ]
  ret i32 %31
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z16__shfl_down_syncjjji(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %15 [
    i32 0, label %30
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = freeze i32 %6
  %8 = srem i32 %7, %3
  %9 = add i32 %8, %2
  %10 = icmp slt i32 %9, %3
  %11 = select i1 %10, i32 %9, i32 %8
  %12 = sub nsw i32 %7, %8
  %13 = add nsw i32 %12, %11
  %14 = tail call spir_func i32 @_Z23intel_sub_group_shufflejj(i32 noundef %1, i32 noundef %13) #40
  br label %30

15:                                               ; preds = %4
  %16 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %20

18:                                               ; preds = %15
  %19 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.2) #40
  br label %20

20:                                               ; preds = %18, %15
  %21 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %22 = freeze i32 %21
  %23 = srem i32 %22, %3
  %24 = add i32 %23, %2
  %25 = icmp slt i32 %24, %3
  %26 = select i1 %25, i32 %24, i32 %23
  %27 = sub nsw i32 %22, %23
  %28 = add nsw i32 %27, %26
  %29 = tail call spir_func i32 @_Z23intel_sub_group_shufflejj(i32 noundef %1, i32 noundef %28) #40
  br label %30

30:                                               ; preds = %4, %20, %5
  %31 = phi i32 [ %14, %5 ], [ %29, %20 ], [ %0, %4 ]
  ret i32 %31
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z16__shfl_down_syncjlji(i32 noundef %0, i64 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %15 [
    i32 0, label %30
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = freeze i32 %6
  %8 = srem i32 %7, %3
  %9 = add i32 %8, %2
  %10 = icmp slt i32 %9, %3
  %11 = select i1 %10, i32 %9, i32 %8
  %12 = sub nsw i32 %7, %8
  %13 = add nsw i32 %12, %11
  %14 = tail call spir_func i64 @_Z23intel_sub_group_shufflelj(i64 noundef %1, i32 noundef %13) #40
  br label %30

15:                                               ; preds = %4
  %16 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %20

18:                                               ; preds = %15
  %19 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.2) #40
  br label %20

20:                                               ; preds = %18, %15
  %21 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %22 = freeze i32 %21
  %23 = srem i32 %22, %3
  %24 = add i32 %23, %2
  %25 = icmp slt i32 %24, %3
  %26 = select i1 %25, i32 %24, i32 %23
  %27 = sub nsw i32 %22, %23
  %28 = add nsw i32 %27, %26
  %29 = tail call spir_func i64 @_Z23intel_sub_group_shufflelj(i64 noundef %1, i32 noundef %28) #40
  br label %30

30:                                               ; preds = %4, %20, %5
  %31 = phi i64 [ %14, %5 ], [ %29, %20 ], [ 0, %4 ]
  ret i64 %31
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z16__shfl_down_syncjmji(i32 noundef %0, i64 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %15 [
    i32 0, label %30
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = freeze i32 %6
  %8 = srem i32 %7, %3
  %9 = add i32 %8, %2
  %10 = icmp slt i32 %9, %3
  %11 = select i1 %10, i32 %9, i32 %8
  %12 = sub nsw i32 %7, %8
  %13 = add nsw i32 %12, %11
  %14 = tail call spir_func i64 @_Z23intel_sub_group_shufflemj(i64 noundef %1, i32 noundef %13) #40
  br label %30

15:                                               ; preds = %4
  %16 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %20

18:                                               ; preds = %15
  %19 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.2) #40
  br label %20

20:                                               ; preds = %18, %15
  %21 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %22 = freeze i32 %21
  %23 = srem i32 %22, %3
  %24 = add i32 %23, %2
  %25 = icmp slt i32 %24, %3
  %26 = select i1 %25, i32 %24, i32 %23
  %27 = sub nsw i32 %22, %23
  %28 = add nsw i32 %27, %26
  %29 = tail call spir_func i64 @_Z23intel_sub_group_shufflemj(i64 noundef %1, i32 noundef %28) #40
  br label %30

30:                                               ; preds = %4, %20, %5
  %31 = phi i64 [ %14, %5 ], [ %29, %20 ], [ 0, %4 ]
  ret i64 %31
}

; Function Attrs: convergent norecurse nounwind
define spir_func float @_Z16__shfl_down_syncjfji(i32 noundef %0, float noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %15 [
    i32 0, label %30
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = freeze i32 %6
  %8 = srem i32 %7, %3
  %9 = add i32 %8, %2
  %10 = icmp slt i32 %9, %3
  %11 = select i1 %10, i32 %9, i32 %8
  %12 = sub nsw i32 %7, %8
  %13 = add nsw i32 %12, %11
  %14 = tail call spir_func float @_Z23intel_sub_group_shufflefj(float noundef %1, i32 noundef %13) #40
  br label %30

15:                                               ; preds = %4
  %16 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %20

18:                                               ; preds = %15
  %19 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.2) #40
  br label %20

20:                                               ; preds = %18, %15
  %21 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %22 = freeze i32 %21
  %23 = srem i32 %22, %3
  %24 = add i32 %23, %2
  %25 = icmp slt i32 %24, %3
  %26 = select i1 %25, i32 %24, i32 %23
  %27 = sub nsw i32 %22, %23
  %28 = add nsw i32 %27, %26
  %29 = tail call spir_func float @_Z23intel_sub_group_shufflefj(float noundef %1, i32 noundef %28) #40
  br label %30

30:                                               ; preds = %4, %20, %5
  %31 = phi float [ %14, %5 ], [ %29, %20 ], [ 0.000000e+00, %4 ]
  ret float %31
}

; Function Attrs: convergent norecurse nounwind
define spir_func double @_Z16__shfl_down_syncjdji(i32 noundef %0, double noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %15 [
    i32 0, label %30
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %7 = freeze i32 %6
  %8 = srem i32 %7, %3
  %9 = add i32 %8, %2
  %10 = icmp slt i32 %9, %3
  %11 = select i1 %10, i32 %9, i32 %8
  %12 = sub nsw i32 %7, %8
  %13 = add nsw i32 %12, %11
  %14 = tail call spir_func double @_Z23intel_sub_group_shuffledj(double noundef %1, i32 noundef %13) #40
  br label %30

15:                                               ; preds = %4
  %16 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %20

18:                                               ; preds = %15
  %19 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.2) #40
  br label %20

20:                                               ; preds = %18, %15
  %21 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %22 = freeze i32 %21
  %23 = srem i32 %22, %3
  %24 = add i32 %23, %2
  %25 = icmp slt i32 %24, %3
  %26 = select i1 %25, i32 %24, i32 %23
  %27 = sub nsw i32 %22, %23
  %28 = add nsw i32 %27, %26
  %29 = tail call spir_func double @_Z23intel_sub_group_shuffledj(double noundef %1, i32 noundef %28) #40
  br label %30

30:                                               ; preds = %4, %20, %5
  %31 = phi double [ %14, %5 ], [ %29, %20 ], [ 0.000000e+00, %4 ]
  ret double %31
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z15__shfl_xor_syncjiii(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %7 [
    i32 0, label %14
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z27intel_sub_group_shuffle_xorij(i32 noundef %1, i32 noundef %2) #40
  br label %14

7:                                                ; preds = %4
  %8 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %12

10:                                               ; preds = %7
  %11 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.3) #40
  br label %12

12:                                               ; preds = %10, %7
  %13 = tail call spir_func i32 @_Z27intel_sub_group_shuffle_xorij(i32 noundef %1, i32 noundef %2) #40
  br label %14

14:                                               ; preds = %4, %12, %5
  %15 = phi i32 [ %6, %5 ], [ %13, %12 ], [ %0, %4 ]
  ret i32 %15
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z15__shfl_xor_syncjjii(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %7 [
    i32 0, label %14
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i32 @_Z27intel_sub_group_shuffle_xorjj(i32 noundef %1, i32 noundef %2) #40
  br label %14

7:                                                ; preds = %4
  %8 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %12

10:                                               ; preds = %7
  %11 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.3) #40
  br label %12

12:                                               ; preds = %10, %7
  %13 = tail call spir_func i32 @_Z27intel_sub_group_shuffle_xorjj(i32 noundef %1, i32 noundef %2) #40
  br label %14

14:                                               ; preds = %4, %12, %5
  %15 = phi i32 [ %6, %5 ], [ %13, %12 ], [ %0, %4 ]
  ret i32 %15
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z15__shfl_xor_syncjlii(i32 noundef %0, i64 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %7 [
    i32 0, label %14
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i64 @_Z27intel_sub_group_shuffle_xorlj(i64 noundef %1, i32 noundef %2) #40
  br label %14

7:                                                ; preds = %4
  %8 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %12

10:                                               ; preds = %7
  %11 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.3) #40
  br label %12

12:                                               ; preds = %10, %7
  %13 = tail call spir_func i64 @_Z27intel_sub_group_shuffle_xorlj(i64 noundef %1, i32 noundef %2) #40
  br label %14

14:                                               ; preds = %4, %12, %5
  %15 = phi i64 [ %6, %5 ], [ %13, %12 ], [ 0, %4 ]
  ret i64 %15
}

; Function Attrs: convergent norecurse nounwind
define spir_func i64 @_Z15__shfl_xor_syncjmii(i32 noundef %0, i64 noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %7 [
    i32 0, label %14
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func i64 @_Z27intel_sub_group_shuffle_xormj(i64 noundef %1, i32 noundef %2) #40
  br label %14

7:                                                ; preds = %4
  %8 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %12

10:                                               ; preds = %7
  %11 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.3) #40
  br label %12

12:                                               ; preds = %10, %7
  %13 = tail call spir_func i64 @_Z27intel_sub_group_shuffle_xormj(i64 noundef %1, i32 noundef %2) #40
  br label %14

14:                                               ; preds = %4, %12, %5
  %15 = phi i64 [ %6, %5 ], [ %13, %12 ], [ 0, %4 ]
  ret i64 %15
}

; Function Attrs: convergent norecurse nounwind
define spir_func float @_Z15__shfl_xor_syncjfii(i32 noundef %0, float noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %7 [
    i32 0, label %14
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func float @_Z27intel_sub_group_shuffle_xorfj(float noundef %1, i32 noundef %2) #40
  br label %14

7:                                                ; preds = %4
  %8 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %12

10:                                               ; preds = %7
  %11 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.3) #40
  br label %12

12:                                               ; preds = %10, %7
  %13 = tail call spir_func float @_Z27intel_sub_group_shuffle_xorfj(float noundef %1, i32 noundef %2) #40
  br label %14

14:                                               ; preds = %4, %12, %5
  %15 = phi float [ %6, %5 ], [ %13, %12 ], [ 0.000000e+00, %4 ]
  ret float %15
}

; Function Attrs: convergent norecurse nounwind
define spir_func double @_Z15__shfl_xor_syncjdii(i32 noundef %0, double noundef %1, i32 noundef %2, i32 noundef %3) local_unnamed_addr #10 {
  switch i32 %0, label %7 [
    i32 0, label %14
    i32 -1, label %5
  ]

5:                                                ; preds = %4
  %6 = tail call spir_func double @_Z27intel_sub_group_shuffle_xordj(double noundef %1, i32 noundef %2) #40
  br label %14

7:                                                ; preds = %4
  %8 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %12

10:                                               ; preds = %7
  %11 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.3) #40
  br label %12

12:                                               ; preds = %10, %7
  %13 = tail call spir_func double @_Z27intel_sub_group_shuffle_xordj(double noundef %1, i32 noundef %2) #40
  br label %14

14:                                               ; preds = %4, %12, %5
  %15 = phi double [ %6, %5 ], [ %13, %12 ], [ 0.000000e+00, %4 ]
  ret double %15
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z10__chip_alli(i32 noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i64 @_Z13__chip_balloti(i32 noundef %0) #40
  %3 = icmp eq i64 %2, -1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

; Function Attrs: convergent nounwind
declare spir_func i64 @_Z13__chip_balloti(i32 noundef) local_unnamed_addr #11

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z10__chip_anyi(i32 noundef %0) local_unnamed_addr #10 {
  %2 = tail call spir_func i64 @_Z13__chip_balloti(i32 noundef %0) #40
  %3 = icmp ne i64 %2, 0
  %4 = zext i1 %3 to i32
  ret i32 %4
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z18__chip_ballot_syncji(i32 noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  switch i32 %0, label %6 [
    i32 0, label %15
    i32 -1, label %3
  ]

3:                                                ; preds = %2
  %4 = tail call spir_func i64 @_Z13__chip_balloti(i32 noundef %1) #40
  %5 = trunc i64 %4 to i32
  br label %15

6:                                                ; preds = %2
  %7 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %11

9:                                                ; preds = %6
  %10 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.4) #40
  br label %11

11:                                               ; preds = %9, %6
  %12 = tail call spir_func i64 @_Z13__chip_balloti(i32 noundef %1) #40
  %13 = trunc i64 %12 to i32
  %14 = and i32 %13, %0
  br label %15

15:                                               ; preds = %2, %11, %3
  %16 = phi i32 [ %5, %3 ], [ %14, %11 ], [ %0, %2 ]
  ret i32 %16
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z15__chip_any_syncji(i32 noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  switch i32 %0, label %6 [
    i32 0, label %11
    i32 -1, label %3
  ]

3:                                                ; preds = %2
  %4 = tail call spir_func i64 @_Z13__chip_balloti(i32 noundef %1) #40
  %5 = icmp ne i64 %4, 0
  br label %11

6:                                                ; preds = %2
  %7 = tail call spir_func i64 @_Z13__chip_balloti(i32 noundef %1) #40
  %8 = trunc i64 %7 to i32
  %9 = and i32 %8, %0
  %10 = icmp ne i32 %9, 0
  br label %11

11:                                               ; preds = %2, %6, %3
  %12 = phi i1 [ %5, %3 ], [ %10, %6 ], [ false, %2 ]
  %13 = zext i1 %12 to i32
  ret i32 %13
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z15__chip_all_syncji(i32 noundef %0, i32 noundef %1) local_unnamed_addr #10 {
  switch i32 %0, label %6 [
    i32 0, label %11
    i32 -1, label %3
  ]

3:                                                ; preds = %2
  %4 = tail call spir_func i64 @_Z13__chip_balloti(i32 noundef %1) #40
  %5 = icmp eq i64 %4, -1
  br label %11

6:                                                ; preds = %2
  %7 = tail call spir_func i64 @_Z13__chip_balloti(i32 noundef %1) #40
  %8 = trunc i64 %7 to i32
  %9 = and i32 %8, %0
  %10 = icmp eq i32 %9, %0
  br label %11

11:                                               ; preds = %2, %6, %3
  %12 = phi i1 [ %5, %3 ], [ %10, %6 ], [ true, %2 ]
  %13 = zext i1 %12 to i32
  ret i32 %13
}

; Function Attrs: convergent norecurse nounwind
define spir_func i32 @_Z14__chip_lane_idv() local_unnamed_addr #10 {
  %1 = tail call spir_func i32 @_Z22get_sub_group_local_idv() #40
  ret i32 %1
}

; Function Attrs: convergent norecurse nounwind
define spir_func void @_Z15__chip_syncwarpv() local_unnamed_addr #10 {
  tail call spir_func void @_Z17sub_group_barrierj(i32 noundef 2) #40
  ret void
}

; Function Attrs: convergent nounwind
declare spir_func void @_Z17sub_group_barrierj(i32 noundef) local_unnamed_addr #11

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func noundef float @__chip_int_as_float(i32 noundef %0) local_unnamed_addr #1 {
  %2 = bitcast i32 %0 to float
  ret float %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func noundef i32 @__chip_float_as_int(float noundef %0) local_unnamed_addr #1 {
  %2 = bitcast float %0 to i32
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func noundef float @__chip_uint_as_float(i32 noundef %0) local_unnamed_addr #1 {
  %2 = bitcast i32 %0 to float
  ret float %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func noundef i32 @__chip_float_as_uint(float noundef %0) local_unnamed_addr #1 {
  %2 = bitcast float %0 to i32
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func noundef i64 @__chip_double_as_longlong(double noundef %0) local_unnamed_addr #1 {
  %2 = bitcast double %0 to i64
  ret i64 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define spir_func noundef double @__chip_longlong_as_double(i64 noundef %0) local_unnamed_addr #1 {
  %2 = bitcast i64 %0 to double
  ret double %2
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_acos(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4acosd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4acosd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_acosf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4acosf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4acosf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_asin(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4asind(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4asind(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_asinf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4asinf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4asinf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_atan(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4atand(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4atand(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_atanf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4atanf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4atanf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_cbrt(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4cbrtd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4cbrtd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_cbrtf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4cbrtf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4cbrtf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_ceil(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4ceild(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4ceild(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_ceilf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4ceilf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4ceilf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_cos(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z3cosd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z3cosd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_cosf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z3cosf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z3cosf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_cosh(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4coshd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4coshd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_coshf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4coshf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4coshf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_erf(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z3erfd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z3erfd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_erff(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z3erff(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z3erff(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_erfc(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4erfcd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4erfcd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_erfcf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4erfcf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4erfcf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_exp(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z3expd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z3expd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_expf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z3expf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z3expf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_expm1(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z5expm1d(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z5expm1d(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_expm1f(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z5expm1f(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z5expm1f(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_exp2(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4exp2d(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4exp2d(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_exp2f(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4exp2f(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4exp2f(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_fabs(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4fabsd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4fabsd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_fabsf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4fabsf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4fabsf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_floor(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z5floord(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z5floord(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_floorf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z5floorf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z5floorf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_lgamma(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z6lgammad(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z6lgammad(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_lgammaf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z6lgammaf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z6lgammaf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_log(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z3logd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z3logd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_logf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z3logf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z3logf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_log10(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z5log10d(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z5log10d(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_log10f(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z5log10f(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z5log10f(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_rint(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4rintd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_rintf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4rintf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_round(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z5roundd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_roundf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z5roundf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_signbit(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func i32 @_Z7signbitd(double noundef %0) #38
  %3 = sitofp i32 %2 to double
  ret double %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func i32 @_Z7signbitd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_signbitf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func i32 @_Z7signbitf(float noundef %0) #38
  %3 = sitofp i32 %2 to float
  ret float %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func i32 @_Z7signbitf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_sin(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z3sind(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z3sind(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_sinf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z3sinf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z3sinf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_sinh(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4sinhd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4sinhd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_sinhf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4sinhf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4sinhf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_sqrt(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4sqrtd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_sqrtf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4sqrtf(float noundef %0) #38, !fpmath !18
  ret float %2
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_tan(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z3tand(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z3tand(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_tanf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z3tanf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z3tanf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_tanh(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z4tanhd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4tanhd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_tanhf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z4tanhf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4tanhf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_trunc(double noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func double @_Z5truncd(double noundef %0) #38
  ret double %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z5truncd(double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_truncf(float noundef %0) local_unnamed_addr #6 {
  %2 = tail call spir_func float @_Z5truncf(float noundef %0) #38
  ret float %2
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z5truncf(float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_copysign(double noundef %0, double noundef %1) local_unnamed_addr #6 {
  %3 = tail call spir_func double @_Z8copysigndd(double noundef %0, double noundef %1) #38
  ret double %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z8copysigndd(double noundef, double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_fmax(double noundef %0, double noundef %1) local_unnamed_addr #6 {
  %3 = tail call spir_func double @_Z4fmaxdd(double noundef %0, double noundef %1) #38
  ret double %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4fmaxdd(double noundef, double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_fmaxf(float noundef %0, float noundef %1) local_unnamed_addr #6 {
  %3 = tail call spir_func float @_Z4fmaxff(float noundef %0, float noundef %1) #38
  ret float %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4fmaxff(float noundef, float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_fmin(double noundef %0, double noundef %1) local_unnamed_addr #6 {
  %3 = tail call spir_func double @_Z4fmindd(double noundef %0, double noundef %1) #38
  ret double %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4fmindd(double noundef, double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_fminf(float noundef %0, float noundef %1) local_unnamed_addr #6 {
  %3 = tail call spir_func float @_Z4fminff(float noundef %0, float noundef %1) #38
  ret float %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4fminff(float noundef, float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_fmod(double noundef %0, double noundef %1) local_unnamed_addr #6 {
  %3 = tail call spir_func double @_Z4fmoddd(double noundef %0, double noundef %1) #38
  ret double %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z4fmoddd(double noundef, double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_fmodf(float noundef %0, float noundef %1) local_unnamed_addr #6 {
  %3 = tail call spir_func float @_Z4fmodff(float noundef %0, float noundef %1) #38
  ret float %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z4fmodff(float noundef, float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_hypot(double noundef %0, double noundef %1) local_unnamed_addr #6 {
  %3 = tail call spir_func double @_Z5hypotdd(double noundef %0, double noundef %1) #38
  ret double %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z5hypotdd(double noundef, double noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func float @__chip_c2ocl_hypotf(float noundef %0, float noundef %1) local_unnamed_addr #6 {
  %3 = tail call spir_func float @_Z5hypotff(float noundef %0, float noundef %1) #38
  ret float %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z5hypotff(float noundef, float noundef) local_unnamed_addr #4

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define spir_func double @__chip_c2ocl_nextafter(double noundef %0, double noundef %1) local_unnamed_addr #6 {
  %3 = tail call spir_func double @_Z9nextafterdd(double noundef %0, double noundef %1) #38
  ret double %3
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func double @_Z9nextafterdd(double noundef, double noundef) local_unnamed_addr #4

; Function Attrs: convergent nofree norecurse nounwind
define internal spir_func void @_cl_print_str(ptr addrspace(4) nocapture noundef readonly %0) #16 {
  %2 = load i8, ptr addrspace(4) %0, align 1, !tbaa !14
  %3 = icmp eq i8 %2, 0
  br i1 %3, label %13, label %4

4:                                                ; preds = %1, %4
  %5 = phi i8 [ %11, %4 ], [ %2, %1 ]
  %6 = phi i32 [ %9, %4 ], [ 0, %1 ]
  %7 = sext i8 %5 to i32
  %8 = tail call spir_func i32 (ptr addrspace(2), ...) @printf(ptr addrspace(2) noundef @.str.5, i32 noundef %7) #40
  %9 = add i32 %6, 1
  %10 = getelementptr inbounds i8, ptr addrspace(4) %0, i32 %9
  %11 = load i8, ptr addrspace(4) %10, align 1, !tbaa !14
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %13, label %4

13:                                               ; preds = %4, %1
  ret void
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(read)
define internal spir_func <4 x float> @_chip_tex1df_impl(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, float noundef %2) #17 {
  %4 = tail call spir_func <4 x float> @_Z11read_imagef14ocl_image1d_ro11ocl_samplerf(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, float noundef %2) #41
  ret <4 x float> %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(read)
define internal spir_func <4 x float> @_chip_tex1dfetchf_impl(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, i32 noundef %2) #17 {
  %4 = tail call spir_func <4 x float> @_Z11read_imagef14ocl_image1d_ro11ocl_sampleri(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, i32 noundef %2) #41
  ret <4 x float> %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(read)
define internal spir_func <4 x i32> @_chip_tex1dfetchi_impl(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, i32 noundef %2) #17 {
  %4 = tail call spir_func <4 x i32> @_Z11read_imagei14ocl_image1d_ro11ocl_sampleri(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, i32 noundef %2) #41
  ret <4 x i32> %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(read)
define internal spir_func <4 x i32> @_chip_tex1dfetchu_impl(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, i32 noundef %2) #17 {
  %4 = tail call spir_func <4 x i32> @_Z12read_imageui14ocl_image1d_ro11ocl_sampleri(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, i32 noundef %2) #41
  ret <4 x i32> %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(read)
define internal spir_func <4 x i32> @_chip_tex1di_impl(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, float noundef %2) #17 {
  %4 = tail call spir_func <4 x i32> @_Z11read_imagei14ocl_image1d_ro11ocl_samplerf(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, float noundef %2) #41
  ret <4 x i32> %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(read)
define internal spir_func <4 x i32> @_chip_tex1du_impl(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, float noundef %2) #17 {
  %4 = tail call spir_func <4 x i32> @_Z12read_imageui14ocl_image1d_ro11ocl_samplerf(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, float noundef %2) #41
  ret <4 x i32> %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(read)
define internal spir_func <4 x float> @_chip_tex2df_impl(target("spirv.Image", void, 1, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, <2 x float> noundef %2) #17 {
  %4 = tail call spir_func <4 x float> @_Z11read_imagef14ocl_image2d_ro11ocl_samplerDv2_f(target("spirv.Image", void, 1, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, <2 x float> noundef %2) #41
  ret <4 x float> %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(read)
define internal spir_func <4 x i32> @_chip_tex2di_impl(target("spirv.Image", void, 1, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, <2 x float> noundef %2) #17 {
  %4 = tail call spir_func <4 x i32> @_Z11read_imagei14ocl_image2d_ro11ocl_samplerDv2_f(target("spirv.Image", void, 1, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, <2 x float> noundef %2) #41
  ret <4 x i32> %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(read)
define internal spir_func <4 x i32> @_chip_tex2du_impl(target("spirv.Image", void, 1, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, <2 x float> noundef %2) #17 {
  %4 = tail call spir_func <4 x i32> @_Z12read_imageui14ocl_image2d_ro11ocl_samplerDv2_f(target("spirv.Image", void, 1, 0, 0, 0, 0, 0, 0) %0, target("spirv.Sampler") %1, <2 x float> noundef %2) #41
  ret <4 x i32> %4
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(read)
declare spir_func <4 x i32> @_Z12read_imageui14ocl_image2d_ro11ocl_samplerDv2_f(target("spirv.Image", void, 1, 0, 0, 0, 0, 0, 0), target("spirv.Sampler"), <2 x float> noundef) local_unnamed_addr #18

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(read)
declare spir_func <4 x i32> @_Z11read_imagei14ocl_image2d_ro11ocl_samplerDv2_f(target("spirv.Image", void, 1, 0, 0, 0, 0, 0, 0), target("spirv.Sampler"), <2 x float> noundef) local_unnamed_addr #18

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(read)
declare spir_func <4 x float> @_Z11read_imagef14ocl_image2d_ro11ocl_samplerDv2_f(target("spirv.Image", void, 1, 0, 0, 0, 0, 0, 0), target("spirv.Sampler"), <2 x float> noundef) local_unnamed_addr #18

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(read)
declare spir_func <4 x i32> @_Z12read_imageui14ocl_image1d_ro11ocl_samplerf(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0), target("spirv.Sampler"), float noundef) local_unnamed_addr #18

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(read)
declare spir_func <4 x i32> @_Z11read_imagei14ocl_image1d_ro11ocl_samplerf(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0), target("spirv.Sampler"), float noundef) local_unnamed_addr #18

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(read)
declare spir_func <4 x i32> @_Z12read_imageui14ocl_image1d_ro11ocl_sampleri(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0), target("spirv.Sampler"), i32 noundef) local_unnamed_addr #18

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(read)
declare spir_func <4 x i32> @_Z11read_imagei14ocl_image1d_ro11ocl_sampleri(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0), target("spirv.Sampler"), i32 noundef) local_unnamed_addr #18

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(read)
declare spir_func <4 x float> @_Z11read_imagef14ocl_image1d_ro11ocl_sampleri(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0), target("spirv.Sampler"), i32 noundef) local_unnamed_addr #18

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(read)
declare spir_func <4 x float> @_Z11read_imagef14ocl_image1d_ro11ocl_samplerf(target("spirv.Image", void, 0, 0, 0, 0, 0, 0, 0), target("spirv.Sampler"), float noundef) local_unnamed_addr #18

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @acos(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_acos(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @acosf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_acosf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @asin(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_asin(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @asinf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_asinf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @atan(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_atan(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @atanf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_atanf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @cbrt(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_cbrt(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @cbrtf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_cbrtf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @ceil(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_ceil(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @ceilf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_ceilf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @cos(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_cos(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @cosf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_cosf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @cosh(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_cosh(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @coshf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_coshf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @erf(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_erf(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @erff(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_erff(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @erfc(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_erfc(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @erfcf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_erfcf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @exp(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_exp(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @expf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_expf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @expm1(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_expm1(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @expm1f(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_expm1f(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @exp2(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_exp2(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @exp2f(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_exp2f(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @fabs(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_fabs(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @fabsf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_fabsf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @floor(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_floor(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @floorf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_floorf(float noundef %0) #39
  ret float %2
}

; Function Attrs: nounwind
define spir_func double @lgamma(double noundef %0) local_unnamed_addr #20 {
  %2 = tail call spir_func double @__chip_c2ocl_lgamma(double noundef %0) #39
  ret double %2
}

; Function Attrs: nounwind
define spir_func float @lgammaf(float noundef %0) local_unnamed_addr #20 {
  %2 = tail call spir_func float @__chip_c2ocl_lgammaf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @log(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_log(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @logf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_logf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @log10(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_log10(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @log10f(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_log10f(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @rint(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_rint(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @rintf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_rintf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @round(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_round(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @roundf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_roundf(float noundef %0) #39
  ret float %2
}

; Function Attrs: nounwind
define spir_func double @signbit(double noundef %0) local_unnamed_addr #20 {
  %2 = tail call spir_func double @__chip_c2ocl_signbit(double noundef %0) #39
  ret double %2
}

; Function Attrs: nounwind
define spir_func float @signbitf(float noundef %0) local_unnamed_addr #20 {
  %2 = tail call spir_func float @__chip_c2ocl_signbitf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @sin(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_sin(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @sinf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_sinf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @sinh(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_sinh(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @sinhf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_sinhf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @sqrt(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_sqrt(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @sqrtf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_sqrtf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @tan(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_tan(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @tanf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_tanf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @tanh(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_tanh(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @tanhf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_tanhf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @trunc(double noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func double @__chip_c2ocl_trunc(double noundef %0) #39
  ret double %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @truncf(float noundef %0) local_unnamed_addr #19 {
  %2 = tail call spir_func float @__chip_c2ocl_truncf(float noundef %0) #39
  ret float %2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @copysign(double noundef %0, double noundef %1) local_unnamed_addr #19 {
  %3 = tail call spir_func double @__chip_c2ocl_copysign(double noundef %0, double noundef %1) #39
  ret double %3
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @fmax(double noundef %0, double noundef %1) local_unnamed_addr #19 {
  %3 = tail call spir_func double @__chip_c2ocl_fmax(double noundef %0, double noundef %1) #39
  ret double %3
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @fmaxf(float noundef %0, float noundef %1) local_unnamed_addr #19 {
  %3 = tail call spir_func float @__chip_c2ocl_fmaxf(float noundef %0, float noundef %1) #39
  ret float %3
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @fmin(double noundef %0, double noundef %1) local_unnamed_addr #19 {
  %3 = tail call spir_func double @__chip_c2ocl_fmin(double noundef %0, double noundef %1) #39
  ret double %3
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @fminf(float noundef %0, float noundef %1) local_unnamed_addr #19 {
  %3 = tail call spir_func float @__chip_c2ocl_fminf(float noundef %0, float noundef %1) #39
  ret float %3
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @fmod(double noundef %0, double noundef %1) local_unnamed_addr #19 {
  %3 = tail call spir_func double @__chip_c2ocl_fmod(double noundef %0, double noundef %1) #39
  ret double %3
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @fmodf(float noundef %0, float noundef %1) local_unnamed_addr #19 {
  %3 = tail call spir_func float @__chip_c2ocl_fmodf(float noundef %0, float noundef %1) #39
  ret float %3
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @hypot(double noundef %0, double noundef %1) local_unnamed_addr #19 {
  %3 = tail call spir_func double @__chip_c2ocl_hypot(double noundef %0, double noundef %1) #39
  ret double %3
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func float @hypotf(float noundef %0, float noundef %1) local_unnamed_addr #19 {
  %3 = tail call spir_func float @__chip_c2ocl_hypotf(float noundef %0, float noundef %1) #39
  ret float %3
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
define spir_func double @nextafter(double noundef %0, double noundef %1) local_unnamed_addr #19 {
  %3 = tail call spir_func double @__chip_c2ocl_nextafter(double noundef %0, double noundef %1) #39
  ret double %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_acos_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fcmp oge double %2, 5.000000e-01
  %4 = tail call double @llvm.fma.f64(double %2, double -5.000000e-01, double 5.000000e-01)
  %5 = fmul double %0, %0
  %6 = select i1 %3, double %4, double %5
  %7 = tail call double @llvm.fma.f64(double %6, double 0x3FA059859FEA6A70, double 0xBF90A5A378A05EAF)
  %8 = tail call double @llvm.fma.f64(double %6, double %7, double 0x3F94052137024D6A)
  %9 = tail call double @llvm.fma.f64(double %6, double %8, double 0x3F7AB3A098A70509)
  %10 = tail call double @llvm.fma.f64(double %6, double %9, double 0x3F88ED60A300C8D2)
  %11 = tail call double @llvm.fma.f64(double %6, double %10, double 0x3F8C6FA84B77012B)
  %12 = tail call double @llvm.fma.f64(double %6, double %11, double 0x3F91C6C111DCCB70)
  %13 = tail call double @llvm.fma.f64(double %6, double %12, double 0x3F96E89F0A0ADACF)
  %14 = tail call double @llvm.fma.f64(double %6, double %13, double 0x3F9F1C72C668963F)
  %15 = tail call double @llvm.fma.f64(double %6, double %14, double 0x3FA6DB6DB41CE4BD)
  %16 = tail call double @llvm.fma.f64(double %6, double %15, double 0x3FB333333336FD5B)
  %17 = tail call double @llvm.fma.f64(double %6, double %16, double 0x3FC5555555555380)
  %18 = fmul double %6, %17
  %19 = tail call double @llvm.fma.f64(double %0, double %18, double %0)
  %20 = fneg double %19
  %21 = tail call double @llvm.fma.f64(double 0x3FEDD9AD336A0500, double 0x3FFAF154EEB562D6, double %20)
  br i1 %3, label %22, label %73

22:                                               ; preds = %1
  %23 = fptrunc double %4 to float
  %24 = tail call spir_func float @_Z12native_rsqrtf(float noundef %23) #38
  %25 = fpext float %24 to double
  %26 = fmul double %4, %25
  %27 = fmul double %25, 5.000000e-01
  %28 = fneg double %27
  %29 = tail call double @llvm.fma.f64(double %28, double %26, double 5.000000e-01)
  %30 = tail call double @llvm.fma.f64(double %27, double %29, double %27)
  %31 = tail call double @llvm.fma.f64(double %26, double %29, double %26)
  %32 = fneg double %31
  %33 = tail call double @llvm.fma.f64(double %32, double %31, double %4)
  %34 = tail call double @llvm.fma.f64(double %33, double %30, double %31)
  %35 = fcmp oeq double %4, 0.000000e+00
  %36 = select i1 %35, double %4, double %34
  %37 = fmul double %36, %36
  %38 = fneg double %37
  %39 = tail call double @llvm.fma.f64(double %36, double %36, double %38)
  %40 = fsub double %4, %37
  %41 = fsub double %4, %40
  %42 = fsub double %41, %37
  %43 = fsub double %42, %39
  %44 = fadd double %40, %43
  %45 = fmul double %36, 2.000000e+00
  %46 = fptrunc double %45 to float
  %47 = tail call spir_func float @_Z12native_recipf(float noundef %46) #38
  %48 = fpext float %47 to double
  %49 = fneg double %45
  %50 = tail call double @llvm.fma.f64(double %49, double %48, double 1.000000e+00)
  %51 = tail call double @llvm.fma.f64(double %50, double %48, double %48)
  %52 = tail call double @llvm.fma.f64(double %49, double %51, double 1.000000e+00)
  %53 = tail call double @llvm.fma.f64(double %52, double %51, double %51)
  %54 = fmul double %53, %44
  %55 = tail call double @llvm.fma.f64(double %49, double %54, double %44)
  %56 = tail call double @llvm.fma.f64(double %55, double %53, double %54)
  %57 = select i1 %35, double 0.000000e+00, double %56
  %58 = fadd double %36, %57
  %59 = fsub double %58, %36
  %60 = fsub double %57, %59
  %61 = tail call double @llvm.fma.f64(double %58, double %18, double %58)
  %62 = fmul double %61, -2.000000e+00
  %63 = tail call double @llvm.fma.f64(double 0x3FFDD9AD336A0500, double 0x3FFAF154EEB562D6, double %62)
  %64 = tail call double @llvm.fma.f64(double %58, double %18, double %60)
  %65 = fadd double %58, %64
  %66 = fmul double %65, 2.000000e+00
  %67 = fcmp olt double %0, 0.000000e+00
  %68 = select i1 %67, double %63, double %66
  %69 = fcmp oeq double %0, -1.000000e+00
  %70 = select i1 %69, double 0x400921FB54442D18, double %68
  %71 = fcmp oeq double %0, 1.000000e+00
  %72 = select i1 %71, double 0.000000e+00, double %70
  br label %73

73:                                               ; preds = %22, %1
  %74 = phi double [ %72, %22 ], [ %21, %1 ]
  ret double %74
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fabs.f64(double) #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fma.f64(double, double, double) #2

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z12native_rsqrtf(float noundef) local_unnamed_addr #22

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z12native_recipf(float noundef) local_unnamed_addr #22

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_acos_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = tail call spir_func float @__ocml_fmuladd_f32(float noundef -5.000000e-01, float noundef %2, float noundef 5.000000e-01) #38
  %4 = fmul float %0, %0
  %5 = fcmp ogt float %2, 5.000000e-01
  %6 = select i1 %5, float %3, float %4
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef 0x3FA38434E0000000, float noundef 0x3F8BF8BB40000000) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %7, float noundef 0x3FA0698780000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %8, float noundef 0x3FA6C83620000000) #38
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %9, float noundef 0x3FB3337900000000) #38
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %10, float noundef 0x3FC5555580000000) #38
  %12 = fmul float %6, %11
  %13 = tail call float @llvm.sqrt.f32(float %6), !fpmath !18
  %14 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %13, float noundef %12, float noundef %13) #38
  %15 = fmul float %14, 2.000000e+00
  %16 = fneg float %15
  %17 = tail call spir_func float @__ocml_fmuladd_f32(float noundef 0x3FFDDCB020000000, float noundef 0x3FFAEE9D60000000, float noundef %16) #38
  %18 = fcmp olt float %0, 0.000000e+00
  %19 = select i1 %18, float %17, float %15
  %20 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef %12, float noundef %0) #38
  %21 = fneg float %20
  %22 = tail call spir_func float @__ocml_fmuladd_f32(float noundef 0x3FEDDCB020000000, float noundef 0x3FFAEE9D60000000, float noundef %21) #38
  %23 = select i1 %5, float %19, float %22
  ret float %23
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fabs.f32(float) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_fmuladd_f32(float noundef %0, float noundef %1, float noundef %2) local_unnamed_addr #23 {
  %4 = tail call float @llvm.fmuladd.f32(float %0, float %1, float %2)
  ret float %4
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.sqrt.f32(float) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_acos_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call half @llvm.fabs.f16(half %2)
  %4 = tail call half @llvm.fma.f16(half %3, half 0xHB800, half 0xH3800)
  %5 = fmul half %2, %2
  %6 = fcmp ogt half %3, 0xH3800
  %7 = select i1 %6, half %4, half %5
  %8 = tail call half @llvm.fma.f16(half %7, half 0xH2E0A, half 0xH3148)
  %9 = fmul half %7, %8
  %10 = tail call half @llvm.sqrt.f16(half %7)
  %11 = tail call half @llvm.fma.f16(half %10, half %9, half %10)
  %12 = fmul half %11, 0xH4000
  %13 = fneg half %12
  %14 = tail call half @llvm.fma.f16(half 0xH3FAA, half 0xH3E8F, half %13)
  %15 = fcmp olt half %2, 0xH0000
  %16 = select i1 %15, half %14, half %12
  %17 = tail call half @llvm.fma.f16(half %2, half %9, half %2)
  %18 = fneg half %17
  %19 = tail call half @llvm.fma.f16(half 0xH3BAA, half 0xH3E8F, half %18)
  %20 = select i1 %6, half %16, half %19
  %21 = insertelement <2 x half> poison, half %20, i64 0
  %22 = extractelement <2 x half> %0, i64 1
  %23 = tail call half @llvm.fabs.f16(half %22)
  %24 = tail call half @llvm.fma.f16(half %23, half 0xHB800, half 0xH3800)
  %25 = fmul half %22, %22
  %26 = fcmp ogt half %23, 0xH3800
  %27 = select i1 %26, half %24, half %25
  %28 = tail call half @llvm.fma.f16(half %27, half 0xH2E0A, half 0xH3148)
  %29 = fmul half %27, %28
  %30 = tail call half @llvm.sqrt.f16(half %27)
  %31 = tail call half @llvm.fma.f16(half %30, half %29, half %30)
  %32 = fmul half %31, 0xH4000
  %33 = fneg half %32
  %34 = tail call half @llvm.fma.f16(half 0xH3FAA, half 0xH3E8F, half %33)
  %35 = fcmp olt half %22, 0xH0000
  %36 = select i1 %35, half %34, half %32
  %37 = tail call half @llvm.fma.f16(half %22, half %29, half %22)
  %38 = fneg half %37
  %39 = tail call half @llvm.fma.f16(half 0xH3BAA, half 0xH3E8F, half %38)
  %40 = select i1 %26, half %36, half %39
  %41 = insertelement <2 x half> %21, half %40, i64 1
  ret <2 x half> %41
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.fabs.f16(half) #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.fma.f16(half, half, half) #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.sqrt.f16(half) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_acos_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  %3 = tail call half @llvm.fma.f16(half %2, half 0xHB800, half 0xH3800)
  %4 = fmul half %0, %0
  %5 = fcmp ogt half %2, 0xH3800
  %6 = select i1 %5, half %3, half %4
  %7 = tail call half @llvm.fma.f16(half %6, half 0xH2E0A, half 0xH3148)
  %8 = fmul half %6, %7
  %9 = tail call half @llvm.sqrt.f16(half %6)
  %10 = tail call half @llvm.fma.f16(half %9, half %8, half %9)
  %11 = fmul half %10, 0xH4000
  %12 = fneg half %11
  %13 = tail call half @llvm.fma.f16(half 0xH3FAA, half 0xH3E8F, half %12)
  %14 = fcmp olt half %0, 0xH0000
  %15 = select i1 %14, half %13, half %11
  %16 = tail call half @llvm.fma.f16(half %0, half %8, half %0)
  %17 = fneg half %16
  %18 = tail call half @llvm.fma.f16(half 0xH3BAA, half 0xH3E8F, half %17)
  %19 = select i1 %5, half %15, half %18
  ret half %19
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_acosh_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = fcmp oge double %0, 0x5FF0000000000000
  %4 = select i1 %3, double 0x1FF0000000000000, double 1.000000e+00
  %5 = fmul double %4, %0
  %6 = fmul double %5, %5
  %7 = fneg double %6
  %8 = tail call double @llvm.fma.f64(double %5, double %5, double %7)
  %9 = select i1 %3, double 0x4000000000000, double 1.000000e+00
  %10 = fsub double %6, %9
  %11 = fsub double %10, %6
  %12 = fsub double %11, %10
  %13 = fadd double %6, %12
  %14 = fadd double %9, %11
  %15 = fsub double %13, %14
  %16 = fadd double %8, %15
  %17 = fadd double %10, %16
  %18 = fsub double %10, %17
  %19 = fadd double %16, %18
  %20 = fptrunc double %17 to float
  %21 = tail call spir_func float @_Z12native_rsqrtf(float noundef %20) #38
  %22 = fpext float %21 to double
  %23 = fmul double %17, %22
  %24 = fmul double %22, 5.000000e-01
  %25 = fneg double %24
  %26 = tail call double @llvm.fma.f64(double %25, double %23, double 5.000000e-01)
  %27 = tail call double @llvm.fma.f64(double %24, double %26, double %24)
  %28 = tail call double @llvm.fma.f64(double %23, double %26, double %23)
  %29 = fneg double %28
  %30 = tail call double @llvm.fma.f64(double %29, double %28, double %17)
  %31 = tail call double @llvm.fma.f64(double %30, double %27, double %28)
  %32 = fcmp oeq double %17, 0.000000e+00
  %33 = select i1 %32, double %17, double %31
  %34 = fmul double %33, %33
  %35 = fneg double %34
  %36 = tail call double @llvm.fma.f64(double %33, double %33, double %35)
  %37 = fsub double %17, %34
  %38 = fsub double %17, %37
  %39 = fsub double %38, %34
  %40 = fadd double %19, %39
  %41 = fsub double %40, %36
  %42 = fadd double %37, %41
  %43 = fmul double %33, 2.000000e+00
  %44 = fptrunc double %43 to float
  %45 = tail call spir_func float @_Z12native_recipf(float noundef %44) #38
  %46 = fpext float %45 to double
  %47 = fneg double %43
  %48 = tail call double @llvm.fma.f64(double %47, double %46, double 1.000000e+00)
  %49 = tail call double @llvm.fma.f64(double %48, double %46, double %46)
  %50 = tail call double @llvm.fma.f64(double %47, double %49, double 1.000000e+00)
  %51 = tail call double @llvm.fma.f64(double %50, double %49, double %49)
  %52 = fmul double %51, %42
  %53 = tail call double @llvm.fma.f64(double %47, double %52, double %42)
  %54 = tail call double @llvm.fma.f64(double %53, double %51, double %52)
  %55 = select i1 %32, double 0.000000e+00, double %54
  %56 = fadd double %33, %55
  %57 = fsub double %56, %33
  %58 = fsub double %55, %57
  %59 = fadd double %5, %56
  %60 = fsub double %59, %5
  %61 = fsub double %59, %60
  %62 = fsub double %5, %61
  %63 = fsub double %56, %60
  %64 = fadd double %63, %62
  %65 = fadd double %58, %64
  %66 = fadd double %59, %65
  %67 = fsub double %66, %59
  %68 = fsub double %65, %67
  %69 = insertelement <2 x double> poison, double %68, i64 0
  %70 = insertelement <2 x double> %69, double %66, i64 1
  %71 = select i1 %3, i32 512, i32 0
  %72 = tail call spir_func double @__ocmlpriv_lnep_f64(<2 x double> noundef %70, i32 noundef %71) #38
  %73 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %74 = icmp eq i8 %73, 0
  br i1 %74, label %75, label %82

75:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %0, ptr %2, align 8, !tbaa !19
  %76 = addrspacecast ptr %2 to ptr addrspace(4)
  %77 = load i128, ptr addrspace(4) %76, align 8, !tbaa !29
  %78 = icmp eq i128 %77, 9218868437227405312
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %79 = select i1 %78, double %0, double %72
  %80 = fcmp olt double %0, 1.000000e+00
  %81 = select i1 %80, double 0x7FF8000000000000, double %79
  br label %82

82:                                               ; preds = %75, %1
  %83 = phi double [ %72, %1 ], [ %81, %75 ]
  ret double %83
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_lnep_f64(<2 x double> noundef %0, i32 noundef %1) local_unnamed_addr #21 {
  %3 = alloca i32, align 4
  %4 = extractelement <2 x double> %0, i64 1
  %5 = fcmp olt double %4, 0x3FE5555555555555
  %6 = sext i1 %5 to i32
  %7 = fptrunc double %4 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %8 = addrspacecast ptr %3 to ptr addrspace(4)
  %9 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %7, ptr addrspace(4) noundef %8) #40
  %10 = load i32, ptr %3, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %11 = add i32 %10, %6
  %12 = sub nsw i32 0, %11
  %13 = call spir_func double @_Z5ldexpdi(double noundef %4, i32 noundef %12) #38
  %14 = extractelement <2 x double> %0, i64 0
  %15 = call spir_func double @_Z5ldexpdi(double noundef %14, i32 noundef %12) #38
  %16 = fadd double %13, -1.000000e+00
  %17 = fadd double %16, 1.000000e+00
  %18 = fsub double %13, %17
  %19 = fadd double %15, %18
  %20 = fadd double %16, %19
  %21 = fsub double %20, %16
  %22 = fsub double %19, %21
  %23 = fadd double %13, 1.000000e+00
  %24 = fadd double %23, -1.000000e+00
  %25 = fsub double %13, %24
  %26 = fadd double %15, %25
  %27 = fadd double %23, %26
  %28 = fsub double %27, %23
  %29 = fsub double %26, %28
  %30 = fptrunc double %27 to float
  %31 = call spir_func float @_Z12native_recipf(float noundef %30) #38
  %32 = fpext float %31 to double
  %33 = fneg double %27
  %34 = call double @llvm.fma.f64(double %33, double %32, double 1.000000e+00)
  %35 = call double @llvm.fma.f64(double %34, double %32, double %32)
  %36 = call double @llvm.fma.f64(double %33, double %35, double 1.000000e+00)
  %37 = call double @llvm.fma.f64(double %36, double %35, double %35)
  %38 = fmul double %20, %37
  %39 = fmul double %27, %38
  %40 = fneg double %39
  %41 = call double @llvm.fma.f64(double %38, double %27, double %40)
  %42 = call double @llvm.fma.f64(double %38, double %29, double %41)
  %43 = fadd double %39, %42
  %44 = fsub double %43, %39
  %45 = fsub double %20, %43
  %46 = fsub double %20, %45
  %47 = fsub double %46, %43
  %48 = fadd double %22, %47
  %49 = fsub double %44, %42
  %50 = fadd double %49, %48
  %51 = fadd double %45, %50
  %52 = fsub double %45, %51
  %53 = fadd double %50, %52
  %54 = fmul double %37, %51
  %55 = fmul double %27, %54
  %56 = fneg double %55
  %57 = call double @llvm.fma.f64(double %54, double %27, double %56)
  %58 = call double @llvm.fma.f64(double %54, double %29, double %57)
  %59 = fadd double %55, %58
  %60 = fsub double %59, %55
  %61 = fsub double %51, %59
  %62 = fsub double %51, %61
  %63 = fsub double %62, %59
  %64 = fadd double %53, %63
  %65 = fsub double %60, %58
  %66 = fadd double %65, %64
  %67 = fadd double %61, %66
  %68 = fmul double %37, %67
  %69 = fadd double %38, %54
  %70 = fsub double %69, %38
  %71 = fsub double %54, %70
  %72 = fadd double %71, %68
  %73 = fadd double %69, %72
  %74 = fsub double %73, %69
  %75 = fsub double %72, %74
  %76 = fmul double %73, %73
  %77 = call double @llvm.fma.f64(double %76, double 0x3FC3AB76BF559E2B, double 0x3FC385386B47B09A)
  %78 = call double @llvm.fma.f64(double %76, double %77, double 0x3FC7474DD7F4DF2E)
  %79 = call double @llvm.fma.f64(double %76, double %78, double 0x3FCC71C016291751)
  %80 = call double @llvm.fma.f64(double %76, double %79, double 0x3FD249249B27ACF1)
  %81 = call double @llvm.fma.f64(double %76, double %80, double 0x3FD99999998EF7B6)
  %82 = call double @llvm.fma.f64(double %76, double %81, double 0x3FE5555555555780)
  %83 = add nsw i32 %11, %1
  %84 = sitofp i32 %83 to double
  %85 = fmul double %84, 0x3FE62E42FEFA39EF
  %86 = fneg double %85
  %87 = call double @llvm.fma.f64(double %84, double 0x3FE62E42FEFA39EF, double %86)
  %88 = call double @llvm.fma.f64(double %84, double 0x3C7ABC9E3B39803F, double %87)
  %89 = fadd double %85, %88
  %90 = fsub double %89, %85
  %91 = fsub double %88, %90
  %92 = call spir_func double @_Z5ldexpdi(double noundef %73, i32 noundef 1) #38
  %93 = call spir_func double @_Z5ldexpdi(double noundef %75, i32 noundef 1) #38
  %94 = fmul double %73, %76
  %95 = fmul double %94, %82
  %96 = fadd double %92, %95
  %97 = fsub double %96, %92
  %98 = fsub double %95, %97
  %99 = fadd double %93, %98
  %100 = fadd double %96, %99
  %101 = fsub double %100, %96
  %102 = fsub double %99, %101
  %103 = fadd double %89, %100
  %104 = fsub double %103, %89
  %105 = fsub double %103, %104
  %106 = fsub double %89, %105
  %107 = fsub double %100, %104
  %108 = fadd double %107, %106
  %109 = fadd double %91, %102
  %110 = fsub double %109, %91
  %111 = fsub double %109, %110
  %112 = fsub double %91, %111
  %113 = fsub double %102, %110
  %114 = fadd double %113, %112
  %115 = fadd double %109, %108
  %116 = fadd double %103, %115
  %117 = fsub double %116, %103
  %118 = fsub double %115, %117
  %119 = fadd double %114, %118
  %120 = fadd double %116, %119
  ret double %120
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_acosh_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = fcmp oge float %0, 0x43F0000000000000
  %4 = select i1 %3, float 0x3BF0000000000000, float 1.000000e+00
  %5 = fmul float %4, %0
  %6 = fmul float %5, %5
  %7 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %8 = freeze i32 %7
  %9 = icmp sgt i32 %8, 8999
  br i1 %9, label %11, label %10

10:                                               ; preds = %1
  switch i32 %8, label %14 [
    i32 8001, label %11
    i32 7001, label %11
  ]

11:                                               ; preds = %10, %10, %1
  %12 = fneg float %6
  %13 = tail call float @llvm.fma.f32(float %5, float %5, float %12)
  br label %24

14:                                               ; preds = %10
  %15 = bitcast float %5 to i32
  %16 = and i32 %15, -4096
  %17 = bitcast i32 %16 to float
  %18 = fsub float %5, %17
  %19 = fneg float %6
  %20 = tail call float @llvm.fmuladd.f32(float %17, float %17, float %19)
  %21 = fmul float %17, 2.000000e+00
  %22 = tail call float @llvm.fmuladd.f32(float %21, float %18, float %20)
  %23 = tail call float @llvm.fmuladd.f32(float %18, float %18, float %22)
  br label %24

24:                                               ; preds = %11, %14
  %25 = phi float [ %23, %14 ], [ %13, %11 ]
  %26 = select i1 %3, float 0x37F0000000000000, float 1.000000e+00
  %27 = fsub float %6, %26
  %28 = fsub float %27, %6
  %29 = fsub float %28, %27
  %30 = fadd float %6, %29
  %31 = fadd float %26, %28
  %32 = fsub float %30, %31
  %33 = fadd float %32, %25
  %34 = fadd float %27, %33
  %35 = fsub float %27, %34
  %36 = fadd float %33, %35
  %37 = tail call float @llvm.sqrt.f32(float %34), !fpmath !18
  %38 = fmul float %37, %37
  br i1 %9, label %40, label %39

39:                                               ; preds = %24
  switch i32 %8, label %43 [
    i32 8001, label %40
    i32 7001, label %40
  ]

40:                                               ; preds = %39, %39, %24
  %41 = fneg float %38
  %42 = tail call float @llvm.fma.f32(float %37, float %37, float %41)
  br label %53

43:                                               ; preds = %39
  %44 = bitcast float %37 to i32
  %45 = and i32 %44, -4096
  %46 = bitcast i32 %45 to float
  %47 = fsub float %37, %46
  %48 = fneg float %38
  %49 = tail call float @llvm.fmuladd.f32(float %46, float %46, float %48)
  %50 = fmul float %46, 2.000000e+00
  %51 = tail call float @llvm.fmuladd.f32(float %50, float %47, float %49)
  %52 = tail call float @llvm.fmuladd.f32(float %47, float %47, float %51)
  br label %53

53:                                               ; preds = %40, %43
  %54 = phi float [ %52, %43 ], [ %42, %40 ]
  %55 = fsub float %34, %38
  %56 = fsub float %34, %55
  %57 = fsub float %56, %38
  %58 = fadd float %36, %57
  %59 = fsub float %58, %54
  %60 = fadd float %55, %59
  %61 = fmul float %37, 2.000000e+00
  %62 = tail call spir_func float @_Z12native_recipf(float noundef %61) #38
  %63 = fmul float %62, %60
  %64 = fcmp oeq float %34, 0.000000e+00
  %65 = select i1 %64, float 0.000000e+00, float %63
  %66 = fadd float %37, %65
  %67 = fsub float %66, %37
  %68 = fsub float %65, %67
  %69 = fadd float %5, %66
  %70 = fsub float %69, %5
  %71 = fsub float %69, %70
  %72 = fsub float %5, %71
  %73 = fsub float %66, %70
  %74 = fadd float %73, %72
  %75 = fadd float %68, %74
  %76 = fadd float %69, %75
  %77 = fsub float %76, %69
  %78 = fsub float %75, %77
  %79 = insertelement <2 x float> poison, float %78, i64 0
  %80 = insertelement <2 x float> %79, float %76, i64 1
  %81 = select i1 %3, i32 64, i32 0
  %82 = tail call spir_func float @__ocmlpriv_lnep_f32(<2 x float> noundef %80, i32 noundef %81) #38
  %83 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %84 = icmp eq i8 %83, 0
  br i1 %84, label %85, label %92

85:                                               ; preds = %53
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %0, ptr %2, align 8, !tbaa !16
  %86 = addrspacecast ptr %2 to ptr addrspace(4)
  %87 = load i64, ptr addrspace(4) %86, align 8, !tbaa !12
  %88 = icmp eq i64 %87, 2139095040
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %89 = select i1 %88, float %0, float %82
  %90 = fcmp olt float %0, 1.000000e+00
  %91 = select i1 %90, float 0x7FF8000000000000, float %89
  br label %92

92:                                               ; preds = %85, %53
  %93 = phi float [ %82, %53 ], [ %91, %85 ]
  ret float %93
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fma.f32(float, float, float) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_lnep_f32(<2 x float> noundef %0, i32 noundef %1) local_unnamed_addr #21 {
  %3 = alloca i32, align 4
  %4 = extractelement <2 x float> %0, i64 1
  %5 = fcmp olt float %4, 0x3FE5555560000000
  %6 = sext i1 %5 to i32
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %7 = addrspacecast ptr %3 to ptr addrspace(4)
  %8 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %4, ptr addrspace(4) noundef %7) #40
  %9 = load i32, ptr %3, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %10 = add i32 %9, %6
  %11 = sub nsw i32 0, %10
  %12 = call spir_func float @_Z5ldexpfi(float noundef %4, i32 noundef %11) #38
  %13 = extractelement <2 x float> %0, i64 0
  %14 = call spir_func float @_Z5ldexpfi(float noundef %13, i32 noundef %11) #38
  %15 = fadd float %12, -1.000000e+00
  %16 = fadd float %15, 1.000000e+00
  %17 = fsub float %12, %16
  %18 = fadd float %14, %17
  %19 = fadd float %15, %18
  %20 = fsub float %19, %15
  %21 = fsub float %18, %20
  %22 = fadd float %12, 1.000000e+00
  %23 = fadd float %22, -1.000000e+00
  %24 = fsub float %12, %23
  %25 = fadd float %14, %24
  %26 = fadd float %22, %25
  %27 = fsub float %26, %22
  %28 = fsub float %25, %27
  %29 = call spir_func float @_Z12native_recipf(float noundef %26) #38
  %30 = fmul float %29, %19
  %31 = fmul float %26, %30
  %32 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %33 = freeze i32 %32
  %34 = icmp sgt i32 %33, 8999
  br i1 %34, label %35, label %40

35:                                               ; preds = %2
  %36 = fneg float %31
  %37 = call float @llvm.fma.f32(float %30, float %26, float %36)
  %38 = insertelement <2 x float> poison, float %37, i64 0
  %39 = insertelement <2 x float> %38, float %31, i64 1
  br label %62

40:                                               ; preds = %2
  switch i32 %33, label %41 [
    i32 8001, label %55
    i32 7001, label %55
  ]

41:                                               ; preds = %40
  %42 = bitcast float %30 to i32
  %43 = and i32 %42, -4096
  %44 = bitcast i32 %43 to float
  %45 = fsub float %30, %44
  %46 = bitcast float %26 to i32
  %47 = and i32 %46, -4096
  %48 = bitcast i32 %47 to float
  %49 = fsub float %26, %48
  %50 = fneg float %31
  %51 = call float @llvm.fmuladd.f32(float %44, float %48, float %50)
  %52 = call float @llvm.fmuladd.f32(float %44, float %49, float %51)
  %53 = call float @llvm.fmuladd.f32(float %45, float %48, float %52)
  %54 = call float @llvm.fmuladd.f32(float %45, float %49, float %53)
  br label %58

55:                                               ; preds = %40, %40
  %56 = fneg float %31
  %57 = call float @llvm.fma.f32(float %30, float %26, float %56)
  br label %58

58:                                               ; preds = %55, %41
  %59 = phi float [ %57, %55 ], [ %54, %41 ]
  %60 = insertelement <2 x float> poison, float %59, i64 0
  %61 = insertelement <2 x float> %60, float %31, i64 1
  switch i32 %33, label %67 [
    i32 8001, label %62
    i32 7001, label %62
  ]

62:                                               ; preds = %58, %58, %35
  %63 = phi <2 x float> [ %61, %58 ], [ %61, %58 ], [ %39, %35 ]
  %64 = phi float [ %59, %58 ], [ %59, %58 ], [ %37, %35 ]
  %65 = call float @llvm.fma.f32(float %30, float %28, float %64)
  %66 = insertelement <2 x float> %63, float %65, i64 0
  br label %70

67:                                               ; preds = %58
  %68 = call float @llvm.fmuladd.f32(float %30, float %28, float %59)
  %69 = insertelement <2 x float> %61, float %68, i64 0
  br label %70

70:                                               ; preds = %67, %62
  %71 = phi <2 x float> [ %66, %62 ], [ %69, %67 ]
  %72 = extractelement <2 x float> %71, i64 1
  %73 = extractelement <2 x float> %71, i64 0
  %74 = fadd float %72, %73
  %75 = fsub float %74, %72
  %76 = fsub float %19, %74
  %77 = fsub float %19, %76
  %78 = fsub float %77, %74
  %79 = fadd float %21, %78
  %80 = fsub float %75, %73
  %81 = fadd float %80, %79
  %82 = fadd float %76, %81
  %83 = fmul float %29, %82
  %84 = fmul float %26, %83
  br i1 %34, label %85, label %90

85:                                               ; preds = %70
  %86 = fneg float %84
  %87 = call float @llvm.fma.f32(float %83, float %26, float %86)
  %88 = insertelement <2 x float> poison, float %87, i64 0
  %89 = insertelement <2 x float> %88, float %84, i64 1
  br label %112

90:                                               ; preds = %70
  switch i32 %33, label %91 [
    i32 8001, label %105
    i32 7001, label %105
  ]

91:                                               ; preds = %90
  %92 = bitcast float %83 to i32
  %93 = and i32 %92, -4096
  %94 = bitcast i32 %93 to float
  %95 = fsub float %83, %94
  %96 = bitcast float %26 to i32
  %97 = and i32 %96, -4096
  %98 = bitcast i32 %97 to float
  %99 = fsub float %26, %98
  %100 = fneg float %84
  %101 = call float @llvm.fmuladd.f32(float %94, float %98, float %100)
  %102 = call float @llvm.fmuladd.f32(float %94, float %99, float %101)
  %103 = call float @llvm.fmuladd.f32(float %95, float %98, float %102)
  %104 = call float @llvm.fmuladd.f32(float %95, float %99, float %103)
  br label %108

105:                                              ; preds = %90, %90
  %106 = fneg float %84
  %107 = call float @llvm.fma.f32(float %83, float %26, float %106)
  br label %108

108:                                              ; preds = %105, %91
  %109 = phi float [ %107, %105 ], [ %104, %91 ]
  %110 = insertelement <2 x float> poison, float %109, i64 0
  %111 = insertelement <2 x float> %110, float %84, i64 1
  switch i32 %33, label %117 [
    i32 8001, label %112
    i32 7001, label %112
  ]

112:                                              ; preds = %108, %108, %85
  %113 = phi <2 x float> [ %111, %108 ], [ %111, %108 ], [ %89, %85 ]
  %114 = phi float [ %109, %108 ], [ %109, %108 ], [ %87, %85 ]
  %115 = call float @llvm.fma.f32(float %83, float %28, float %114)
  %116 = insertelement <2 x float> %113, float %115, i64 0
  br label %120

117:                                              ; preds = %108
  %118 = call float @llvm.fmuladd.f32(float %83, float %28, float %109)
  %119 = insertelement <2 x float> %111, float %118, i64 0
  br label %120

120:                                              ; preds = %112, %117
  %121 = phi <2 x float> [ %116, %112 ], [ %119, %117 ]
  %122 = fsub float %76, %82
  %123 = fadd float %81, %122
  %124 = extractelement <2 x float> %121, i64 1
  %125 = extractelement <2 x float> %121, i64 0
  %126 = fadd float %124, %125
  %127 = fsub float %126, %124
  %128 = fsub float %82, %126
  %129 = fsub float %82, %128
  %130 = fsub float %129, %126
  %131 = fadd float %123, %130
  %132 = fsub float %127, %125
  %133 = fadd float %132, %131
  %134 = fadd float %128, %133
  %135 = fmul float %29, %134
  %136 = fadd float %30, %83
  %137 = fsub float %136, %30
  %138 = fsub float %83, %137
  %139 = fadd float %138, %135
  %140 = fadd float %136, %139
  %141 = fmul float %140, %140
  %142 = call spir_func float @__ocml_fmuladd_f32(float noundef %141, float noundef 0x3FD36DB580000000, float noundef 0x3FD992B460000000) #38
  %143 = call spir_func float @__ocml_fmuladd_f32(float noundef %141, float noundef %142, float noundef 0x3FE5555B40000000) #38
  %144 = add nsw i32 %10, %1
  %145 = sitofp i32 %144 to float
  %146 = fmul float %145, 0x3FE62E4300000000
  br i1 %34, label %147, label %152

147:                                              ; preds = %120
  %148 = fneg float %146
  %149 = call float @llvm.fma.f32(float %145, float 0x3FE62E4300000000, float %148)
  %150 = insertelement <2 x float> poison, float %149, i64 0
  %151 = insertelement <2 x float> %150, float %146, i64 1
  br label %170

152:                                              ; preds = %120
  switch i32 %33, label %153 [
    i32 8001, label %163
    i32 7001, label %163
  ]

153:                                              ; preds = %152
  %154 = bitcast float %145 to i32
  %155 = and i32 %154, -4096
  %156 = bitcast i32 %155 to float
  %157 = fsub float %145, %156
  %158 = fneg float %146
  %159 = call float @llvm.fmuladd.f32(float %156, float 0x3FE62E0000000000, float %158)
  %160 = call float @llvm.fmuladd.f32(float %157, float 0x3FE62E0000000000, float %159)
  %161 = call float @llvm.fmuladd.f32(float %156, float 0x3F00C00000000000, float %160)
  %162 = call float @llvm.fmuladd.f32(float %157, float 0x3F00C00000000000, float %161)
  br label %166

163:                                              ; preds = %152, %152
  %164 = fneg float %146
  %165 = call float @llvm.fma.f32(float %145, float 0x3FE62E4300000000, float %164)
  br label %166

166:                                              ; preds = %163, %153
  %167 = phi float [ %165, %163 ], [ %162, %153 ]
  %168 = insertelement <2 x float> poison, float %167, i64 0
  %169 = insertelement <2 x float> %168, float %146, i64 1
  switch i32 %33, label %175 [
    i32 8001, label %170
    i32 7001, label %170
  ]

170:                                              ; preds = %166, %166, %147
  %171 = phi <2 x float> [ %169, %166 ], [ %169, %166 ], [ %151, %147 ]
  %172 = phi float [ %167, %166 ], [ %167, %166 ], [ %149, %147 ]
  %173 = call float @llvm.fma.f32(float %145, float 0xBE205C6100000000, float %172)
  %174 = insertelement <2 x float> %171, float %173, i64 0
  br label %178

175:                                              ; preds = %166
  %176 = call float @llvm.fmuladd.f32(float %145, float 0xBE205C6100000000, float %167)
  %177 = insertelement <2 x float> %169, float %176, i64 0
  br label %178

178:                                              ; preds = %170, %175
  %179 = phi <2 x float> [ %174, %170 ], [ %177, %175 ]
  %180 = fsub float %140, %136
  %181 = fsub float %139, %180
  %182 = extractelement <2 x float> %179, i64 1
  %183 = extractelement <2 x float> %179, i64 0
  %184 = fadd float %182, %183
  %185 = fsub float %184, %182
  %186 = fsub float %183, %185
  %187 = call spir_func float @_Z5ldexpfi(float noundef %140, i32 noundef 1) #38
  %188 = call spir_func float @_Z5ldexpfi(float noundef %181, i32 noundef 1) #38
  %189 = fmul float %140, %141
  %190 = fmul float %143, %189
  %191 = fadd float %190, %187
  %192 = fsub float %191, %187
  %193 = fsub float %190, %192
  %194 = fadd float %188, %193
  %195 = fadd float %191, %194
  %196 = fsub float %195, %191
  %197 = fsub float %194, %196
  %198 = fadd float %184, %195
  %199 = fsub float %198, %184
  %200 = fsub float %198, %199
  %201 = fsub float %184, %200
  %202 = fsub float %195, %199
  %203 = fadd float %202, %201
  %204 = fadd float %186, %197
  %205 = fsub float %204, %186
  %206 = fsub float %204, %205
  %207 = fsub float %186, %206
  %208 = fsub float %197, %205
  %209 = fadd float %208, %207
  %210 = fadd float %204, %203
  %211 = fadd float %198, %210
  %212 = fsub float %211, %198
  %213 = fsub float %210, %212
  %214 = fadd float %209, %213
  %215 = fadd float %211, %214
  ret float %215
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_acosh_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %3, float noundef -1.000000e+00) #38
  %5 = tail call float @llvm.sqrt.f32(float %4), !fpmath !18
  %6 = fadd float %5, %3
  %7 = tail call float @llvm.log2.f32(float %6)
  %8 = fmul float %7, 0x3FE62E4300000000
  %9 = fptrunc float %8 to half
  %10 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %11 = icmp eq i8 %10, 0
  %12 = fcmp olt half %2, 0xH3C00
  %13 = and i1 %12, %11
  %14 = select i1 %13, half 0xH7E00, half %9
  %15 = insertelement <2 x half> poison, half %14, i64 0
  %16 = extractelement <2 x half> %0, i64 1
  %17 = fpext half %16 to float
  %18 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %17, float noundef %17, float noundef -1.000000e+00) #38
  %19 = tail call float @llvm.sqrt.f32(float %18), !fpmath !18
  %20 = fadd float %19, %17
  %21 = tail call float @llvm.log2.f32(float %20)
  %22 = fmul float %21, 0x3FE62E4300000000
  %23 = fptrunc float %22 to half
  %24 = fcmp olt half %16, 0xH3C00
  %25 = and i1 %24, %11
  %26 = select i1 %25, half 0xH7E00, half %23
  %27 = insertelement <2 x half> %15, half %26, i64 1
  ret <2 x half> %27
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.log2.f32(float) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_acosh_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %2, float noundef -1.000000e+00) #38
  %4 = tail call float @llvm.sqrt.f32(float %3), !fpmath !18
  %5 = fadd float %4, %2
  %6 = tail call float @llvm.log2.f32(float %5)
  %7 = fmul float %6, 0x3FE62E4300000000
  %8 = fptrunc float %7 to half
  %9 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %10 = icmp eq i8 %9, 0
  %11 = fcmp olt half %0, 0xH3C00
  %12 = and i1 %11, %10
  %13 = select i1 %12, half 0xH7E00, half %8
  ret half %13
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_acospi_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fcmp oge double %2, 5.000000e-01
  %4 = tail call double @llvm.fma.f64(double %2, double -5.000000e-01, double 5.000000e-01)
  %5 = fmul double %0, %0
  %6 = select i1 %3, double %4, double %5
  %7 = tail call double @llvm.fma.f64(double %6, double 0x3F8547A51D41FB0B, double 0xBF76A3FB0718A8F7)
  %8 = tail call double @llvm.fma.f64(double %6, double %7, double 0x3F7A7B91F7177EE8)
  %9 = tail call double @llvm.fma.f64(double %6, double %8, double 0x3F6035D3435B8AD8)
  %10 = tail call double @llvm.fma.f64(double %6, double %9, double 0x3F6FF0549B4E0449)
  %11 = tail call double @llvm.fma.f64(double %6, double %10, double 0x3F721604AE288F96)
  %12 = tail call double @llvm.fma.f64(double %6, double %11, double 0x3F76A2B36F9AEC49)
  %13 = tail call double @llvm.fma.f64(double %6, double %12, double 0x3F7D2B076C914F04)
  %14 = tail call double @llvm.fma.f64(double %6, double %13, double 0x3F83CE53861F8F1F)
  %15 = tail call double @llvm.fma.f64(double %6, double %14, double 0x3F8D1A4529A30A69)
  %16 = tail call double @llvm.fma.f64(double %6, double %15, double 0x3F98723A1D61D2E9)
  %17 = tail call double @llvm.fma.f64(double %6, double %16, double 0x3FAB2995E7B7AF0F)
  %18 = fmul double %6, %17
  %19 = fmul double %0, 0x3FD45F306DC9C883
  %20 = tail call double @llvm.fma.f64(double %0, double %18, double %19)
  %21 = fsub double 5.000000e-01, %20
  br i1 %3, label %22, label %91

22:                                               ; preds = %1
  %23 = fptrunc double %4 to float
  %24 = tail call spir_func float @_Z12native_rsqrtf(float noundef %23) #38
  %25 = fpext float %24 to double
  %26 = fmul double %4, %25
  %27 = fmul double %25, 5.000000e-01
  %28 = fneg double %27
  %29 = tail call double @llvm.fma.f64(double %28, double %26, double 5.000000e-01)
  %30 = tail call double @llvm.fma.f64(double %27, double %29, double %27)
  %31 = tail call double @llvm.fma.f64(double %26, double %29, double %26)
  %32 = fneg double %31
  %33 = tail call double @llvm.fma.f64(double %32, double %31, double %4)
  %34 = tail call double @llvm.fma.f64(double %33, double %30, double %31)
  %35 = fcmp oeq double %4, 0.000000e+00
  %36 = select i1 %35, double %4, double %34
  %37 = fmul double %36, %36
  %38 = fneg double %37
  %39 = tail call double @llvm.fma.f64(double %36, double %36, double %38)
  %40 = fsub double %4, %37
  %41 = fsub double %4, %40
  %42 = fsub double %41, %37
  %43 = fsub double %42, %39
  %44 = fadd double %40, %43
  %45 = fmul double %36, 2.000000e+00
  %46 = fptrunc double %45 to float
  %47 = tail call spir_func float @_Z12native_recipf(float noundef %46) #38
  %48 = fpext float %47 to double
  %49 = fneg double %45
  %50 = tail call double @llvm.fma.f64(double %49, double %48, double 1.000000e+00)
  %51 = tail call double @llvm.fma.f64(double %50, double %48, double %48)
  %52 = tail call double @llvm.fma.f64(double %49, double %51, double 1.000000e+00)
  %53 = tail call double @llvm.fma.f64(double %52, double %51, double %51)
  %54 = fmul double %53, %44
  %55 = tail call double @llvm.fma.f64(double %49, double %54, double %44)
  %56 = tail call double @llvm.fma.f64(double %55, double %53, double %54)
  %57 = select i1 %35, double 0.000000e+00, double %56
  %58 = fadd double %36, %57
  %59 = fsub double %58, %36
  %60 = fsub double %57, %59
  %61 = tail call spir_func double @_Z5ldexpdi(double noundef %58, i32 noundef 1) #38
  %62 = tail call spir_func double @_Z5ldexpdi(double noundef %60, i32 noundef 1) #38
  %63 = fmul double %61, 0x3FD45F306DC9C883
  %64 = tail call double @llvm.fma.f64(double %61, double %18, double %63)
  %65 = fsub double 1.000000e+00, %64
  %66 = fneg double %63
  %67 = tail call double @llvm.fma.f64(double %61, double 0x3FD45F306DC9C883, double %66)
  %68 = tail call double @llvm.fma.f64(double %62, double 0x3FD45F306DC9C883, double %67)
  %69 = fadd double %63, %68
  %70 = fsub double %69, %63
  %71 = fsub double %68, %70
  %72 = fmul double %18, %61
  %73 = fneg double %72
  %74 = tail call double @llvm.fma.f64(double %61, double %18, double %73)
  %75 = tail call double @llvm.fma.f64(double %62, double %18, double %74)
  %76 = fadd double %72, %75
  %77 = fsub double %76, %72
  %78 = fsub double %75, %77
  %79 = fadd double %69, %76
  %80 = fsub double %79, %69
  %81 = fsub double %76, %80
  %82 = fadd double %71, %78
  %83 = fadd double %82, %81
  %84 = fadd double %79, %83
  %85 = fcmp olt double %0, 0.000000e+00
  %86 = select i1 %85, double %65, double %84
  %87 = fcmp oeq double %0, -1.000000e+00
  %88 = select i1 %87, double 1.000000e+00, double %86
  %89 = fcmp oeq double %0, 1.000000e+00
  %90 = select i1 %89, double 0.000000e+00, double %88
  br label %91

91:                                               ; preds = %22, %1
  %92 = phi double [ %90, %22 ], [ %21, %1 ]
  ret double %92
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_acospi_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = tail call spir_func float @__ocml_fmuladd_f32(float noundef -5.000000e-01, float noundef %2, float noundef 5.000000e-01) #38
  %4 = fmul float %0, %0
  %5 = fcmp ogt float %2, 5.000000e-01
  %6 = select i1 %5, float %3, float %4
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef 0xBF73F1C6C0000000, float noundef 0x3F92AC5600000000) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %7, float noundef 0x3F780AAB40000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %8, float noundef 0x3F8E533780000000) #38
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %9, float noundef 0x3F986680A0000000) #38
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %10, float noundef 0x3FAB29C5A0000000) #38
  %12 = fmul float %6, %11
  %13 = tail call float @llvm.sqrt.f32(float %6), !fpmath !18
  %14 = fmul float %13, 0x3FD45F3060000000
  %15 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %13, float noundef %12, float noundef %14) #38
  %16 = fmul float %15, 2.000000e+00
  %17 = fsub float 1.000000e+00, %16
  %18 = fcmp olt float %0, 0.000000e+00
  %19 = select i1 %18, float %17, float %16
  %20 = fmul float %0, 0x3FD45F3060000000
  %21 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef %12, float noundef %20) #38
  %22 = fsub float 5.000000e-01, %21
  %23 = select i1 %5, float %19, float %22
  ret float %23
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_acospi_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call half @llvm.fabs.f16(half %2)
  %4 = tail call half @llvm.fma.f16(half %3, half 0xHB800, half 0xH3800)
  %5 = fmul half %2, %2
  %6 = fcmp ogt half %3, 0xH3800
  %7 = select i1 %6, half %4, half %5
  %8 = tail call half @llvm.fma.f16(half %7, half 0xH282E, half 0xH2A9F)
  %9 = fmul half %7, %8
  %10 = tail call half @llvm.sqrt.f16(half %7)
  %11 = fmul half %10, 0xH3518
  %12 = tail call half @llvm.fma.f16(half %10, half %9, half %11)
  %13 = fmul half %12, 0xH4000
  %14 = fsub half 0xH3C00, %13
  %15 = fcmp olt half %2, 0xH0000
  %16 = select i1 %15, half %14, half %13
  %17 = fmul half %2, 0xH3518
  %18 = tail call half @llvm.fma.f16(half %2, half %9, half %17)
  %19 = fsub half 0xH3800, %18
  %20 = select i1 %6, half %16, half %19
  %21 = insertelement <2 x half> poison, half %20, i64 0
  %22 = extractelement <2 x half> %0, i64 1
  %23 = tail call half @llvm.fabs.f16(half %22)
  %24 = tail call half @llvm.fma.f16(half %23, half 0xHB800, half 0xH3800)
  %25 = fmul half %22, %22
  %26 = fcmp ogt half %23, 0xH3800
  %27 = select i1 %26, half %24, half %25
  %28 = tail call half @llvm.fma.f16(half %27, half 0xH282E, half 0xH2A9F)
  %29 = fmul half %27, %28
  %30 = tail call half @llvm.sqrt.f16(half %27)
  %31 = fmul half %30, 0xH3518
  %32 = tail call half @llvm.fma.f16(half %30, half %29, half %31)
  %33 = fmul half %32, 0xH4000
  %34 = fsub half 0xH3C00, %33
  %35 = fcmp olt half %22, 0xH0000
  %36 = select i1 %35, half %34, half %33
  %37 = fmul half %22, 0xH3518
  %38 = tail call half @llvm.fma.f16(half %22, half %29, half %37)
  %39 = fsub half 0xH3800, %38
  %40 = select i1 %26, half %36, half %39
  %41 = insertelement <2 x half> %21, half %40, i64 1
  ret <2 x half> %41
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_acospi_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  %3 = tail call half @llvm.fma.f16(half %2, half 0xHB800, half 0xH3800)
  %4 = fmul half %0, %0
  %5 = fcmp ogt half %2, 0xH3800
  %6 = select i1 %5, half %3, half %4
  %7 = tail call half @llvm.fma.f16(half %6, half 0xH282E, half 0xH2A9F)
  %8 = fmul half %6, %7
  %9 = tail call half @llvm.sqrt.f16(half %6)
  %10 = fmul half %9, 0xH3518
  %11 = tail call half @llvm.fma.f16(half %9, half %8, half %10)
  %12 = fmul half %11, 0xH4000
  %13 = fsub half 0xH3C00, %12
  %14 = fcmp olt half %0, 0xH0000
  %15 = select i1 %14, half %13, half %12
  %16 = fmul half %0, 0xH3518
  %17 = tail call half @llvm.fma.f16(half %0, half %8, half %16)
  %18 = fsub half 0xH3800, %17
  %19 = select i1 %5, half %15, half %18
  ret half %19
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_asin_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fcmp oge double %2, 5.000000e-01
  %4 = tail call double @llvm.fma.f64(double %2, double -5.000000e-01, double 5.000000e-01)
  %5 = fmul double %0, %0
  %6 = select i1 %3, double %4, double %5
  %7 = tail call double @llvm.fma.f64(double %6, double 0x3FA059859FEA6A70, double 0xBF90A5A378A05EAF)
  %8 = tail call double @llvm.fma.f64(double %6, double %7, double 0x3F94052137024D6A)
  %9 = tail call double @llvm.fma.f64(double %6, double %8, double 0x3F7AB3A098A70509)
  %10 = tail call double @llvm.fma.f64(double %6, double %9, double 0x3F88ED60A300C8D2)
  %11 = tail call double @llvm.fma.f64(double %6, double %10, double 0x3F8C6FA84B77012B)
  %12 = tail call double @llvm.fma.f64(double %6, double %11, double 0x3F91C6C111DCCB70)
  %13 = tail call double @llvm.fma.f64(double %6, double %12, double 0x3F96E89F0A0ADACF)
  %14 = tail call double @llvm.fma.f64(double %6, double %13, double 0x3F9F1C72C668963F)
  %15 = tail call double @llvm.fma.f64(double %6, double %14, double 0x3FA6DB6DB41CE4BD)
  %16 = tail call double @llvm.fma.f64(double %6, double %15, double 0x3FB333333336FD5B)
  %17 = tail call double @llvm.fma.f64(double %6, double %16, double 0x3FC5555555555380)
  %18 = fmul double %6, %17
  %19 = tail call double @llvm.fma.f64(double %2, double %18, double %2)
  br i1 %3, label %20, label %83

20:                                               ; preds = %1
  %21 = fptrunc double %4 to float
  %22 = tail call spir_func float @_Z12native_rsqrtf(float noundef %21) #38
  %23 = fpext float %22 to double
  %24 = fmul double %4, %23
  %25 = fmul double %23, 5.000000e-01
  %26 = fneg double %25
  %27 = tail call double @llvm.fma.f64(double %26, double %24, double 5.000000e-01)
  %28 = tail call double @llvm.fma.f64(double %25, double %27, double %25)
  %29 = tail call double @llvm.fma.f64(double %24, double %27, double %24)
  %30 = fneg double %29
  %31 = tail call double @llvm.fma.f64(double %30, double %29, double %4)
  %32 = tail call double @llvm.fma.f64(double %31, double %28, double %29)
  %33 = fcmp oeq double %4, 0.000000e+00
  %34 = select i1 %33, double %4, double %32
  %35 = fmul double %34, %34
  %36 = fneg double %35
  %37 = tail call double @llvm.fma.f64(double %34, double %34, double %36)
  %38 = fsub double %4, %35
  %39 = fsub double %4, %38
  %40 = fsub double %39, %35
  %41 = fsub double %40, %37
  %42 = fadd double %38, %41
  %43 = fmul double %34, 2.000000e+00
  %44 = fptrunc double %43 to float
  %45 = tail call spir_func float @_Z12native_recipf(float noundef %44) #38
  %46 = fpext float %45 to double
  %47 = fneg double %43
  %48 = tail call double @llvm.fma.f64(double %47, double %46, double 1.000000e+00)
  %49 = tail call double @llvm.fma.f64(double %48, double %46, double %46)
  %50 = tail call double @llvm.fma.f64(double %47, double %49, double 1.000000e+00)
  %51 = tail call double @llvm.fma.f64(double %50, double %49, double %49)
  %52 = fmul double %51, %42
  %53 = tail call double @llvm.fma.f64(double %47, double %52, double %42)
  %54 = tail call double @llvm.fma.f64(double %53, double %51, double %52)
  %55 = select i1 %33, double 0.000000e+00, double %54
  %56 = fadd double %34, %55
  %57 = fsub double %56, %34
  %58 = fsub double %55, %57
  %59 = fmul double %18, %56
  %60 = fneg double %59
  %61 = tail call double @llvm.fma.f64(double %56, double %18, double %60)
  %62 = tail call double @llvm.fma.f64(double %58, double %18, double %61)
  %63 = fadd double %59, %62
  %64 = fsub double %63, %59
  %65 = fsub double %62, %64
  %66 = fadd double %56, %63
  %67 = fsub double %66, %56
  %68 = fsub double %63, %67
  %69 = fadd double %58, %65
  %70 = fadd double %69, %68
  %71 = fadd double %66, %70
  %72 = fsub double %71, %66
  %73 = fsub double 0x3FE921FB54442D18, %71
  %74 = fsub double 0x3FE921FB54442D18, %73
  %75 = fsub double %74, %71
  %76 = fadd double %75, 0x3C81A62633145C07
  %77 = fsub double %72, %70
  %78 = fadd double %77, %76
  %79 = fadd double %73, %78
  %80 = fadd double %79, %79
  %81 = fcmp oeq double %2, 1.000000e+00
  %82 = select i1 %81, double 0x3FF921FB54442D18, double %80
  br label %83

83:                                               ; preds = %20, %1
  %84 = phi double [ %82, %20 ], [ %19, %1 ]
  %85 = tail call double @llvm.copysign.f64(double %84, double %0)
  ret double %85
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.copysign.f64(double, double) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_asin_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef -5.000000e-01, float noundef 5.000000e-01) #38
  %4 = fmul float %0, %0
  %5 = fcmp oge float %2, 5.000000e-01
  %6 = select i1 %5, float %3, float %4
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef 0x3FA38434E0000000, float noundef 0x3F8BF8BB40000000) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %7, float noundef 0x3FA0698780000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %8, float noundef 0x3FA6C83620000000) #38
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %9, float noundef 0x3FB3337900000000) #38
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %10, float noundef 0x3FC5555580000000) #38
  %12 = fmul float %6, %11
  %13 = tail call float @llvm.sqrt.f32(float %6), !fpmath !18
  %14 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %13, float noundef %12, float noundef %13) #38
  %15 = fmul float %14, -2.000000e+00
  %16 = tail call spir_func float @__ocml_fmuladd_f32(float noundef 0x3FEDDCB020000000, float noundef 0x3FFAEE9D60000000, float noundef %15) #38
  %17 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %12, float noundef %2) #38
  %18 = fcmp olt float %2, 5.000000e-01
  %19 = select i1 %18, float %17, float %16
  %20 = tail call float @llvm.copysign.f32(float %19, float %0)
  ret float %20
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.copysign.f32(float, float) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_asin_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_asin_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_asin_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_asin_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  %3 = fcmp ugt half %2, 0xH3800
  br i1 %3, label %9, label %4

4:                                                ; preds = %1
  %5 = fmul half %0, %0
  %6 = tail call half @llvm.fma.f16(half %5, half 0xH2E0A, half 0xH3148)
  %7 = fmul half %5, %6
  %8 = tail call half @llvm.fma.f16(half %2, half %7, half %2)
  br label %16

9:                                                ; preds = %1
  %10 = fpext half %2 to float
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef -5.000000e-01, float noundef 5.000000e-01) #38
  %12 = tail call float @llvm.sqrt.f32(float %11), !fpmath !18
  %13 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %11, float noundef 0xBFD82675A0000000, float noundef 0xBFFFF9F600000000) #38
  %14 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %12, float noundef %13, float noundef 0x3FF921FB60000000) #38
  %15 = fptrunc float %14 to half
  br label %16

16:                                               ; preds = %9, %4
  %17 = phi half [ %8, %4 ], [ %15, %9 ]
  %18 = tail call half @llvm.copysign.f16(half %17, half %0)
  ret half %18
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.copysign.f16(half, half) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_asinh_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = tail call double @llvm.fabs.f64(double %0)
  %4 = fcmp oge double %3, 0x5FF0000000000000
  %5 = select i1 %4, double 0x1FF0000000000000, double 1.000000e+00
  %6 = fmul double %3, %5
  %7 = fmul double %6, %6
  %8 = fneg double %7
  %9 = tail call double @llvm.fma.f64(double %6, double %6, double %8)
  %10 = select i1 %4, double 0x4000000000000, double 1.000000e+00
  %11 = fadd double %10, %7
  %12 = fsub double %11, %7
  %13 = fsub double %12, %11
  %14 = fadd double %7, %13
  %15 = fsub double %10, %12
  %16 = fadd double %15, %14
  %17 = fadd double %9, %16
  %18 = fadd double %11, %17
  %19 = fsub double %11, %18
  %20 = fadd double %17, %19
  %21 = fptrunc double %18 to float
  %22 = tail call spir_func float @_Z12native_rsqrtf(float noundef %21) #38
  %23 = fpext float %22 to double
  %24 = fmul double %18, %23
  %25 = fmul double %23, 5.000000e-01
  %26 = fneg double %25
  %27 = tail call double @llvm.fma.f64(double %26, double %24, double 5.000000e-01)
  %28 = tail call double @llvm.fma.f64(double %25, double %27, double %25)
  %29 = tail call double @llvm.fma.f64(double %24, double %27, double %24)
  %30 = fneg double %29
  %31 = tail call double @llvm.fma.f64(double %30, double %29, double %18)
  %32 = tail call double @llvm.fma.f64(double %31, double %28, double %29)
  %33 = fcmp oeq double %18, 0.000000e+00
  %34 = select i1 %33, double %18, double %32
  %35 = fmul double %34, %34
  %36 = fneg double %35
  %37 = tail call double @llvm.fma.f64(double %34, double %34, double %36)
  %38 = fsub double %18, %35
  %39 = fsub double %18, %38
  %40 = fsub double %39, %35
  %41 = fadd double %20, %40
  %42 = fsub double %41, %37
  %43 = fadd double %38, %42
  %44 = fmul double %34, 2.000000e+00
  %45 = fptrunc double %44 to float
  %46 = tail call spir_func float @_Z12native_recipf(float noundef %45) #38
  %47 = fpext float %46 to double
  %48 = fneg double %44
  %49 = tail call double @llvm.fma.f64(double %48, double %47, double 1.000000e+00)
  %50 = tail call double @llvm.fma.f64(double %49, double %47, double %47)
  %51 = tail call double @llvm.fma.f64(double %48, double %50, double 1.000000e+00)
  %52 = tail call double @llvm.fma.f64(double %51, double %50, double %50)
  %53 = fmul double %52, %43
  %54 = tail call double @llvm.fma.f64(double %48, double %53, double %43)
  %55 = tail call double @llvm.fma.f64(double %54, double %52, double %53)
  %56 = select i1 %33, double 0.000000e+00, double %55
  %57 = fadd double %34, %56
  %58 = fsub double %57, %34
  %59 = fsub double %56, %58
  %60 = fadd double %6, %57
  %61 = fsub double %60, %6
  %62 = fsub double %60, %61
  %63 = fsub double %6, %62
  %64 = fsub double %57, %61
  %65 = fadd double %64, %63
  %66 = fadd double %59, %65
  %67 = fadd double %60, %66
  %68 = fsub double %67, %60
  %69 = fsub double %66, %68
  %70 = insertelement <2 x double> poison, double %69, i64 0
  %71 = insertelement <2 x double> %70, double %67, i64 1
  %72 = select i1 %4, i32 512, i32 0
  %73 = tail call spir_func double @__ocmlpriv_lnep_f64(<2 x double> noundef %71, i32 noundef %72) #38
  %74 = fcmp olt double %3, 0x3E40000000000000
  %75 = select i1 %74, double %3, double %73
  %76 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %77 = icmp eq i8 %76, 0
  br i1 %77, label %78, label %83

78:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %3, ptr %2, align 8, !tbaa !19
  %79 = addrspacecast ptr %2 to ptr addrspace(4)
  %80 = load i128, ptr addrspace(4) %79, align 8, !tbaa !29
  %81 = icmp eq i128 %80, 9218868437227405312
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %82 = select i1 %81, double %3, double %75
  br label %83

83:                                               ; preds = %78, %1
  %84 = phi double [ %75, %1 ], [ %82, %78 ]
  %85 = tail call double @llvm.copysign.f64(double %84, double %0)
  ret double %85
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_asinh_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = tail call float @llvm.fabs.f32(float %0)
  %4 = fcmp oge float %3, 0x43F0000000000000
  %5 = select i1 %4, float 0x3BF0000000000000, float 1.000000e+00
  %6 = fmul float %3, %5
  %7 = fmul float %6, %6
  %8 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %9 = freeze i32 %8
  %10 = icmp sgt i32 %9, 8999
  br i1 %10, label %12, label %11

11:                                               ; preds = %1
  switch i32 %9, label %15 [
    i32 8001, label %12
    i32 7001, label %12
  ]

12:                                               ; preds = %11, %11, %1
  %13 = fneg float %7
  %14 = tail call float @llvm.fma.f32(float %6, float %6, float %13)
  br label %25

15:                                               ; preds = %11
  %16 = bitcast float %6 to i32
  %17 = and i32 %16, -4096
  %18 = bitcast i32 %17 to float
  %19 = fsub float %6, %18
  %20 = fneg float %7
  %21 = tail call float @llvm.fmuladd.f32(float %18, float %18, float %20)
  %22 = fmul float %18, 2.000000e+00
  %23 = tail call float @llvm.fmuladd.f32(float %22, float %19, float %21)
  %24 = tail call float @llvm.fmuladd.f32(float %19, float %19, float %23)
  br label %25

25:                                               ; preds = %12, %15
  %26 = phi float [ %24, %15 ], [ %14, %12 ]
  %27 = select i1 %4, float 0x37F0000000000000, float 1.000000e+00
  %28 = fadd float %27, %7
  %29 = fsub float %28, %7
  %30 = fsub float %29, %28
  %31 = fadd float %7, %30
  %32 = fsub float %27, %29
  %33 = fadd float %32, %31
  %34 = fadd float %33, %26
  %35 = fadd float %28, %34
  %36 = fsub float %28, %35
  %37 = fadd float %34, %36
  %38 = tail call float @llvm.sqrt.f32(float %35), !fpmath !18
  %39 = fmul float %38, %38
  br i1 %10, label %41, label %40

40:                                               ; preds = %25
  switch i32 %9, label %44 [
    i32 8001, label %41
    i32 7001, label %41
  ]

41:                                               ; preds = %40, %40, %25
  %42 = fneg float %39
  %43 = tail call float @llvm.fma.f32(float %38, float %38, float %42)
  br label %54

44:                                               ; preds = %40
  %45 = bitcast float %38 to i32
  %46 = and i32 %45, -4096
  %47 = bitcast i32 %46 to float
  %48 = fsub float %38, %47
  %49 = fneg float %39
  %50 = tail call float @llvm.fmuladd.f32(float %47, float %47, float %49)
  %51 = fmul float %47, 2.000000e+00
  %52 = tail call float @llvm.fmuladd.f32(float %51, float %48, float %50)
  %53 = tail call float @llvm.fmuladd.f32(float %48, float %48, float %52)
  br label %54

54:                                               ; preds = %41, %44
  %55 = phi float [ %53, %44 ], [ %43, %41 ]
  %56 = fsub float %35, %39
  %57 = fsub float %35, %56
  %58 = fsub float %57, %39
  %59 = fadd float %37, %58
  %60 = fsub float %59, %55
  %61 = fadd float %56, %60
  %62 = fmul float %38, 2.000000e+00
  %63 = tail call spir_func float @_Z12native_recipf(float noundef %62) #38
  %64 = fmul float %63, %61
  %65 = fcmp oeq float %35, 0.000000e+00
  %66 = select i1 %65, float 0.000000e+00, float %64
  %67 = fadd float %38, %66
  %68 = fsub float %67, %38
  %69 = fsub float %66, %68
  %70 = fadd float %6, %67
  %71 = fsub float %70, %6
  %72 = fsub float %70, %71
  %73 = fsub float %6, %72
  %74 = fsub float %67, %71
  %75 = fadd float %74, %73
  %76 = fadd float %69, %75
  %77 = fadd float %70, %76
  %78 = fsub float %77, %70
  %79 = fsub float %76, %78
  %80 = insertelement <2 x float> poison, float %79, i64 0
  %81 = insertelement <2 x float> %80, float %77, i64 1
  %82 = select i1 %4, i32 64, i32 0
  %83 = tail call spir_func float @__ocmlpriv_lnep_f32(<2 x float> noundef %81, i32 noundef %82) #38
  %84 = fcmp olt float %3, 0x3F30000000000000
  %85 = select i1 %84, float %3, float %83
  %86 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %87 = icmp eq i8 %86, 0
  br i1 %87, label %88, label %93

88:                                               ; preds = %54
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %3, ptr %2, align 8, !tbaa !16
  %89 = addrspacecast ptr %2 to ptr addrspace(4)
  %90 = load i64, ptr addrspace(4) %89, align 8, !tbaa !12
  %91 = icmp eq i64 %90, 2139095040
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %92 = select i1 %91, float %3, float %85
  br label %93

93:                                               ; preds = %88, %54
  %94 = phi float [ %85, %54 ], [ %92, %88 ]
  %95 = tail call float @llvm.copysign.f32(float %94, float %0)
  ret float %95
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_asinh_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_asinh_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_asinh_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_asinh_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %3, float noundef 1.000000e+00) #38
  %5 = tail call float @llvm.sqrt.f32(float %4), !fpmath !18
  %6 = fadd float %5, %3
  %7 = tail call float @llvm.log2.f32(float %6)
  %8 = fmul float %7, 0x3FE62E4300000000
  %9 = fptrunc float %8 to half
  %10 = tail call half @llvm.copysign.f16(half %9, half %0)
  %11 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %13, label %18

13:                                               ; preds = %1
  %14 = fptoui half %0 to i16
  %15 = tail call spir_func i32 @__builtin_generic_class_f16(i16 noundef zeroext %14) #39
  %16 = icmp eq i32 %15, 0
  %17 = select i1 %16, half %10, half %0
  br label %18

18:                                               ; preds = %13, %1
  %19 = phi half [ %10, %1 ], [ %17, %13 ]
  ret half %19
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16(i16 noundef zeroext %0) unnamed_addr #25 {
  switch i16 %0, label %2 [
    i16 31744, label %6
    i16 -1024, label %6
  ]

2:                                                ; preds = %1
  %3 = and i16 %0, 32256
  %4 = icmp ne i16 %3, 0
  %5 = sext i1 %4 to i32
  br label %6

6:                                                ; preds = %2, %1, %1
  %7 = phi i32 [ -1, %1 ], [ -1, %1 ], [ %5, %2 ]
  ret i32 %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_asinpi_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fcmp oge double %2, 5.000000e-01
  %4 = tail call double @llvm.fma.f64(double %2, double -5.000000e-01, double 5.000000e-01)
  %5 = fmul double %0, %0
  %6 = select i1 %3, double %4, double %5
  %7 = tail call double @llvm.fma.f64(double %6, double 0x3F8547A51D41FB0B, double 0xBF76A3FB0718A8F7)
  %8 = tail call double @llvm.fma.f64(double %6, double %7, double 0x3F7A7B91F7177EE8)
  %9 = tail call double @llvm.fma.f64(double %6, double %8, double 0x3F6035D3435B8AD8)
  %10 = tail call double @llvm.fma.f64(double %6, double %9, double 0x3F6FF0549B4E0449)
  %11 = tail call double @llvm.fma.f64(double %6, double %10, double 0x3F721604AE288F96)
  %12 = tail call double @llvm.fma.f64(double %6, double %11, double 0x3F76A2B36F9AEC49)
  %13 = tail call double @llvm.fma.f64(double %6, double %12, double 0x3F7D2B076C914F04)
  %14 = tail call double @llvm.fma.f64(double %6, double %13, double 0x3F83CE53861F8F1F)
  %15 = tail call double @llvm.fma.f64(double %6, double %14, double 0x3F8D1A4529A30A69)
  %16 = tail call double @llvm.fma.f64(double %6, double %15, double 0x3F98723A1D61D2E9)
  %17 = tail call double @llvm.fma.f64(double %6, double %16, double 0x3FAB2995E7B7AF0F)
  %18 = fmul double %6, %17
  %19 = fmul double %2, %18
  %20 = tail call double @llvm.fma.f64(double %2, double 0x3FD45F306DC9C883, double %19)
  br i1 %3, label %21, label %91

21:                                               ; preds = %1
  %22 = fptrunc double %4 to float
  %23 = tail call spir_func float @_Z12native_rsqrtf(float noundef %22) #38
  %24 = fpext float %23 to double
  %25 = fmul double %4, %24
  %26 = fmul double %24, 5.000000e-01
  %27 = fneg double %26
  %28 = tail call double @llvm.fma.f64(double %27, double %25, double 5.000000e-01)
  %29 = tail call double @llvm.fma.f64(double %26, double %28, double %26)
  %30 = tail call double @llvm.fma.f64(double %25, double %28, double %25)
  %31 = fneg double %30
  %32 = tail call double @llvm.fma.f64(double %31, double %30, double %4)
  %33 = tail call double @llvm.fma.f64(double %32, double %29, double %30)
  %34 = fcmp oeq double %4, 0.000000e+00
  %35 = select i1 %34, double %4, double %33
  %36 = fmul double %35, %35
  %37 = fneg double %36
  %38 = tail call double @llvm.fma.f64(double %35, double %35, double %37)
  %39 = fsub double %4, %36
  %40 = fsub double %4, %39
  %41 = fsub double %40, %36
  %42 = fsub double %41, %38
  %43 = fadd double %39, %42
  %44 = fmul double %35, 2.000000e+00
  %45 = fptrunc double %44 to float
  %46 = tail call spir_func float @_Z12native_recipf(float noundef %45) #38
  %47 = fpext float %46 to double
  %48 = fneg double %44
  %49 = tail call double @llvm.fma.f64(double %48, double %47, double 1.000000e+00)
  %50 = tail call double @llvm.fma.f64(double %49, double %47, double %47)
  %51 = tail call double @llvm.fma.f64(double %48, double %50, double 1.000000e+00)
  %52 = tail call double @llvm.fma.f64(double %51, double %50, double %50)
  %53 = fmul double %52, %43
  %54 = tail call double @llvm.fma.f64(double %48, double %53, double %43)
  %55 = tail call double @llvm.fma.f64(double %54, double %52, double %53)
  %56 = select i1 %34, double 0.000000e+00, double %55
  %57 = fadd double %35, %56
  %58 = fsub double %57, %35
  %59 = fsub double %56, %58
  %60 = tail call spir_func double @_Z5ldexpdi(double noundef %57, i32 noundef 1) #38
  %61 = tail call spir_func double @_Z5ldexpdi(double noundef %59, i32 noundef 1) #38
  %62 = fmul double %60, 0x3FD45F306DC9C883
  %63 = fneg double %62
  %64 = tail call double @llvm.fma.f64(double %60, double 0x3FD45F306DC9C883, double %63)
  %65 = tail call double @llvm.fma.f64(double %61, double 0x3FD45F306DC9C883, double %64)
  %66 = fadd double %62, %65
  %67 = fsub double %66, %62
  %68 = fsub double %65, %67
  %69 = fmul double %18, %60
  %70 = fneg double %69
  %71 = tail call double @llvm.fma.f64(double %60, double %18, double %70)
  %72 = tail call double @llvm.fma.f64(double %61, double %18, double %71)
  %73 = fadd double %69, %72
  %74 = fsub double %73, %69
  %75 = fsub double %72, %74
  %76 = fadd double %66, %73
  %77 = fsub double %76, %66
  %78 = fsub double %73, %77
  %79 = fadd double %68, %75
  %80 = fadd double %79, %78
  %81 = fadd double %76, %80
  %82 = fsub double %81, %76
  %83 = fsub double 5.000000e-01, %81
  %84 = fsub double 5.000000e-01, %83
  %85 = fsub double %84, %81
  %86 = fsub double %82, %80
  %87 = fadd double %86, %85
  %88 = fadd double %83, %87
  %89 = fcmp oeq double %2, 1.000000e+00
  %90 = select i1 %89, double 5.000000e-01, double %88
  br label %91

91:                                               ; preds = %21, %1
  %92 = phi double [ %90, %21 ], [ %20, %1 ]
  %93 = tail call double @llvm.copysign.f64(double %92, double %0)
  ret double %93
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_asinpi_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef -5.000000e-01, float noundef 5.000000e-01) #38
  %4 = fmul float %0, %0
  %5 = fcmp oge float %2, 5.000000e-01
  %6 = select i1 %5, float %3, float %4
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef 0xBF73F1C6C0000000, float noundef 0x3F92AC5600000000) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %7, float noundef 0x3F780AAB40000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %8, float noundef 0x3F8E533780000000) #38
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %9, float noundef 0x3F986680A0000000) #38
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %10, float noundef 0x3FAB29C5A0000000) #38
  %12 = fmul float %6, %11
  %13 = tail call float @llvm.sqrt.f32(float %6), !fpmath !18
  %14 = fmul float %13, 0x3FD45F3060000000
  %15 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %13, float noundef %12, float noundef %14) #38
  %16 = tail call spir_func float @__ocml_fmuladd_f32(float noundef -2.000000e+00, float noundef %15, float noundef 5.000000e-01) #38
  %17 = fmul float %2, %12
  %18 = tail call spir_func float @__ocml_fmuladd_f32(float noundef 0x3FD45F3060000000, float noundef %2, float noundef %17) #38
  %19 = select i1 %5, float %16, float %18
  %20 = tail call float @llvm.copysign.f32(float %19, float %0)
  ret float %20
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_asinpi_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call half @llvm.fabs.f16(half %2)
  %4 = fcmp ugt half %3, 0xH3800
  br i1 %4, label %10, label %5

5:                                                ; preds = %1
  %6 = fmul half %2, %2
  %7 = tail call half @llvm.fma.f16(half %6, half 0xH282E, half 0xH2A9F)
  %8 = tail call half @llvm.fma.f16(half %6, half %7, half 0xH3518)
  %9 = fmul half %3, %8
  br label %18

10:                                               ; preds = %1
  %11 = fpext half %3 to float
  %12 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %11, float noundef -5.000000e-01, float noundef 5.000000e-01) #38
  %13 = tail call float @llvm.sqrt.f32(float %12), !fpmath !18
  %14 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %12, float noundef 0xBFAF4B7360000000, float noundef 0xBFBAD08260000000) #38
  %15 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %12, float noundef %14, float noundef 0xBFE45F5A80000000) #38
  %16 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %13, float noundef %15, float noundef 5.000000e-01) #38
  %17 = fptrunc float %16 to half
  br label %18

18:                                               ; preds = %5, %10
  %19 = phi half [ %9, %5 ], [ %17, %10 ]
  %20 = extractelement <2 x half> %0, i64 1
  %21 = tail call half @llvm.fabs.f16(half %20)
  %22 = fcmp ugt half %21, 0xH3800
  br i1 %22, label %28, label %23

23:                                               ; preds = %18
  %24 = fmul half %20, %20
  %25 = tail call half @llvm.fma.f16(half %24, half 0xH282E, half 0xH2A9F)
  %26 = tail call half @llvm.fma.f16(half %24, half %25, half 0xH3518)
  %27 = fmul half %21, %26
  br label %36

28:                                               ; preds = %18
  %29 = fpext half %21 to float
  %30 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %29, float noundef -5.000000e-01, float noundef 5.000000e-01) #38
  %31 = tail call float @llvm.sqrt.f32(float %30), !fpmath !18
  %32 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef 0xBFAF4B7360000000, float noundef 0xBFBAD08260000000) #38
  %33 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %32, float noundef 0xBFE45F5A80000000) #38
  %34 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %31, float noundef %33, float noundef 5.000000e-01) #38
  %35 = fptrunc float %34 to half
  br label %36

36:                                               ; preds = %23, %28
  %37 = phi half [ %27, %23 ], [ %35, %28 ]
  %38 = tail call half @llvm.copysign.f16(half %19, half %2)
  %39 = insertelement <2 x half> poison, half %38, i64 0
  %40 = tail call half @llvm.copysign.f16(half %37, half %20)
  %41 = insertelement <2 x half> %39, half %40, i64 1
  ret <2 x half> %41
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_asinpi_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  %3 = fcmp ugt half %2, 0xH3800
  br i1 %3, label %9, label %4

4:                                                ; preds = %1
  %5 = fmul half %0, %0
  %6 = tail call half @llvm.fma.f16(half %5, half 0xH282E, half 0xH2A9F)
  %7 = tail call half @llvm.fma.f16(half %5, half %6, half 0xH3518)
  %8 = fmul half %2, %7
  br label %17

9:                                                ; preds = %1
  %10 = fpext half %2 to float
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef -5.000000e-01, float noundef 5.000000e-01) #38
  %12 = tail call float @llvm.sqrt.f32(float %11), !fpmath !18
  %13 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %11, float noundef 0xBFAF4B7360000000, float noundef 0xBFBAD08260000000) #38
  %14 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %11, float noundef %13, float noundef 0xBFE45F5A80000000) #38
  %15 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %12, float noundef %14, float noundef 5.000000e-01) #38
  %16 = fptrunc float %15 to half
  br label %17

17:                                               ; preds = %9, %4
  %18 = phi half [ %8, %4 ], [ %16, %9 ]
  %19 = tail call half @llvm.copysign.f16(half %18, half %0)
  ret half %19
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_atan2_f64(double noundef %0, double noundef %1) local_unnamed_addr #21 {
  %3 = tail call double @llvm.fabs.f64(double %0)
  %4 = tail call double @llvm.fabs.f64(double %1)
  %5 = tail call double @llvm.maxnum.f64(double %4, double %3)
  %6 = tail call double @llvm.minnum.f64(double %4, double %3)
  %7 = fdiv double %6, %5
  %8 = tail call spir_func double @__ocmlpriv_atanred_f64(double noundef %7) #38
  %9 = bitcast double %1 to <2 x i32>
  %10 = extractelement <2 x i32> %9, i64 1
  %11 = icmp slt i32 %10, 0
  %12 = fsub double 0x3FF921FB54442D18, %8
  %13 = fcmp olt double %4, %3
  %14 = select i1 %13, double %12, double %8
  %15 = fsub double 0x400921FB54442D18, %14
  %16 = select i1 %11, double %15, double %14
  %17 = select i1 %11, double 0x400921FB54442D18, double 0.000000e+00
  %18 = fcmp oeq double %0, 0.000000e+00
  %19 = select i1 %18, double %17, double %16
  %20 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %31

22:                                               ; preds = %2
  %23 = select i1 %11, double 0x4002D97C7F3321D2, double 0x3FE921FB54442D18
  %24 = tail call double @llvm.copysign.f64(double %23, double %0)
  %25 = fcmp oeq double %4, 0x7FF0000000000000
  %26 = fcmp oeq double %3, 0x7FF0000000000000
  %27 = and i1 %26, %25
  %28 = select i1 %27, double %24, double %19
  %29 = fcmp uno double %1, %0
  %30 = select i1 %29, double 0x7FF8000000000000, double %28
  br label %31

31:                                               ; preds = %22, %2
  %32 = phi double [ %19, %2 ], [ %30, %22 ]
  %33 = tail call double @llvm.copysign.f64(double %32, double %0)
  ret double %33
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.maxnum.f64(double, double) #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.minnum.f64(double, double) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_atanred_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = fmul double %0, %0
  %3 = tail call double @llvm.fma.f64(double %2, double 0x3EEBA404B5E68A13, double 0xBF23E260BD3237F4)
  %4 = tail call double @llvm.fma.f64(double %2, double %3, double 0x3F4B2BB069EFB384)
  %5 = tail call double @llvm.fma.f64(double %2, double %4, double 0xBF67952DAF56DE9B)
  %6 = tail call double @llvm.fma.f64(double %2, double %5, double 0x3F7D6D43A595C56F)
  %7 = tail call double @llvm.fma.f64(double %2, double %6, double 0xBF8C6EA4A57D9582)
  %8 = tail call double @llvm.fma.f64(double %2, double %7, double 0x3F967E295F08B19F)
  %9 = tail call double @llvm.fma.f64(double %2, double %8, double 0xBF9E9AE6FC27006A)
  %10 = tail call double @llvm.fma.f64(double %2, double %9, double 0x3FA2C15B5711927A)
  %11 = tail call double @llvm.fma.f64(double %2, double %10, double 0xBFA59976E82D3FF0)
  %12 = tail call double @llvm.fma.f64(double %2, double %11, double 0x3FA82D5D6EF28734)
  %13 = tail call double @llvm.fma.f64(double %2, double %12, double 0xBFAAE5CE6A214619)
  %14 = tail call double @llvm.fma.f64(double %2, double %13, double 0x3FAE1BB48427B883)
  %15 = tail call double @llvm.fma.f64(double %2, double %14, double 0xBFB110E48B207F05)
  %16 = tail call double @llvm.fma.f64(double %2, double %15, double 0x3FB3B13657B87036)
  %17 = tail call double @llvm.fma.f64(double %2, double %16, double 0xBFB745D119378E4F)
  %18 = tail call double @llvm.fma.f64(double %2, double %17, double 0x3FBC71C717E1913C)
  %19 = tail call double @llvm.fma.f64(double %2, double %18, double 0xBFC2492492376B7D)
  %20 = tail call double @llvm.fma.f64(double %2, double %19, double 0x3FC99999999952CC)
  %21 = tail call double @llvm.fma.f64(double %2, double %20, double 0xBFD5555555555523)
  %22 = fmul double %2, %21
  %23 = tail call double @llvm.fma.f64(double %0, double %22, double %0)
  ret double %23
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_atan2_f32(float noundef %0, float noundef %1) local_unnamed_addr #21 {
  %3 = tail call float @llvm.fabs.f32(float %1)
  %4 = tail call float @llvm.fabs.f32(float %0)
  %5 = tail call float @llvm.minnum.f32(float %3, float %4)
  %6 = tail call float @llvm.maxnum.f32(float %3, float %4)
  %7 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %16, label %9

9:                                                ; preds = %2
  %10 = fcmp ogt float %6, 0x45F0000000000000
  %11 = select i1 %10, float 0x3DF0000000000000, float 1.000000e+00
  %12 = fmul float %6, %11
  %13 = tail call spir_func float @_Z12native_recipf(float noundef %12) #38
  %14 = fmul float %5, %13
  %15 = fmul float %11, %14
  br label %18

16:                                               ; preds = %2
  %17 = fdiv float %5, %6, !fpmath !15
  br label %18

18:                                               ; preds = %16, %9
  %19 = phi float [ %15, %9 ], [ %17, %16 ]
  %20 = tail call spir_func float @__ocmlpriv_atanred_f32(float noundef %19) #38
  %21 = fsub float 0x3FF921FB60000000, %20
  %22 = fcmp ogt float %4, %3
  %23 = select i1 %22, float %21, float %20
  %24 = fsub float 0x400921FB60000000, %23
  %25 = fcmp olt float %1, 0.000000e+00
  %26 = select i1 %25, float %24, float %23
  %27 = bitcast float %1 to i32
  %28 = icmp slt i32 %27, 0
  %29 = select i1 %28, float 0x400921FB60000000, float 0.000000e+00
  %30 = fcmp oeq float %0, 0.000000e+00
  %31 = select i1 %30, float %29, float %26
  %32 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %34, label %42

34:                                               ; preds = %18
  %35 = select i1 %25, float 0x4002D97C80000000, float 0x3FE921FB60000000
  %36 = fcmp oeq float %3, 0x7FF0000000000000
  %37 = fcmp oeq float %4, 0x7FF0000000000000
  %38 = and i1 %37, %36
  %39 = select i1 %38, float %35, float %31
  %40 = fcmp uno float %1, %0
  %41 = select i1 %40, float 0x7FF8000000000000, float %39
  br label %42

42:                                               ; preds = %34, %18
  %43 = phi float [ %31, %18 ], [ %41, %34 ]
  %44 = tail call float @llvm.copysign.f32(float %43, float %0)
  ret float %44
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.minnum.f32(float, float) #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.maxnum.f32(float, float) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_atanred_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = fmul float %0, %0
  %3 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef 0x3F65A54B00000000, float noundef 0xBF8F4B2180000000) #38
  %4 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %3, float noundef 0x3FA53F67E0000000) #38
  %5 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %4, float noundef 0xBFB2FA9AE0000000) #38
  %6 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %5, float noundef 0x3FBB263640000000) #38
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %6, float noundef 0xBFC22C1CC0000000) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %7, float noundef 0x3FC99717E0000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %8, float noundef 0xBFD5554C40000000) #38
  %10 = fmul float %2, %9
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef %10, float noundef %0) #38
  ret float %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_atan2_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #21 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = tail call spir_func half @__ocml_atan2_f16(half noundef %3, half noundef %4) #38
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = extractelement <2 x half> %1, i64 1
  %9 = tail call spir_func half @__ocml_atan2_f16(half noundef %7, half noundef %8) #38
  %10 = insertelement <2 x half> %6, half %9, i64 1
  ret <2 x half> %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_atan2_f16(half noundef %0, half noundef %1) local_unnamed_addr #24 {
  %3 = tail call half @llvm.fabs.f16(half %1)
  %4 = tail call half @llvm.fabs.f16(half %0)
  %5 = tail call half @llvm.minnum.f16(half %3, half %4)
  %6 = tail call half @llvm.maxnum.f16(half %3, half %4)
  %7 = fdiv half %5, %6
  %8 = tail call spir_func half @__ocmlpriv_atanred_f16(half noundef %7) #38
  %9 = fsub half 0xH3E48, %8
  %10 = fcmp ogt half %4, %3
  %11 = select i1 %10, half %9, half %8
  %12 = fsub half 0xH4248, %11
  %13 = fcmp olt half %1, 0xH0000
  %14 = select i1 %13, half %12, half %11
  %15 = bitcast half %1 to i16
  %16 = icmp slt i16 %15, 0
  %17 = select i1 %16, half 0xH4248, half 0xH0000
  %18 = fcmp oeq half %0, 0xH0000
  %19 = select i1 %18, half %17, half %14
  %20 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %30

22:                                               ; preds = %2
  %23 = select i1 %13, half 0xH40B6, half 0xH3A48
  %24 = fcmp oeq half %3, 0xH7C00
  %25 = fcmp oeq half %4, 0xH7C00
  %26 = and i1 %25, %24
  %27 = select i1 %26, half %23, half %19
  %28 = fcmp uno half %1, %0
  %29 = select i1 %28, half 0xH7E00, half %27
  br label %30

30:                                               ; preds = %22, %2
  %31 = phi half [ %19, %2 ], [ %29, %22 ]
  %32 = tail call half @llvm.copysign.f16(half %31, half %0)
  ret half %32
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.minnum.f16(half, half) #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.maxnum.f16(half, half) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocmlpriv_atanred_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = fmul half %0, %0
  %3 = tail call half @llvm.fma.f16(half %2, half 0xHA9E2, half 0xH3113)
  %4 = tail call half @llvm.fma.f16(half %2, half %3, half 0xHB53D)
  %5 = fmul half %2, %4
  %6 = tail call half @llvm.fma.f16(half %0, half %5, half %0)
  ret half %6
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_atan2pi_f64(double noundef %0, double noundef %1) local_unnamed_addr #21 {
  %3 = tail call double @llvm.fabs.f64(double %0)
  %4 = tail call double @llvm.fabs.f64(double %1)
  %5 = tail call double @llvm.maxnum.f64(double %4, double %3)
  %6 = tail call double @llvm.minnum.f64(double %4, double %3)
  %7 = fdiv double %6, %5
  %8 = tail call spir_func double @__ocmlpriv_atanpired_f64(double noundef %7) #38
  %9 = bitcast double %1 to <2 x i32>
  %10 = extractelement <2 x i32> %9, i64 1
  %11 = icmp slt i32 %10, 0
  %12 = fsub double 5.000000e-01, %8
  %13 = fcmp olt double %4, %3
  %14 = select i1 %13, double %12, double %8
  %15 = fsub double 1.000000e+00, %14
  %16 = select i1 %11, double %15, double %14
  %17 = select i1 %11, double 1.000000e+00, double 0.000000e+00
  %18 = fcmp oeq double %0, 0.000000e+00
  %19 = select i1 %18, double %17, double %16
  %20 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %31

22:                                               ; preds = %2
  %23 = select i1 %11, double 7.500000e-01, double 2.500000e-01
  %24 = tail call double @llvm.copysign.f64(double %23, double %0)
  %25 = fcmp oeq double %4, 0x7FF0000000000000
  %26 = fcmp oeq double %3, 0x7FF0000000000000
  %27 = and i1 %26, %25
  %28 = select i1 %27, double %24, double %19
  %29 = fcmp uno double %1, %0
  %30 = select i1 %29, double 0x7FF8000000000000, double %28
  br label %31

31:                                               ; preds = %22, %2
  %32 = phi double [ %19, %2 ], [ %30, %22 ]
  %33 = tail call double @llvm.copysign.f64(double %32, double %0)
  ret double %33
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_atanpired_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = fmul double %0, %0
  %3 = tail call double @llvm.fma.f64(double %2, double 0x3ED39E58B43320D2, double 0xBF0BE9E52F5DF14F)
  %4 = tail call double @llvm.fma.f64(double %2, double %3, double 0x3F32D7A6CAD8E9DB)
  %5 = tail call double @llvm.fma.f64(double %2, double %4, double 0xBF5024EBCC10F8A6)
  %6 = tail call double @llvm.fma.f64(double %2, double %5, double 0x3F63DF92946A87D8)
  %7 = tail call double @llvm.fma.f64(double %2, double %6, double 0xBF72F04271B6CD94)
  %8 = tail call double @llvm.fma.f64(double %2, double %7, double 0x3F7D91B9A6908690)
  %9 = tail call double @llvm.fma.f64(double %2, double %8, double 0xBF83E1C18F5EA692)
  %10 = tail call double @llvm.fma.f64(double %2, double %9, double 0x3F88253E53662BE6)
  %11 = tail call double @llvm.fma.f64(double %2, double %10, double 0xBF8BA3DB7E462112)
  %12 = tail call double @llvm.fma.f64(double %2, double %11, double 0x3F8ED7188505388C)
  %13 = tail call double @llvm.fma.f64(double %2, double %12, double 0xBF9121F707A5851B)
  %14 = tail call double @llvm.fma.f64(double %2, double %13, double 0x3F932B737D7F904A)
  %15 = tail call double @llvm.fma.f64(double %2, double %14, double 0xBF95BAC13378EA68)
  %16 = tail call double @llvm.fma.f64(double %2, double %15, double 0x3F9912AF944C4411)
  %17 = tail call double @llvm.fma.f64(double %2, double %16, double 0xBF9DA1BABD44FCCF)
  %18 = tail call double @llvm.fma.f64(double %2, double %17, double 0x3FA21BB945AACD29)
  %19 = tail call double @llvm.fma.f64(double %2, double %18, double 0xBFA7483758F7040F)
  %20 = tail call double @llvm.fma.f64(double %2, double %19, double 0x3FB04C26BE3B5934)
  %21 = tail call double @llvm.fma.f64(double %2, double %20, double 0xBFBB2995E7B7B74D)
  %22 = tail call double @llvm.fma.f64(double %2, double %21, double 0x3FD45F306DC9C883)
  %23 = fmul double %22, %0
  ret double %23
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_atan2pi_f32(float noundef %0, float noundef %1) local_unnamed_addr #21 {
  %3 = tail call float @llvm.fabs.f32(float %1)
  %4 = tail call float @llvm.fabs.f32(float %0)
  %5 = tail call float @llvm.minnum.f32(float %3, float %4)
  %6 = tail call float @llvm.maxnum.f32(float %3, float %4)
  %7 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %16, label %9

9:                                                ; preds = %2
  %10 = fcmp ogt float %6, 0x45F0000000000000
  %11 = select i1 %10, float 0x3DF0000000000000, float 1.000000e+00
  %12 = fmul float %6, %11
  %13 = tail call spir_func float @_Z12native_recipf(float noundef %12) #38
  %14 = fmul float %5, %13
  %15 = fmul float %11, %14
  br label %18

16:                                               ; preds = %2
  %17 = fdiv float %5, %6, !fpmath !15
  br label %18

18:                                               ; preds = %16, %9
  %19 = phi float [ %15, %9 ], [ %17, %16 ]
  %20 = tail call spir_func float @__ocmlpriv_atanpired_f32(float noundef %19) #38
  %21 = fsub float 5.000000e-01, %20
  %22 = fcmp ogt float %4, %3
  %23 = select i1 %22, float %21, float %20
  %24 = fsub float 1.000000e+00, %23
  %25 = fcmp olt float %1, 0.000000e+00
  %26 = select i1 %25, float %24, float %23
  %27 = bitcast float %1 to i32
  %28 = icmp slt i32 %27, 0
  %29 = select i1 %28, float 1.000000e+00, float 0.000000e+00
  %30 = fcmp oeq float %0, 0.000000e+00
  %31 = select i1 %30, float %29, float %26
  %32 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %34, label %42

34:                                               ; preds = %18
  %35 = select i1 %25, float 7.500000e-01, float 2.500000e-01
  %36 = fcmp oeq float %3, 0x7FF0000000000000
  %37 = fcmp oeq float %4, 0x7FF0000000000000
  %38 = and i1 %37, %36
  %39 = select i1 %38, float %35, float %31
  %40 = fcmp uno float %1, %0
  %41 = select i1 %40, float 0x7FF8000000000000, float %39
  br label %42

42:                                               ; preds = %34, %18
  %43 = phi float [ %31, %18 ], [ %41, %34 ]
  %44 = tail call float @llvm.copysign.f32(float %43, float %0)
  ret float %44
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_atanpired_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = fmul float %0, %0
  %3 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef 0x3F4CCF8360000000, float noundef 0xBF74761E40000000) #38
  %4 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %3, float noundef 0x3F8B6662E0000000) #38
  %5 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %4, float noundef 0xBF98423B40000000) #38
  %6 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %5, float noundef 0x3FA149CB40000000) #38
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %6, float noundef 0xBFA721CCC0000000) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %7, float noundef 0x3FB04A4660000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %8, float noundef 0xBFBB2981C0000000) #38
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %9, float noundef 0x3FD45F3060000000) #38
  %11 = fmul float %10, %0
  ret float %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_atan2pi_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #21 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = tail call spir_func half @__ocml_atan2pi_f16(half noundef %3, half noundef %4) #38
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = extractelement <2 x half> %1, i64 1
  %9 = tail call spir_func half @__ocml_atan2pi_f16(half noundef %7, half noundef %8) #38
  %10 = insertelement <2 x half> %6, half %9, i64 1
  ret <2 x half> %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_atan2pi_f16(half noundef %0, half noundef %1) local_unnamed_addr #24 {
  %3 = tail call half @llvm.fabs.f16(half %1)
  %4 = tail call half @llvm.fabs.f16(half %0)
  %5 = tail call half @llvm.minnum.f16(half %3, half %4)
  %6 = tail call half @llvm.maxnum.f16(half %3, half %4)
  %7 = fdiv half %5, %6
  %8 = tail call spir_func half @__ocmlpriv_atanpired_f16(half noundef %7) #38
  %9 = fsub half 0xH3800, %8
  %10 = fcmp ogt half %4, %3
  %11 = select i1 %10, half %9, half %8
  %12 = fsub half 0xH3C00, %11
  %13 = fcmp olt half %1, 0xH0000
  %14 = select i1 %13, half %12, half %11
  %15 = bitcast half %1 to i16
  %16 = icmp slt i16 %15, 0
  %17 = select i1 %16, half 0xH3C00, half 0xH0000
  %18 = fcmp oeq half %0, 0xH0000
  %19 = select i1 %18, half %17, half %14
  %20 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %30

22:                                               ; preds = %2
  %23 = select i1 %13, half 0xH3A00, half 0xH3400
  %24 = fcmp oeq half %3, 0xH7C00
  %25 = fcmp oeq half %4, 0xH7C00
  %26 = and i1 %25, %24
  %27 = select i1 %26, half %23, half %19
  %28 = fcmp uno half %1, %0
  %29 = select i1 %28, half 0xH7E00, half %27
  br label %30

30:                                               ; preds = %22, %2
  %31 = phi half [ %19, %2 ], [ %29, %22 ]
  %32 = tail call half @llvm.copysign.f16(half %31, half %0)
  ret half %32
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocmlpriv_atanpired_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = fmul half %0, %0
  %3 = tail call half @llvm.fma.f16(half %2, half 0xHA3BD, half 0xH2A91)
  %4 = tail call half @llvm.fma.f16(half %2, half %3, half 0xHAEB2)
  %5 = tail call half @llvm.fma.f16(half %2, half %4, half 0xH3518)
  %6 = fmul half %5, %0
  ret half %6
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_atan_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fcmp ogt double %2, 1.000000e+00
  %4 = fdiv double 1.000000e+00, %2
  %5 = select i1 %3, double %4, double %2
  %6 = tail call spir_func double @__ocmlpriv_atanred_f64(double noundef %5) #38
  %7 = fneg double %6
  %8 = tail call double @llvm.fma.f64(double 0x3FEDD9AD336A0500, double 0x3FFAF154EEB562D6, double %7)
  %9 = select i1 %3, double %8, double %6
  %10 = tail call double @llvm.copysign.f64(double %9, double %0)
  ret double %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_atan_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = fcmp ogt float %2, 1.000000e+00
  %4 = tail call spir_func float @_Z12native_recipf(float noundef %2) #38
  %5 = select i1 %3, float %4, float %2
  %6 = tail call spir_func float @__ocmlpriv_atanred_f32(float noundef %5) #38
  %7 = fneg float %6
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef 0x3FEDDCB020000000, float noundef 0x3FFAEE9D60000000, float noundef %7) #38
  %9 = select i1 %3, float %8, float %6
  %10 = tail call float @llvm.copysign.f32(float %9, float %0)
  ret float %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_atan_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_atan_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_atan_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_atan_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  %3 = fcmp ogt half %2, 0xH3C00
  %4 = fpext half %2 to float
  %5 = tail call spir_func float @_Z10half_recipf(float noundef %4) #38
  %6 = fptrunc float %5 to half
  %7 = select i1 %3, half %6, half %2
  %8 = tail call spir_func half @__ocmlpriv_atanred_f16(half noundef %7) #38
  %9 = fneg half %8
  %10 = tail call half @llvm.fma.f16(half 0xH3BAA, half 0xH3E8F, half %9)
  %11 = select i1 %3, half %10, half %8
  %12 = tail call half @llvm.copysign.f16(half %11, half %0)
  ret half %12
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z10half_recipf(float noundef) local_unnamed_addr #22

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_atanh_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fadd double %2, 1.000000e+00
  %4 = fadd double %3, -1.000000e+00
  %5 = fsub double %2, %4
  %6 = fsub double 1.000000e+00, %2
  %7 = fsub double 1.000000e+00, %6
  %8 = fsub double %7, %2
  %9 = fptrunc double %6 to float
  %10 = tail call spir_func float @_Z12native_recipf(float noundef %9) #38
  %11 = fpext float %10 to double
  %12 = fneg double %6
  %13 = tail call double @llvm.fma.f64(double %12, double %11, double 1.000000e+00)
  %14 = tail call double @llvm.fma.f64(double %13, double %11, double %11)
  %15 = tail call double @llvm.fma.f64(double %12, double %14, double 1.000000e+00)
  %16 = tail call double @llvm.fma.f64(double %15, double %14, double %14)
  %17 = fmul double %3, %16
  %18 = fmul double %6, %17
  %19 = fneg double %18
  %20 = tail call double @llvm.fma.f64(double %17, double %6, double %19)
  %21 = tail call double @llvm.fma.f64(double %17, double %8, double %20)
  %22 = fadd double %18, %21
  %23 = fsub double %22, %18
  %24 = fsub double %3, %22
  %25 = fsub double %3, %24
  %26 = fsub double %25, %22
  %27 = fsub double %23, %21
  %28 = fadd double %27, %26
  %29 = fadd double %5, %28
  %30 = fadd double %24, %29
  %31 = fmul double %16, %30
  %32 = fadd double %17, %31
  %33 = fsub double %32, %17
  %34 = fsub double %31, %33
  %35 = insertelement <2 x double> poison, double %34, i64 0
  %36 = insertelement <2 x double> %35, double %32, i64 1
  %37 = tail call spir_func double @__ocmlpriv_lnep_f64(<2 x double> noundef %36, i32 noundef 0) #38
  %38 = fmul double %37, 5.000000e-01
  %39 = fcmp olt double %2, 0x3E40000000000000
  %40 = select i1 %39, double %2, double %38
  %41 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %42 = icmp eq i8 %41, 0
  %43 = fcmp ogt double %2, 1.000000e+00
  %44 = select i1 %43, double 0x7FF8000000000000, double %40
  %45 = fcmp oeq double %2, 1.000000e+00
  %46 = select i1 %45, double 0x7FF0000000000000, double %44
  %47 = select i1 %42, double %46, double %40
  %48 = tail call double @llvm.copysign.f64(double %47, double %0)
  ret double %48
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_atanh_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = fadd float %2, 1.000000e+00
  %4 = fsub float 1.000000e+00, %2
  %5 = fsub float 1.000000e+00, %4
  %6 = fsub float %5, %2
  %7 = tail call spir_func float @_Z12native_recipf(float noundef %4) #38
  %8 = fmul float %3, %7
  %9 = fmul float %4, %8
  %10 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %11 = freeze i32 %10
  %12 = icmp sgt i32 %11, 8999
  br i1 %12, label %13, label %18

13:                                               ; preds = %1
  %14 = fneg float %9
  %15 = tail call float @llvm.fma.f32(float %8, float %4, float %14)
  %16 = insertelement <2 x float> poison, float %15, i64 0
  %17 = insertelement <2 x float> %16, float %9, i64 1
  br label %40

18:                                               ; preds = %1
  switch i32 %11, label %19 [
    i32 8001, label %33
    i32 7001, label %33
  ]

19:                                               ; preds = %18
  %20 = bitcast float %8 to i32
  %21 = and i32 %20, -4096
  %22 = bitcast i32 %21 to float
  %23 = fsub float %8, %22
  %24 = bitcast float %4 to i32
  %25 = and i32 %24, -4096
  %26 = bitcast i32 %25 to float
  %27 = fsub float %4, %26
  %28 = fneg float %9
  %29 = tail call float @llvm.fmuladd.f32(float %22, float %26, float %28)
  %30 = tail call float @llvm.fmuladd.f32(float %22, float %27, float %29)
  %31 = tail call float @llvm.fmuladd.f32(float %23, float %26, float %30)
  %32 = tail call float @llvm.fmuladd.f32(float %23, float %27, float %31)
  br label %36

33:                                               ; preds = %18, %18
  %34 = fneg float %9
  %35 = tail call float @llvm.fma.f32(float %8, float %4, float %34)
  br label %36

36:                                               ; preds = %33, %19
  %37 = phi float [ %35, %33 ], [ %32, %19 ]
  %38 = insertelement <2 x float> poison, float %37, i64 0
  %39 = insertelement <2 x float> %38, float %9, i64 1
  switch i32 %11, label %45 [
    i32 8001, label %40
    i32 7001, label %40
  ]

40:                                               ; preds = %36, %36, %13
  %41 = phi <2 x float> [ %39, %36 ], [ %39, %36 ], [ %17, %13 ]
  %42 = phi float [ %37, %36 ], [ %37, %36 ], [ %15, %13 ]
  %43 = tail call float @llvm.fma.f32(float %8, float %6, float %42)
  %44 = insertelement <2 x float> %41, float %43, i64 0
  br label %48

45:                                               ; preds = %36
  %46 = tail call float @llvm.fmuladd.f32(float %8, float %6, float %37)
  %47 = insertelement <2 x float> %39, float %46, i64 0
  br label %48

48:                                               ; preds = %40, %45
  %49 = phi <2 x float> [ %44, %40 ], [ %47, %45 ]
  %50 = fadd float %3, -1.000000e+00
  %51 = fsub float %2, %50
  %52 = extractelement <2 x float> %49, i64 1
  %53 = extractelement <2 x float> %49, i64 0
  %54 = fadd float %52, %53
  %55 = fsub float %54, %52
  %56 = fsub float %3, %54
  %57 = fsub float %3, %56
  %58 = fsub float %57, %54
  %59 = fsub float %55, %53
  %60 = fadd float %59, %58
  %61 = fadd float %51, %60
  %62 = fadd float %56, %61
  %63 = fmul float %7, %62
  %64 = fadd float %8, %63
  %65 = fsub float %64, %8
  %66 = fsub float %63, %65
  %67 = insertelement <2 x float> poison, float %66, i64 0
  %68 = insertelement <2 x float> %67, float %64, i64 1
  %69 = tail call spir_func float @__ocmlpriv_lnep_f32(<2 x float> noundef %68, i32 noundef 0) #38
  %70 = fmul float %69, 5.000000e-01
  %71 = fcmp olt float %2, 0x3F30000000000000
  %72 = select i1 %71, float %2, float %70
  %73 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %74 = icmp eq i8 %73, 0
  %75 = fcmp ogt float %2, 1.000000e+00
  %76 = select i1 %75, float 0x7FF8000000000000, float %72
  %77 = fcmp oeq float %2, 1.000000e+00
  %78 = select i1 %77, float 0x7FF0000000000000, float %76
  %79 = select i1 %74, float %78, float %72
  %80 = tail call float @llvm.copysign.f32(float %79, float %0)
  ret float %80
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_atanh_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call half @llvm.fabs.f16(half %2)
  %4 = fpext half %3 to float
  %5 = fadd float %4, 1.000000e+00
  %6 = fsub float 1.000000e+00, %4
  %7 = tail call spir_func float @_Z12native_recipf(float noundef %6) #38
  %8 = fmul float %5, %7
  %9 = tail call float @llvm.log2.f32(float %8)
  %10 = fmul float %9, 0x3FD62E4300000000
  %11 = fptrunc float %10 to half
  %12 = fcmp olt half %3, 0xH2000
  %13 = select i1 %12, half %3, half %11
  %14 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %16, label %23

16:                                               ; preds = %1
  %17 = fcmp oeq half %3, 0xH3C00
  %18 = select i1 %17, half 0xH7C00, half %13
  %19 = fcmp ogt half %3, 0xH3C00
  %20 = fcmp uno half %2, 0xH0000
  %21 = or i1 %20, %19
  %22 = select i1 %21, half 0xH7E00, half %18
  br label %23

23:                                               ; preds = %1, %16
  %24 = phi half [ %13, %1 ], [ %22, %16 ]
  %25 = extractelement <2 x half> %0, i64 1
  %26 = tail call half @llvm.fabs.f16(half %25)
  %27 = fpext half %26 to float
  %28 = fadd float %27, 1.000000e+00
  %29 = fsub float 1.000000e+00, %27
  %30 = tail call spir_func float @_Z12native_recipf(float noundef %29) #38
  %31 = fmul float %28, %30
  %32 = tail call float @llvm.log2.f32(float %31)
  %33 = fmul float %32, 0x3FD62E4300000000
  %34 = fptrunc float %33 to half
  %35 = fcmp olt half %26, 0xH2000
  %36 = select i1 %35, half %26, half %34
  br i1 %15, label %37, label %44

37:                                               ; preds = %23
  %38 = fcmp oeq half %26, 0xH3C00
  %39 = select i1 %38, half 0xH7C00, half %36
  %40 = fcmp ogt half %26, 0xH3C00
  %41 = fcmp uno half %25, 0xH0000
  %42 = or i1 %41, %40
  %43 = select i1 %42, half 0xH7E00, half %39
  br label %44

44:                                               ; preds = %23, %37
  %45 = phi half [ %36, %23 ], [ %43, %37 ]
  %46 = tail call half @llvm.copysign.f16(half %24, half %2)
  %47 = insertelement <2 x half> poison, half %46, i64 0
  %48 = tail call half @llvm.copysign.f16(half %45, half %25)
  %49 = insertelement <2 x half> %47, half %48, i64 1
  ret <2 x half> %49
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_atanh_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  %3 = fpext half %2 to float
  %4 = fadd float %3, 1.000000e+00
  %5 = fsub float 1.000000e+00, %3
  %6 = tail call spir_func float @_Z12native_recipf(float noundef %5) #38
  %7 = fmul float %4, %6
  %8 = tail call float @llvm.log2.f32(float %7)
  %9 = fmul float %8, 0x3FD62E4300000000
  %10 = fptrunc float %9 to half
  %11 = fcmp olt half %2, 0xH2000
  %12 = select i1 %11, half %2, half %10
  %13 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %15, label %22

15:                                               ; preds = %1
  %16 = fcmp oeq half %2, 0xH3C00
  %17 = select i1 %16, half 0xH7C00, half %12
  %18 = fcmp ogt half %2, 0xH3C00
  %19 = fcmp uno half %0, 0xH0000
  %20 = or i1 %19, %18
  %21 = select i1 %20, half 0xH7E00, half %17
  br label %22

22:                                               ; preds = %15, %1
  %23 = phi half [ %12, %1 ], [ %21, %15 ]
  %24 = tail call half @llvm.copysign.f16(half %23, half %0)
  ret half %24
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_atanpi_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fcmp ogt double %2, 1.000000e+00
  %4 = fdiv double 1.000000e+00, %2
  %5 = select i1 %3, double %4, double %2
  %6 = tail call spir_func double @__ocmlpriv_atanpired_f64(double noundef %5) #38
  %7 = fsub double 5.000000e-01, %6
  %8 = select i1 %3, double %7, double %6
  %9 = tail call double @llvm.copysign.f64(double %8, double %0)
  ret double %9
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_atanpi_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = fcmp ogt float %2, 1.000000e+00
  %4 = tail call spir_func float @_Z12native_recipf(float noundef %2) #38
  %5 = select i1 %3, float %4, float %2
  %6 = tail call spir_func float @__ocmlpriv_atanpired_f32(float noundef %5) #38
  %7 = fsub float 5.000000e-01, %6
  %8 = select i1 %3, float %7, float %6
  %9 = tail call float @llvm.copysign.f32(float %8, float %0)
  ret float %9
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_atanpi_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_atanpi_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_atanpi_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_atanpi_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  %3 = fcmp ogt half %2, 0xH3C00
  %4 = fpext half %2 to float
  %5 = tail call spir_func float @_Z10half_recipf(float noundef %4) #38
  %6 = fptrunc float %5 to half
  %7 = select i1 %3, half %6, half %2
  %8 = tail call spir_func half @__ocmlpriv_atanpired_f16(half noundef %7) #38
  %9 = fsub half 0xH3800, %8
  %10 = select i1 %3, half %9, half %8
  %11 = tail call half @llvm.copysign.f16(half %10, half %0)
  ret half %11
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_ba0_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.fma.f64(double %0, double 0x41344395CD7AC32C, double 0xC0F25BF3ABBEE803)
  %3 = tail call double @llvm.fma.f64(double %0, double %2, double 0x40A55A4A78625B0F)
  %4 = tail call double @llvm.fma.f64(double %0, double %3, double 0xC05A826C7EA56321)
  %5 = tail call double @llvm.fma.f64(double %0, double %4, double 0x401763253BBF53B6)
  %6 = tail call double @llvm.fma.f64(double %0, double %5, double 0xBFE15EFAFF948953)
  %7 = tail call double @llvm.fma.f64(double %0, double %6, double 0x3FBA7FFFF967A1D4)
  %8 = tail call double @llvm.fma.f64(double %0, double %7, double 0xBFAFFFFFFFFF2868)
  %9 = tail call double @llvm.fma.f64(double %0, double %8, double 1.000000e+00)
  ret double %9
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_ba0_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef 0x3FB92AECC0000000, float noundef 0xBFAFFE4720000000) #38
  %3 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef %2, float noundef 1.000000e+00) #38
  ret float %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_ba1_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.fma.f64(double %0, double 0xC137940A06621145, double 0x40F591FB68428BAF)
  %3 = tail call double @llvm.fma.f64(double %0, double %2, double 0xC0A996552A8BAFB0)
  %4 = tail call double @llvm.fma.f64(double %0, double %3, double 0x4060795578CD8C93)
  %5 = tail call double @llvm.fma.f64(double %0, double %4, double 0xC01EF38364596B5A)
  %6 = tail call double @llvm.fma.f64(double %0, double %5, double 0x3FE9C4FA465744C7)
  %7 = tail call double @llvm.fma.f64(double %0, double %6, double 0xBFC8BFFFFC3937C1)
  %8 = tail call double @llvm.fma.f64(double %0, double %7, double 0x3FC7FFFFFFFFC240)
  %9 = tail call double @llvm.fma.f64(double %0, double %8, double 1.000000e+00)
  ret double %9
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_ba1_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef 0xBFC7C0D460000000, float noundef 0x3FC7FF5AA0000000) #38
  %3 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef %2, float noundef 1.000000e+00) #38
  ret float %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_bp0_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.fma.f64(double %0, double 0xC1B91F780A4A989B, double 0x41752A41923B70A7)
  %3 = tail call double @llvm.fma.f64(double %0, double %2, double 0xC1240A5E31612A8D)
  %4 = tail call double @llvm.fma.f64(double %0, double %3, double 0x40D0C9A0CBE3B3B8)
  %5 = tail call double @llvm.fma.f64(double %0, double %4, double 0xC080AF76167FE583)
  %6 = tail call double @llvm.fma.f64(double %0, double %5, double 0x403778EA61B94139)
  %7 = tail call double @llvm.fma.f64(double %0, double %6, double 0xBFFA3581D1A82662)
  %8 = tail call double @llvm.fma.f64(double %0, double %7, double 0x3FCAD33330A1DAF2)
  %9 = tail call double @llvm.fma.f64(double %0, double %8, double 0xBFB0AAAAAAAA7909)
  %10 = tail call double @llvm.fma.f64(double %0, double %9, double 1.250000e-01)
  ret double %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_bp0_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef 0xBFF5EC5E60000000, float noundef 0x3FCAAFB080000000) #38
  %3 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef %2, float noundef 0xBFB0AA9260000000) #38
  %4 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef %3, float noundef 1.250000e-01) #38
  ret float %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_bp1_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.fma.f64(double %0, double 0x41BC22F653D3A76E, double 0xC1780A4D95ED3E8E)
  %3 = tail call double @llvm.fma.f64(double %0, double %2, double 0x41272F1D1F8CDD76)
  %4 = tail call double @llvm.fma.f64(double %0, double %3, double 0xC0D3EA4E96460AD7)
  %5 = tail call double @llvm.fma.f64(double %0, double %4, double 0x408488DD98D9AB3A)
  %6 = tail call double @llvm.fma.f64(double %0, double %5, double 0xC03E9ED612FA3B38)
  %7 = tail call double @llvm.fma.f64(double %0, double %6, double 0x4002F484FCAB9DDA)
  %8 = tail call double @llvm.fma.f64(double %0, double %7, double 0xBFD7BCCCCAD443C0)
  %9 = tail call double @llvm.fma.f64(double %0, double %8, double 0x3FC4FFFFFFFFCBFA)
  %10 = tail call double @llvm.fma.f64(double %0, double %9, double -3.750000e-01)
  ret double %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_bp1_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef 0x4000214CE0000000, float noundef 0xBFD7A54CA0000000) #38
  %3 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef %2, float noundef 0x3FC4FFEFE0000000) #38
  %4 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef %3, float noundef -3.750000e-01) #38
  ret float %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_cabs_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x double> %0, i64 0
  %3 = extractelement <2 x double> %0, i64 1
  %4 = tail call spir_func double @__ocml_hypot_f64(double noundef %2, double noundef %3) #38
  ret double %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_hypot_f64(double noundef %0, double noundef %1) local_unnamed_addr #21 {
  %3 = alloca i32, align 4
  %4 = tail call double @llvm.fabs.f64(double %0)
  %5 = tail call double @llvm.fabs.f64(double %1)
  %6 = tail call double @llvm.maxnum.f64(double %4, double %5)
  %7 = fptrunc double %6 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %8 = addrspacecast ptr %3 to ptr addrspace(4)
  %9 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %7, ptr addrspace(4) noundef %8) #40
  %10 = load i32, ptr %3, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %11 = sub nsw i32 0, %10
  %12 = call spir_func double @_Z5ldexpdi(double noundef %4, i32 noundef %11) #38
  %13 = call spir_func double @_Z5ldexpdi(double noundef %5, i32 noundef %11) #38
  %14 = fmul double %13, %13
  %15 = call double @llvm.fma.f64(double %12, double %12, double %14)
  %16 = fptrunc double %15 to float
  %17 = call spir_func float @_Z12native_rsqrtf(float noundef %16) #38
  %18 = fpext float %17 to double
  %19 = fmul double %15, %18
  %20 = fmul double %18, 5.000000e-01
  %21 = fneg double %20
  %22 = call double @llvm.fma.f64(double %21, double %19, double 5.000000e-01)
  %23 = call double @llvm.fma.f64(double %20, double %22, double %20)
  %24 = call double @llvm.fma.f64(double %19, double %22, double %19)
  %25 = fneg double %24
  %26 = call double @llvm.fma.f64(double %25, double %24, double %15)
  %27 = call double @llvm.fma.f64(double %26, double %23, double %24)
  %28 = fcmp oeq double %15, 0.000000e+00
  %29 = select i1 %28, double %15, double %27
  %30 = call spir_func double @_Z5ldexpdi(double noundef %29, i32 noundef %10) #38
  %31 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %32 = icmp eq i8 %31, 0
  br i1 %32, label %33, label %40

33:                                               ; preds = %2
  %34 = fcmp uno double %0, %1
  %35 = select i1 %34, double 0x7FF8000000000000, double %30
  %36 = fcmp oeq double %4, 0x7FF0000000000000
  %37 = fcmp oeq double %5, 0x7FF0000000000000
  %38 = or i1 %36, %37
  %39 = select i1 %38, double 0x7FF0000000000000, double %35
  br label %40

40:                                               ; preds = %33, %2
  %41 = phi double [ %30, %2 ], [ %39, %33 ]
  ret double %41
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_cabs_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x float> %0, i64 0
  %3 = extractelement <2 x float> %0, i64 1
  %4 = tail call spir_func float @__ocml_hypot_f32(float noundef %2, float noundef %3) #38
  ret float %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_hypot_f32(float noundef %0, float noundef %1) local_unnamed_addr #21 {
  %3 = alloca i32, align 4
  %4 = tail call float @llvm.fabs.f32(float %0)
  %5 = tail call float @llvm.fabs.f32(float %1)
  %6 = tail call float @llvm.maxnum.f32(float %4, float %5)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %7 = addrspacecast ptr %3 to ptr addrspace(4)
  %8 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %6, ptr addrspace(4) noundef %7) #40
  %9 = load i32, ptr %3, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %10 = sub nsw i32 0, %9
  %11 = call spir_func float @_Z5ldexpfi(float noundef %4, i32 noundef %10) #38
  %12 = call spir_func float @_Z5ldexpfi(float noundef %5, i32 noundef %10) #38
  %13 = fmul float %12, %12
  %14 = call spir_func float @__ocml_fmuladd_f32(float noundef %11, float noundef %11, float noundef %13) #38
  %15 = call float @llvm.sqrt.f32(float %14), !fpmath !18
  %16 = call spir_func float @_Z5ldexpfi(float noundef %15, i32 noundef %9) #38
  %17 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %18 = icmp eq i8 %17, 0
  %19 = call float @llvm.fabs.f32(float %6)
  %20 = fcmp oeq float %19, 0x7FF0000000000000
  %21 = and i1 %20, %18
  %22 = select i1 %21, float 0x7FF0000000000000, float %16
  ret float %22
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_cacos_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = tail call spir_func <2 x double> @__ocml_cacosh_f64(<2 x double> noundef %0) #38
  %3 = extractelement <2 x double> %0, i64 1
  %4 = bitcast double %3 to <2 x i32>
  %5 = extractelement <2 x i32> %4, i64 1
  %6 = icmp slt i32 %5, 0
  %7 = extractelement <2 x double> %2, i64 1
  %8 = fneg double %7
  %9 = select i1 %6, double %8, double %7
  %10 = extractelement <2 x double> %2, i64 0
  %11 = fneg double %10
  %12 = select i1 %6, double %10, double %11
  %13 = insertelement <2 x double> poison, double %9, i64 0
  %14 = insertelement <2 x double> %13, double %12, i64 1
  ret <2 x double> %14
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_cacosh_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = extractelement <2 x double> %0, i64 0
  %4 = tail call double @llvm.fabs.f64(double %3)
  %5 = extractelement <2 x double> %0, i64 1
  %6 = tail call double @llvm.fabs.f64(double %5)
  %7 = fcmp olt double %4, 0x4350000000000000
  %8 = fcmp olt double %6, 0x4350000000000000
  %9 = and i1 %7, %8
  br i1 %9, label %10, label %143

10:                                               ; preds = %1
  %11 = fcmp oge double %4, 1.000000e+00
  %12 = fcmp oge double %6, 0x3CA0000000000000
  %13 = or i1 %11, %12
  br i1 %13, label %18, label %14

14:                                               ; preds = %10
  %15 = fsub double 1.000000e+00, %4
  %16 = fmul double %15, 0x3E50000000000000
  %17 = fcmp ogt double %6, %16
  br i1 %17, label %18, label %188

18:                                               ; preds = %14, %10
  %19 = fadd double %6, %4
  %20 = fsub double %19, %6
  %21 = fsub double %20, %19
  %22 = fadd double %6, %21
  %23 = fsub double %4, %20
  %24 = fadd double %23, %22
  %25 = fsub double %6, %4
  %26 = fsub double %25, %6
  %27 = fsub double %26, %25
  %28 = fadd double %6, %27
  %29 = fadd double %4, %26
  %30 = fsub double %28, %29
  %31 = fmul double %19, %25
  %32 = fneg double %31
  %33 = tail call double @llvm.fma.f64(double %19, double %25, double %32)
  %34 = tail call double @llvm.fma.f64(double %19, double %30, double %33)
  %35 = tail call double @llvm.fma.f64(double %24, double %25, double %34)
  %36 = fadd double %31, %35
  %37 = fsub double %36, %31
  %38 = fsub double %35, %37
  %39 = fadd double %36, 1.000000e+00
  %40 = fsub double %39, %36
  %41 = fsub double %39, %40
  %42 = fsub double %36, %41
  %43 = fsub double 1.000000e+00, %40
  %44 = fadd double %43, %42
  %45 = fadd double %38, %44
  %46 = fadd double %39, %45
  %47 = fsub double %39, %46
  %48 = fadd double %45, %47
  %49 = insertelement <2 x double> poison, double %48, i64 0
  %50 = insertelement <2 x double> %49, double %46, i64 1
  %51 = fmul double %6, %4
  %52 = fneg double %51
  %53 = tail call double @llvm.fma.f64(double %6, double %4, double %52)
  %54 = insertelement <2 x double> poison, double %53, i64 0
  %55 = insertelement <2 x double> %54, double %51, i64 1
  %56 = fmul <2 x double> %55, <double 2.000000e+00, double 2.000000e+00>
  %57 = shufflevector <2 x double> %50, <2 x double> %56, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %58 = tail call spir_func <4 x double> @__ocmlpriv_epcsqrtep_f64(<4 x double> noundef %57) #38
  %59 = shufflevector <4 x double> %58, <4 x double> poison, <2 x i32> <i32 2, i32 3>
  %60 = extractelement <4 x double> %58, i64 3
  %61 = bitcast double %60 to <2 x i32>
  %62 = bitcast double %3 to <2 x i32>
  %63 = xor <2 x i32> %61, %62
  %64 = extractelement <2 x i32> %63, i64 1
  %65 = fneg <2 x double> %59
  %66 = icmp slt i32 %64, 0
  %67 = select i1 %66, <2 x double> %65, <2 x double> %59
  %68 = shufflevector <4 x double> %58, <4 x double> poison, <2 x i32> <i32 0, i32 1>
  %69 = extractelement <4 x double> %58, i64 1
  %70 = bitcast double %69 to <2 x i32>
  %71 = bitcast double %5 to <2 x i32>
  %72 = xor <2 x i32> %70, %71
  %73 = extractelement <2 x i32> %72, i64 1
  %74 = fneg <2 x double> %68
  %75 = icmp slt i32 %73, 0
  %76 = select i1 %75, <2 x double> %74, <2 x double> %68
  %77 = extractelement <2 x double> %67, i64 1
  %78 = fadd double %3, %77
  %79 = fsub double %78, %77
  %80 = fsub double %78, %79
  %81 = fsub double %77, %80
  %82 = fsub double %3, %79
  %83 = fadd double %82, %81
  %84 = extractelement <2 x double> %67, i64 0
  %85 = fadd double %84, %83
  %86 = fadd double %78, %85
  %87 = fsub double %86, %78
  %88 = fsub double %85, %87
  %89 = extractelement <2 x double> %76, i64 1
  %90 = fadd double %5, %89
  %91 = fsub double %90, %89
  %92 = fsub double %90, %91
  %93 = fsub double %89, %92
  %94 = fsub double %5, %91
  %95 = fadd double %94, %93
  %96 = extractelement <2 x double> %76, i64 0
  %97 = fadd double %96, %95
  %98 = fadd double %90, %97
  %99 = fsub double %98, %90
  %100 = fsub double %97, %99
  %101 = fmul double %86, %86
  %102 = fneg double %101
  %103 = tail call double @llvm.fma.f64(double %86, double %86, double %102)
  %104 = fmul double %88, 2.000000e+00
  %105 = tail call double @llvm.fma.f64(double %86, double %104, double %103)
  %106 = fadd double %101, %105
  %107 = fsub double %106, %101
  %108 = fsub double %105, %107
  %109 = fmul double %98, %98
  %110 = fneg double %109
  %111 = tail call double @llvm.fma.f64(double %98, double %98, double %110)
  %112 = fmul double %100, 2.000000e+00
  %113 = tail call double @llvm.fma.f64(double %98, double %112, double %111)
  %114 = fadd double %109, %113
  %115 = fsub double %114, %109
  %116 = fsub double %113, %115
  %117 = fadd double %106, %114
  %118 = fsub double %117, %106
  %119 = fsub double %118, %117
  %120 = fadd double %106, %119
  %121 = fsub double %114, %118
  %122 = fadd double %121, %120
  %123 = fadd double %108, %116
  %124 = fsub double %123, %108
  %125 = fsub double %123, %124
  %126 = fsub double %108, %125
  %127 = fsub double %116, %124
  %128 = fadd double %127, %126
  %129 = fadd double %123, %122
  %130 = fadd double %117, %129
  %131 = fsub double %117, %130
  %132 = fadd double %129, %131
  %133 = fadd double %128, %132
  %134 = fadd double %130, %133
  %135 = fsub double %130, %134
  %136 = fadd double %133, %135
  %137 = insertelement <2 x double> poison, double %136, i64 0
  %138 = insertelement <2 x double> %137, double %134, i64 1
  %139 = insertelement <2 x double> poison, double %86, i64 0
  %140 = fcmp oeq double %5, 0.000000e+00
  %141 = select i1 %140, double %5, double %98
  %142 = insertelement <2 x double> %139, double %141, i64 1
  br label %182

143:                                              ; preds = %1
  %144 = tail call double @llvm.maxnum.f64(double %4, double %6)
  %145 = fptrunc double %144 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %146 = addrspacecast ptr %2 to ptr addrspace(4)
  %147 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %145, ptr addrspace(4) noundef %146) #40
  %148 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %149 = sub nsw i32 0, %148
  %150 = call spir_func double @_Z5ldexpdi(double noundef %4, i32 noundef %149) #38
  %151 = call spir_func double @_Z5ldexpdi(double noundef %6, i32 noundef %149) #38
  %152 = fmul double %150, %150
  %153 = fneg double %152
  %154 = call double @llvm.fma.f64(double %150, double %150, double %153)
  %155 = fmul double %151, %151
  %156 = fneg double %155
  %157 = call double @llvm.fma.f64(double %151, double %151, double %156)
  %158 = fadd double %152, %155
  %159 = fsub double %158, %152
  %160 = fsub double %159, %158
  %161 = fadd double %152, %160
  %162 = fsub double %155, %159
  %163 = fadd double %162, %161
  %164 = fadd double %154, %157
  %165 = fsub double %164, %154
  %166 = fsub double %165, %164
  %167 = fadd double %154, %166
  %168 = fsub double %157, %165
  %169 = fadd double %168, %167
  %170 = fadd double %164, %163
  %171 = fadd double %158, %170
  %172 = fsub double %158, %171
  %173 = fadd double %170, %172
  %174 = fadd double %169, %173
  %175 = fadd double %171, %174
  %176 = fsub double %171, %175
  %177 = fadd double %174, %176
  %178 = insertelement <2 x double> poison, double %177, i64 0
  %179 = insertelement <2 x double> %178, double %175, i64 1
  %180 = shl nsw i32 %148, 1
  %181 = add nsw i32 %180, 2
  br label %182

182:                                              ; preds = %18, %143
  %183 = phi i32 [ %181, %143 ], [ 0, %18 ]
  %184 = phi <2 x double> [ %0, %143 ], [ %142, %18 ]
  %185 = phi <2 x double> [ %179, %143 ], [ %138, %18 ]
  %186 = call spir_func double @__ocmlpriv_lnep_f64(<2 x double> noundef %185, i32 noundef %183) #38
  %187 = fmul double %186, 5.000000e-01
  br label %208

188:                                              ; preds = %14
  %189 = fneg double %4
  %190 = tail call double @llvm.fma.f64(double %189, double %4, double 1.000000e+00)
  %191 = fptrunc double %190 to float
  %192 = tail call spir_func float @_Z12native_rsqrtf(float noundef %191) #38
  %193 = fpext float %192 to double
  %194 = fmul double %190, %193
  %195 = fmul double %193, 5.000000e-01
  %196 = fneg double %195
  %197 = tail call double @llvm.fma.f64(double %196, double %194, double 5.000000e-01)
  %198 = tail call double @llvm.fma.f64(double %195, double %197, double %195)
  %199 = tail call double @llvm.fma.f64(double %194, double %197, double %194)
  %200 = fneg double %199
  %201 = tail call double @llvm.fma.f64(double %200, double %199, double %190)
  %202 = tail call double @llvm.fma.f64(double %201, double %198, double %199)
  %203 = fcmp oeq double %190, 0.000000e+00
  %204 = select i1 %203, double %190, double %202
  %205 = fdiv double %6, %204
  %206 = tail call double @llvm.copysign.f64(double %204, double %5)
  %207 = insertelement <2 x double> %0, double %206, i64 1
  br label %208

208:                                              ; preds = %188, %182
  %209 = phi <2 x double> [ %184, %182 ], [ %207, %188 ]
  %210 = phi double [ %187, %182 ], [ %205, %188 ]
  %211 = extractelement <2 x double> %209, i64 1
  %212 = extractelement <2 x double> %209, i64 0
  %213 = call spir_func double @__ocml_atan2_f64(double noundef %211, double noundef %212) #38
  %214 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %215 = icmp eq i8 %214, 0
  %216 = fcmp oeq double %4, 0x7FF0000000000000
  %217 = fcmp oeq double %6, 0x7FF0000000000000
  %218 = or i1 %216, %217
  %219 = and i1 %218, %215
  %220 = select i1 %219, double 0x7FF0000000000000, double %210
  %221 = insertelement <2 x double> poison, double %220, i64 0
  %222 = insertelement <2 x double> %221, double %213, i64 1
  ret <2 x double> %222
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <4 x double> @__ocmlpriv_epcsqrtep_f64(<4 x double> noundef %0) local_unnamed_addr #21 {
  %2 = shufflevector <4 x double> %0, <4 x double> poison, <2 x i32> <i32 0, i32 1>
  %3 = shufflevector <4 x double> %0, <4 x double> poison, <2 x i32> <i32 2, i32 3>
  %4 = extractelement <4 x double> %0, i64 1
  %5 = fmul double %4, %4
  %6 = fneg double %5
  %7 = tail call double @llvm.fma.f64(double %4, double %4, double %6)
  %8 = extractelement <4 x double> %0, i64 0
  %9 = fmul double %8, 2.000000e+00
  %10 = tail call double @llvm.fma.f64(double %4, double %9, double %7)
  %11 = fadd double %5, %10
  %12 = fsub double %11, %5
  %13 = fsub double %10, %12
  %14 = extractelement <4 x double> %0, i64 3
  %15 = fmul double %14, %14
  %16 = fneg double %15
  %17 = tail call double @llvm.fma.f64(double %14, double %14, double %16)
  %18 = extractelement <4 x double> %0, i64 2
  %19 = fmul double %18, 2.000000e+00
  %20 = tail call double @llvm.fma.f64(double %14, double %19, double %17)
  %21 = fadd double %15, %20
  %22 = fsub double %21, %15
  %23 = fsub double %20, %22
  %24 = fadd double %11, %21
  %25 = fsub double %24, %11
  %26 = fsub double %25, %24
  %27 = fadd double %11, %26
  %28 = fsub double %21, %25
  %29 = fadd double %28, %27
  %30 = fadd double %13, %23
  %31 = fsub double %30, %13
  %32 = fsub double %30, %31
  %33 = fsub double %13, %32
  %34 = fsub double %23, %31
  %35 = fadd double %34, %33
  %36 = fadd double %30, %29
  %37 = fadd double %24, %36
  %38 = fsub double %24, %37
  %39 = fadd double %36, %38
  %40 = fadd double %35, %39
  %41 = fadd double %37, %40
  %42 = fsub double %37, %41
  %43 = fadd double %40, %42
  %44 = fptrunc double %41 to float
  %45 = tail call spir_func float @_Z12native_rsqrtf(float noundef %44) #38
  %46 = fpext float %45 to double
  %47 = fmul double %41, %46
  %48 = fmul double %46, 5.000000e-01
  %49 = fneg double %48
  %50 = tail call double @llvm.fma.f64(double %49, double %47, double 5.000000e-01)
  %51 = tail call double @llvm.fma.f64(double %48, double %50, double %48)
  %52 = tail call double @llvm.fma.f64(double %47, double %50, double %47)
  %53 = fneg double %52
  %54 = tail call double @llvm.fma.f64(double %53, double %52, double %41)
  %55 = tail call double @llvm.fma.f64(double %54, double %51, double %52)
  %56 = fcmp oeq double %41, 0.000000e+00
  %57 = select i1 %56, double %41, double %55
  %58 = fmul double %57, %57
  %59 = fneg double %58
  %60 = tail call double @llvm.fma.f64(double %57, double %57, double %59)
  %61 = fsub double %41, %58
  %62 = fsub double %41, %61
  %63 = fsub double %62, %58
  %64 = fadd double %43, %63
  %65 = fsub double %64, %60
  %66 = fadd double %61, %65
  %67 = fmul double %57, 2.000000e+00
  %68 = fptrunc double %67 to float
  %69 = tail call spir_func float @_Z12native_recipf(float noundef %68) #38
  %70 = fpext float %69 to double
  %71 = fneg double %67
  %72 = tail call double @llvm.fma.f64(double %71, double %70, double 1.000000e+00)
  %73 = tail call double @llvm.fma.f64(double %72, double %70, double %70)
  %74 = tail call double @llvm.fma.f64(double %71, double %73, double 1.000000e+00)
  %75 = tail call double @llvm.fma.f64(double %74, double %73, double %73)
  %76 = fmul double %75, %66
  %77 = tail call double @llvm.fma.f64(double %71, double %76, double %66)
  %78 = tail call double @llvm.fma.f64(double %77, double %75, double %76)
  %79 = select i1 %56, double 0.000000e+00, double %78
  %80 = fadd double %57, %79
  %81 = fsub double %80, %57
  %82 = fsub double %79, %81
  %83 = bitcast double %4 to <2 x i32>
  %84 = extractelement <2 x i32> %83, i64 1
  %85 = icmp slt i32 %84, 0
  %86 = fneg <2 x double> %2
  %87 = select i1 %85, <2 x double> %86, <2 x double> %2
  %88 = extractelement <2 x double> %87, i64 1
  %89 = fadd double %88, %80
  %90 = fsub double %89, %80
  %91 = fsub double %88, %90
  %92 = extractelement <2 x double> %87, i64 0
  %93 = fadd double %92, %82
  %94 = fadd double %93, %91
  %95 = fadd double %89, %94
  %96 = fsub double %95, %89
  %97 = fsub double %94, %96
  %98 = insertelement <2 x double> poison, double %97, i64 0
  %99 = insertelement <2 x double> %98, double %95, i64 1
  %100 = fmul <2 x double> %99, <double 5.000000e-01, double 5.000000e-01>
  %101 = extractelement <2 x double> %100, i64 1
  %102 = fptrunc double %101 to float
  %103 = tail call spir_func float @_Z12native_rsqrtf(float noundef %102) #38
  %104 = fpext float %103 to double
  %105 = fmul double %101, %104
  %106 = fmul double %104, 5.000000e-01
  %107 = fneg double %106
  %108 = tail call double @llvm.fma.f64(double %107, double %105, double 5.000000e-01)
  %109 = tail call double @llvm.fma.f64(double %106, double %108, double %106)
  %110 = tail call double @llvm.fma.f64(double %105, double %108, double %105)
  %111 = fneg double %110
  %112 = tail call double @llvm.fma.f64(double %111, double %110, double %101)
  %113 = tail call double @llvm.fma.f64(double %112, double %109, double %110)
  %114 = fcmp oeq double %101, 0.000000e+00
  %115 = select i1 %114, double %101, double %113
  %116 = fmul double %115, %115
  %117 = fneg double %116
  %118 = tail call double @llvm.fma.f64(double %115, double %115, double %117)
  %119 = fsub double %101, %116
  %120 = fsub double %101, %119
  %121 = fsub double %120, %116
  %122 = extractelement <2 x double> %100, i64 0
  %123 = fadd double %122, %121
  %124 = fsub double %123, %118
  %125 = fadd double %119, %124
  %126 = fmul double %115, 2.000000e+00
  %127 = fptrunc double %126 to float
  %128 = tail call spir_func float @_Z12native_recipf(float noundef %127) #38
  %129 = fpext float %128 to double
  %130 = fneg double %126
  %131 = tail call double @llvm.fma.f64(double %130, double %129, double 1.000000e+00)
  %132 = tail call double @llvm.fma.f64(double %131, double %129, double %129)
  %133 = tail call double @llvm.fma.f64(double %130, double %132, double 1.000000e+00)
  %134 = tail call double @llvm.fma.f64(double %133, double %132, double %132)
  %135 = fmul double %134, %125
  %136 = tail call double @llvm.fma.f64(double %130, double %135, double %125)
  %137 = tail call double @llvm.fma.f64(double %136, double %134, double %135)
  %138 = select i1 %114, double 0.000000e+00, double %137
  %139 = fadd double %115, %138
  %140 = fsub double %139, %115
  %141 = fsub double %138, %140
  %142 = insertelement <2 x double> poison, double %141, i64 0
  %143 = insertelement <2 x double> %142, double %139, i64 1
  %144 = fptrunc double %139 to float
  %145 = tail call spir_func float @_Z12native_recipf(float noundef %144) #38
  %146 = fpext float %145 to double
  %147 = fneg double %139
  %148 = tail call double @llvm.fma.f64(double %147, double %146, double 1.000000e+00)
  %149 = tail call double @llvm.fma.f64(double %148, double %146, double %146)
  %150 = tail call double @llvm.fma.f64(double %147, double %149, double 1.000000e+00)
  %151 = tail call double @llvm.fma.f64(double %150, double %149, double %149)
  %152 = fmul double %14, %151
  %153 = fmul double %139, %152
  %154 = fneg double %153
  %155 = tail call double @llvm.fma.f64(double %152, double %139, double %154)
  %156 = tail call double @llvm.fma.f64(double %152, double %141, double %155)
  %157 = fadd double %153, %156
  %158 = fsub double %157, %153
  %159 = fsub double %156, %158
  %160 = fsub double %14, %157
  %161 = fsub double %14, %160
  %162 = fsub double %161, %157
  %163 = fsub double %162, %159
  %164 = fadd double %18, %163
  %165 = fadd double %160, %164
  %166 = fmul double %151, %165
  %167 = fadd double %152, %166
  %168 = fsub double %167, %152
  %169 = fsub double %166, %168
  %170 = insertelement <2 x double> poison, double %169, i64 0
  %171 = insertelement <2 x double> %170, double %167, i64 1
  %172 = fmul <2 x double> %171, <double 5.000000e-01, double 5.000000e-01>
  %173 = extractelement <2 x double> %172, i64 1
  %174 = bitcast double %173 to <2 x i32>
  %175 = extractelement <2 x i32> %174, i64 1
  %176 = icmp slt i32 %175, 0
  %177 = fneg <2 x double> %172
  %178 = select i1 %176, <2 x double> %177, <2 x double> %172
  %179 = fcmp oeq double %14, 0.000000e+00
  %180 = fcmp oeq double %139, 0.000000e+00
  %181 = and i1 %179, %180
  %182 = select i1 %181, <2 x double> %3, <2 x double> %178
  %183 = fcmp oge double %4, 0.000000e+00
  %184 = select i1 %183, <2 x double> %143, <2 x double> %182
  %185 = select i1 %183, <2 x double> %182, <2 x double> %143
  %186 = extractelement <2 x double> %185, i64 1
  %187 = bitcast double %186 to <2 x i32>
  %188 = bitcast double %14 to <2 x i32>
  %189 = xor <2 x i32> %187, %188
  %190 = extractelement <2 x i32> %189, i64 1
  %191 = fneg <2 x double> %185
  %192 = icmp slt i32 %190, 0
  %193 = select i1 %192, <2 x double> %191, <2 x double> %185
  %194 = shufflevector <2 x double> %184, <2 x double> %193, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %194
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_cacos_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = tail call spir_func <2 x float> @__ocml_cacosh_f32(<2 x float> noundef %0) #38
  %3 = bitcast <2 x float> %0 to <2 x i32>
  %4 = extractelement <2 x i32> %3, i64 1
  %5 = icmp slt i32 %4, 0
  %6 = extractelement <2 x float> %2, i64 1
  %7 = fneg float %6
  %8 = select i1 %5, float %7, float %6
  %9 = extractelement <2 x float> %2, i64 0
  %10 = fneg float %9
  %11 = select i1 %5, float %9, float %10
  %12 = insertelement <2 x float> poison, float %8, i64 0
  %13 = insertelement <2 x float> %12, float %11, i64 1
  ret <2 x float> %13
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_cacosh_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = alloca float, align 8
  %4 = extractelement <2 x float> %0, i64 0
  %5 = tail call float @llvm.fabs.f32(float %4)
  %6 = extractelement <2 x float> %0, i64 1
  %7 = tail call float @llvm.fabs.f32(float %6)
  %8 = fcmp olt float %5, 0x4180000000000000
  %9 = fcmp olt float %7, 0x4180000000000000
  %10 = and i1 %8, %9
  br i1 %10, label %11, label %307

11:                                               ; preds = %1
  %12 = fcmp oge float %5, 1.000000e+00
  %13 = fcmp oge float %7, 0x3E70000000000000
  %14 = or i1 %12, %13
  br i1 %14, label %19, label %15

15:                                               ; preds = %11
  %16 = fsub float 1.000000e+00, %5
  %17 = fmul float %16, 0x3F30000000000000
  %18 = fcmp ogt float %7, %17
  br i1 %18, label %19, label %273

19:                                               ; preds = %15, %11
  %20 = fadd float %7, %5
  %21 = fsub float %20, %7
  %22 = fsub float %21, %20
  %23 = fadd float %7, %22
  %24 = fsub float %5, %21
  %25 = fadd float %24, %23
  %26 = fsub float %7, %5
  %27 = fsub float %26, %7
  %28 = fsub float %27, %26
  %29 = fadd float %7, %28
  %30 = fadd float %5, %27
  %31 = fsub float %29, %30
  %32 = fmul float %20, %26
  %33 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %34 = freeze i32 %33
  %35 = icmp sgt i32 %34, 8999
  br i1 %35, label %36, label %41

36:                                               ; preds = %19
  %37 = fneg float %32
  %38 = tail call float @llvm.fma.f32(float %20, float %26, float %37)
  %39 = insertelement <2 x float> poison, float %38, i64 0
  %40 = insertelement <2 x float> %39, float %32, i64 1
  br label %63

41:                                               ; preds = %19
  switch i32 %34, label %42 [
    i32 8001, label %56
    i32 7001, label %56
  ]

42:                                               ; preds = %41
  %43 = bitcast float %20 to i32
  %44 = and i32 %43, -4096
  %45 = bitcast i32 %44 to float
  %46 = fsub float %20, %45
  %47 = bitcast float %26 to i32
  %48 = and i32 %47, -4096
  %49 = bitcast i32 %48 to float
  %50 = fsub float %26, %49
  %51 = fneg float %32
  %52 = tail call float @llvm.fmuladd.f32(float %45, float %49, float %51)
  %53 = tail call float @llvm.fmuladd.f32(float %45, float %50, float %52)
  %54 = tail call float @llvm.fmuladd.f32(float %46, float %49, float %53)
  %55 = tail call float @llvm.fmuladd.f32(float %46, float %50, float %54)
  br label %59

56:                                               ; preds = %41, %41
  %57 = fneg float %32
  %58 = tail call float @llvm.fma.f32(float %20, float %26, float %57)
  br label %59

59:                                               ; preds = %56, %42
  %60 = phi float [ %58, %56 ], [ %55, %42 ]
  %61 = insertelement <2 x float> poison, float %60, i64 0
  %62 = insertelement <2 x float> %61, float %32, i64 1
  switch i32 %34, label %69 [
    i32 8001, label %63
    i32 7001, label %63
  ]

63:                                               ; preds = %59, %59, %36
  %64 = phi <2 x float> [ %62, %59 ], [ %62, %59 ], [ %40, %36 ]
  %65 = phi float [ %60, %59 ], [ %60, %59 ], [ %38, %36 ]
  %66 = tail call float @llvm.fma.f32(float %20, float %31, float %65)
  %67 = tail call float @llvm.fma.f32(float %25, float %26, float %66)
  %68 = insertelement <2 x float> %64, float %67, i64 0
  br label %74

69:                                               ; preds = %59
  %70 = fmul float %26, %25
  %71 = tail call float @llvm.fmuladd.f32(float %20, float %31, float %70)
  %72 = fadd float %71, %60
  %73 = insertelement <2 x float> %62, float %72, i64 0
  br label %74

74:                                               ; preds = %63, %69
  %75 = phi <2 x float> [ %68, %63 ], [ %73, %69 ]
  %76 = extractelement <2 x float> %75, i64 1
  %77 = extractelement <2 x float> %75, i64 0
  %78 = fadd float %76, %77
  %79 = fsub float %78, %76
  %80 = fsub float %77, %79
  %81 = fadd float %78, 1.000000e+00
  %82 = fsub float %81, %78
  %83 = fsub float %81, %82
  %84 = fsub float %78, %83
  %85 = fsub float 1.000000e+00, %82
  %86 = fadd float %85, %84
  %87 = fadd float %80, %86
  %88 = fadd float %81, %87
  %89 = fsub float %81, %88
  %90 = fadd float %87, %89
  %91 = insertelement <2 x float> poison, float %90, i64 0
  %92 = insertelement <2 x float> %91, float %88, i64 1
  %93 = fmul float %7, %5
  br i1 %35, label %95, label %94

94:                                               ; preds = %74
  switch i32 %34, label %98 [
    i32 8001, label %95
    i32 7001, label %95
  ]

95:                                               ; preds = %94, %94, %74
  %96 = fneg float %93
  %97 = tail call float @llvm.fma.f32(float %7, float %5, float %96)
  br label %112

98:                                               ; preds = %94
  %99 = bitcast float %7 to i32
  %100 = and i32 %99, -4096
  %101 = bitcast i32 %100 to float
  %102 = fsub float %7, %101
  %103 = bitcast float %5 to i32
  %104 = and i32 %103, -4096
  %105 = bitcast i32 %104 to float
  %106 = fsub float %5, %105
  %107 = fneg float %93
  %108 = tail call float @llvm.fmuladd.f32(float %101, float %105, float %107)
  %109 = tail call float @llvm.fmuladd.f32(float %101, float %106, float %108)
  %110 = tail call float @llvm.fmuladd.f32(float %102, float %105, float %109)
  %111 = tail call float @llvm.fmuladd.f32(float %102, float %106, float %110)
  br label %112

112:                                              ; preds = %95, %98
  %113 = phi float [ %111, %98 ], [ %97, %95 ]
  %114 = insertelement <2 x float> poison, float %113, i64 0
  %115 = insertelement <2 x float> %114, float %93, i64 1
  %116 = fmul <2 x float> %115, <float 2.000000e+00, float 2.000000e+00>
  %117 = shufflevector <2 x float> %92, <2 x float> %116, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %118 = tail call spir_func <4 x float> @__ocmlpriv_epcsqrtep_f32(<4 x float> noundef %117) #38
  %119 = shufflevector <4 x float> %118, <4 x float> poison, <2 x i32> <i32 2, i32 3>
  %120 = bitcast <2 x float> %119 to <2 x i32>
  %121 = bitcast <2 x float> %0 to <2 x i32>
  %122 = shufflevector <2 x i32> %120, <2 x i32> poison, <2 x i32> <i32 1, i32 poison>
  %123 = xor <2 x i32> %122, %121
  %124 = extractelement <2 x i32> %123, i64 0
  %125 = fneg <2 x float> %119
  %126 = icmp slt i32 %124, 0
  %127 = select i1 %126, <2 x float> %125, <2 x float> %119
  %128 = shufflevector <4 x float> %118, <4 x float> poison, <2 x i32> <i32 0, i32 1>
  %129 = bitcast <2 x float> %128 to <2 x i32>
  %130 = xor <2 x i32> %129, %121
  %131 = extractelement <2 x i32> %130, i64 1
  %132 = fneg <2 x float> %128
  %133 = icmp slt i32 %131, 0
  %134 = select i1 %133, <2 x float> %132, <2 x float> %128
  %135 = extractelement <2 x float> %127, i64 1
  %136 = fadd float %4, %135
  %137 = fsub float %136, %135
  %138 = fsub float %136, %137
  %139 = fsub float %135, %138
  %140 = fsub float %4, %137
  %141 = fadd float %140, %139
  %142 = extractelement <2 x float> %127, i64 0
  %143 = fadd float %142, %141
  %144 = fadd float %136, %143
  %145 = fsub float %144, %136
  %146 = fsub float %143, %145
  %147 = extractelement <2 x float> %134, i64 1
  %148 = fadd float %6, %147
  %149 = fsub float %148, %147
  %150 = fsub float %148, %149
  %151 = fsub float %147, %150
  %152 = fsub float %6, %149
  %153 = fadd float %152, %151
  %154 = extractelement <2 x float> %134, i64 0
  %155 = fadd float %154, %153
  %156 = fadd float %148, %155
  %157 = fsub float %156, %148
  %158 = fsub float %155, %157
  %159 = fmul float %144, %144
  br i1 %35, label %160, label %165

160:                                              ; preds = %112
  %161 = fneg float %159
  %162 = tail call float @llvm.fma.f32(float %144, float %144, float %161)
  %163 = insertelement <2 x float> poison, float %162, i64 0
  %164 = insertelement <2 x float> %163, float %159, i64 1
  br label %190

165:                                              ; preds = %112
  switch i32 %34, label %166 [
    i32 8001, label %176
    i32 7001, label %176
  ]

166:                                              ; preds = %165
  %167 = bitcast float %144 to i32
  %168 = and i32 %167, -4096
  %169 = bitcast i32 %168 to float
  %170 = fsub float %144, %169
  %171 = fneg float %159
  %172 = tail call float @llvm.fmuladd.f32(float %169, float %169, float %171)
  %173 = fmul float %169, 2.000000e+00
  %174 = tail call float @llvm.fmuladd.f32(float %173, float %170, float %172)
  %175 = tail call float @llvm.fmuladd.f32(float %170, float %170, float %174)
  br label %179

176:                                              ; preds = %165, %165
  %177 = fneg float %159
  %178 = tail call float @llvm.fma.f32(float %144, float %144, float %177)
  br label %179

179:                                              ; preds = %176, %166
  %180 = phi float [ %178, %176 ], [ %175, %166 ]
  %181 = insertelement <2 x float> poison, float %180, i64 0
  %182 = insertelement <2 x float> %181, float %159, i64 1
  switch i32 %34, label %183 [
    i32 8001, label %190
    i32 7001, label %190
  ]

183:                                              ; preds = %179
  %184 = fmul float %146, 2.000000e+00
  %185 = tail call float @llvm.fmuladd.f32(float %184, float %144, float %180)
  %186 = fadd float %159, %185
  %187 = fsub float %186, %159
  %188 = fsub float %185, %187
  %189 = fmul float %156, %156
  br label %205

190:                                              ; preds = %160, %179, %179
  %191 = phi <2 x float> [ %182, %179 ], [ %182, %179 ], [ %164, %160 ]
  %192 = phi float [ %180, %179 ], [ %180, %179 ], [ %162, %160 ]
  %193 = fmul float %146, 2.000000e+00
  %194 = tail call float @llvm.fma.f32(float %144, float %193, float %192)
  %195 = extractelement <2 x float> %191, i64 1
  %196 = fadd float %195, %194
  %197 = fsub float %196, %195
  %198 = fsub float %194, %197
  %199 = fmul float %156, %156
  br i1 %35, label %200, label %205

200:                                              ; preds = %190
  %201 = fneg float %199
  %202 = tail call float @llvm.fma.f32(float %156, float %156, float %201)
  %203 = insertelement <2 x float> poison, float %202, i64 0
  %204 = insertelement <2 x float> %203, float %199, i64 1
  br label %226

205:                                              ; preds = %183, %190
  %206 = phi float [ %189, %183 ], [ %199, %190 ]
  %207 = phi float [ %188, %183 ], [ %198, %190 ]
  %208 = phi float [ %186, %183 ], [ %196, %190 ]
  switch i32 %34, label %209 [
    i32 8001, label %219
    i32 7001, label %219
  ]

209:                                              ; preds = %205
  %210 = bitcast float %156 to i32
  %211 = and i32 %210, -4096
  %212 = bitcast i32 %211 to float
  %213 = fsub float %156, %212
  %214 = fneg float %206
  %215 = tail call float @llvm.fmuladd.f32(float %212, float %212, float %214)
  %216 = fmul float %212, 2.000000e+00
  %217 = tail call float @llvm.fmuladd.f32(float %216, float %213, float %215)
  %218 = tail call float @llvm.fmuladd.f32(float %213, float %213, float %217)
  br label %222

219:                                              ; preds = %205, %205
  %220 = fneg float %206
  %221 = tail call float @llvm.fma.f32(float %156, float %156, float %220)
  br label %222

222:                                              ; preds = %219, %209
  %223 = phi float [ %221, %219 ], [ %218, %209 ]
  %224 = insertelement <2 x float> poison, float %223, i64 0
  %225 = insertelement <2 x float> %224, float %206, i64 1
  switch i32 %34, label %234 [
    i32 8001, label %226
    i32 7001, label %226
  ]

226:                                              ; preds = %222, %222, %200
  %227 = phi float [ %207, %222 ], [ %207, %222 ], [ %198, %200 ]
  %228 = phi float [ %208, %222 ], [ %208, %222 ], [ %196, %200 ]
  %229 = phi <2 x float> [ %225, %222 ], [ %225, %222 ], [ %204, %200 ]
  %230 = phi float [ %223, %222 ], [ %223, %222 ], [ %202, %200 ]
  %231 = fmul float %158, 2.000000e+00
  %232 = tail call float @llvm.fma.f32(float %156, float %231, float %230)
  %233 = insertelement <2 x float> %229, float %232, i64 0
  br label %238

234:                                              ; preds = %222
  %235 = fmul float %158, 2.000000e+00
  %236 = tail call float @llvm.fmuladd.f32(float %235, float %156, float %223)
  %237 = insertelement <2 x float> %225, float %236, i64 0
  br label %238

238:                                              ; preds = %226, %234
  %239 = phi float [ %227, %226 ], [ %207, %234 ]
  %240 = phi float [ %228, %226 ], [ %208, %234 ]
  %241 = phi <2 x float> [ %233, %226 ], [ %237, %234 ]
  %242 = extractelement <2 x float> %241, i64 1
  %243 = extractelement <2 x float> %241, i64 0
  %244 = fadd float %242, %243
  %245 = fsub float %244, %242
  %246 = fsub float %243, %245
  %247 = fadd float %240, %244
  %248 = fsub float %247, %240
  %249 = fsub float %247, %248
  %250 = fsub float %240, %249
  %251 = fsub float %244, %248
  %252 = fadd float %251, %250
  %253 = fadd float %239, %246
  %254 = fsub float %253, %239
  %255 = fsub float %253, %254
  %256 = fsub float %239, %255
  %257 = fsub float %246, %254
  %258 = fadd float %257, %256
  %259 = fadd float %253, %252
  %260 = fadd float %247, %259
  %261 = fsub float %260, %247
  %262 = fsub float %259, %261
  %263 = fadd float %258, %262
  %264 = fadd float %260, %263
  %265 = fsub float %264, %260
  %266 = fsub float %263, %265
  %267 = insertelement <2 x float> poison, float %266, i64 0
  %268 = insertelement <2 x float> %267, float %264, i64 1
  %269 = insertelement <2 x float> poison, float %144, i64 0
  %270 = fcmp oeq float %6, 0.000000e+00
  %271 = select i1 %270, float %6, float %156
  %272 = insertelement <2 x float> %269, float %271, i64 1
  br label %386

273:                                              ; preds = %15
  %274 = fneg float %5
  %275 = tail call float @llvm.fma.f32(float %274, float %5, float 1.000000e+00)
  %276 = fcmp olt float %275, 0x39F0000000000000
  %277 = select i1 %276, float 0x41F0000000000000, float 1.000000e+00
  %278 = fmul float %275, %277
  %279 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %280 = icmp eq i8 %279, 0
  br i1 %280, label %281, label %296

281:                                              ; preds = %273
  %282 = tail call float @llvm.sqrt.f32(float %278), !fpmath !18
  %283 = bitcast float %282 to i32
  %284 = add nsw i32 %283, -1
  %285 = bitcast i32 %284 to float
  %286 = add nsw i32 %283, 1
  %287 = bitcast i32 %286 to float
  %288 = fneg float %285
  %289 = tail call float @llvm.fma.f32(float %288, float %282, float %278)
  %290 = fneg float %287
  %291 = tail call float @llvm.fma.f32(float %290, float %282, float %278)
  %292 = fcmp ole float %289, 0.000000e+00
  %293 = select i1 %292, float %285, float %282
  %294 = fcmp ogt float %291, 0.000000e+00
  %295 = select i1 %294, float %287, float %293
  br label %392

296:                                              ; preds = %273
  %297 = tail call spir_func float @_Z12native_rsqrtf(float noundef %278) #38
  %298 = fmul float %278, %297
  %299 = fmul float %297, 5.000000e-01
  %300 = fneg float %299
  %301 = tail call float @llvm.fma.f32(float %300, float %298, float 5.000000e-01)
  %302 = tail call float @llvm.fma.f32(float %299, float %301, float %299)
  %303 = tail call float @llvm.fma.f32(float %298, float %301, float %298)
  %304 = fneg float %303
  %305 = tail call float @llvm.fma.f32(float %304, float %303, float %278)
  %306 = tail call float @llvm.fma.f32(float %305, float %302, float %303)
  br label %392

307:                                              ; preds = %1
  %308 = bitcast float %5 to i32
  %309 = bitcast float %7 to i32
  %310 = tail call i32 @llvm.umax.i32(i32 %308, i32 %309)
  %311 = bitcast i32 %310 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %312 = addrspacecast ptr %2 to ptr addrspace(4)
  %313 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %311, ptr addrspace(4) noundef %312) #40
  %314 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %315 = sub nsw i32 0, %314
  %316 = call spir_func float @_Z5ldexpfi(float noundef %5, i32 noundef %315) #38
  %317 = call spir_func float @_Z5ldexpfi(float noundef %7, i32 noundef %315) #38
  %318 = fmul float %316, %316
  %319 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %320 = freeze i32 %319
  %321 = icmp sgt i32 %320, 8999
  br i1 %321, label %322, label %326

322:                                              ; preds = %307
  %323 = fneg float %318
  %324 = call float @llvm.fma.f32(float %316, float %316, float %323)
  %325 = fmul float %317, %317
  br label %343

326:                                              ; preds = %307
  switch i32 %320, label %327 [
    i32 8001, label %337
    i32 7001, label %337
  ]

327:                                              ; preds = %326
  %328 = bitcast float %316 to i32
  %329 = and i32 %328, -4096
  %330 = bitcast i32 %329 to float
  %331 = fsub float %316, %330
  %332 = fneg float %318
  %333 = call float @llvm.fmuladd.f32(float %330, float %330, float %332)
  %334 = fmul float %330, 2.000000e+00
  %335 = call float @llvm.fmuladd.f32(float %334, float %331, float %333)
  %336 = call float @llvm.fmuladd.f32(float %331, float %331, float %335)
  br label %340

337:                                              ; preds = %326, %326
  %338 = fneg float %318
  %339 = call float @llvm.fma.f32(float %316, float %316, float %338)
  br label %340

340:                                              ; preds = %337, %327
  %341 = phi float [ %336, %327 ], [ %339, %337 ]
  %342 = fmul float %317, %317
  switch i32 %320, label %348 [
    i32 8001, label %343
    i32 7001, label %343
  ]

343:                                              ; preds = %322, %340, %340
  %344 = phi float [ %342, %340 ], [ %342, %340 ], [ %325, %322 ]
  %345 = phi float [ %341, %340 ], [ %341, %340 ], [ %324, %322 ]
  %346 = fneg float %344
  %347 = call float @llvm.fma.f32(float %317, float %317, float %346)
  br label %358

348:                                              ; preds = %340
  %349 = bitcast float %317 to i32
  %350 = and i32 %349, -4096
  %351 = bitcast i32 %350 to float
  %352 = fsub float %317, %351
  %353 = fneg float %342
  %354 = call float @llvm.fmuladd.f32(float %351, float %351, float %353)
  %355 = fmul float %351, 2.000000e+00
  %356 = call float @llvm.fmuladd.f32(float %355, float %352, float %354)
  %357 = call float @llvm.fmuladd.f32(float %352, float %352, float %356)
  br label %358

358:                                              ; preds = %343, %348
  %359 = phi float [ %342, %348 ], [ %344, %343 ]
  %360 = phi float [ %341, %348 ], [ %345, %343 ]
  %361 = phi float [ %357, %348 ], [ %347, %343 ]
  %362 = fadd float %318, %359
  %363 = fsub float %362, %318
  %364 = fsub float %363, %362
  %365 = fadd float %318, %364
  %366 = fsub float %359, %363
  %367 = fadd float %366, %365
  %368 = fadd float %360, %361
  %369 = fsub float %368, %360
  %370 = fsub float %368, %369
  %371 = fsub float %360, %370
  %372 = fsub float %361, %369
  %373 = fadd float %372, %371
  %374 = fadd float %368, %367
  %375 = fadd float %362, %374
  %376 = fsub float %362, %375
  %377 = fadd float %374, %376
  %378 = fadd float %373, %377
  %379 = fadd float %375, %378
  %380 = fsub float %375, %379
  %381 = fadd float %378, %380
  %382 = insertelement <2 x float> poison, float %381, i64 0
  %383 = insertelement <2 x float> %382, float %379, i64 1
  %384 = shl nsw i32 %314, 1
  %385 = add nsw i32 %384, 2
  br label %386

386:                                              ; preds = %238, %358
  %387 = phi i32 [ %385, %358 ], [ 0, %238 ]
  %388 = phi <2 x float> [ %0, %358 ], [ %272, %238 ]
  %389 = phi <2 x float> [ %383, %358 ], [ %268, %238 ]
  %390 = call spir_func float @__ocmlpriv_lnep_f32(<2 x float> noundef %389, i32 noundef %387) #38
  %391 = fmul float %390, 5.000000e-01
  br label %406

392:                                              ; preds = %296, %281
  %393 = phi float [ %306, %296 ], [ %295, %281 ]
  %394 = select i1 %276, float 0x3EF0000000000000, float 1.000000e+00
  %395 = fmul float %394, %393
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %278, ptr %3, align 8, !tbaa !16
  %396 = addrspacecast ptr %3 to ptr addrspace(4)
  %397 = load i64, ptr addrspace(4) %396, align 8, !tbaa !12
  %398 = icmp ne i64 %397, 2139095040
  %399 = and i64 %397, 2147483647
  %400 = icmp ne i64 %399, 0
  %401 = and i1 %398, %400
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %402 = select i1 %401, float %395, float %278
  %403 = fdiv float %7, %402, !fpmath !15
  %404 = tail call float @llvm.copysign.f32(float %402, float %6)
  %405 = insertelement <2 x float> %0, float %404, i64 1
  br label %406

406:                                              ; preds = %392, %386
  %407 = phi <2 x float> [ %388, %386 ], [ %405, %392 ]
  %408 = phi float [ %391, %386 ], [ %403, %392 ]
  %409 = extractelement <2 x float> %407, i64 1
  %410 = extractelement <2 x float> %407, i64 0
  %411 = call spir_func float @__ocml_atan2_f32(float noundef %409, float noundef %410) #38
  %412 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %413 = icmp eq i8 %412, 0
  %414 = fcmp oeq float %5, 0x7FF0000000000000
  %415 = fcmp oeq float %7, 0x7FF0000000000000
  %416 = or i1 %414, %415
  %417 = and i1 %416, %413
  %418 = select i1 %417, float 0x7FF0000000000000, float %408
  %419 = insertelement <2 x float> poison, float %418, i64 0
  %420 = insertelement <2 x float> %419, float %411, i64 1
  ret <2 x float> %420
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <4 x float> @__ocmlpriv_epcsqrtep_f32(<4 x float> noundef %0) local_unnamed_addr #21 {
  %2 = shufflevector <4 x float> %0, <4 x float> poison, <2 x i32> <i32 0, i32 1>
  %3 = extractelement <4 x float> %0, i64 1
  %4 = fmul float %3, %3
  %5 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %6 = freeze i32 %5
  %7 = icmp sgt i32 %6, 8999
  br i1 %7, label %8, label %13

8:                                                ; preds = %1
  %9 = fneg float %4
  %10 = tail call float @llvm.fma.f32(float %3, float %3, float %9)
  %11 = insertelement <2 x float> poison, float %10, i64 0
  %12 = insertelement <2 x float> %11, float %4, i64 1
  br label %31

13:                                               ; preds = %1
  switch i32 %6, label %14 [
    i32 8001, label %24
    i32 7001, label %24
  ]

14:                                               ; preds = %13
  %15 = bitcast float %3 to i32
  %16 = and i32 %15, -4096
  %17 = bitcast i32 %16 to float
  %18 = fsub float %3, %17
  %19 = fneg float %4
  %20 = tail call float @llvm.fmuladd.f32(float %17, float %17, float %19)
  %21 = fmul float %17, 2.000000e+00
  %22 = tail call float @llvm.fmuladd.f32(float %21, float %18, float %20)
  %23 = tail call float @llvm.fmuladd.f32(float %18, float %18, float %22)
  br label %27

24:                                               ; preds = %13, %13
  %25 = fneg float %4
  %26 = tail call float @llvm.fma.f32(float %3, float %3, float %25)
  br label %27

27:                                               ; preds = %24, %14
  %28 = phi float [ %26, %24 ], [ %23, %14 ]
  %29 = insertelement <2 x float> poison, float %28, i64 0
  %30 = insertelement <2 x float> %29, float %4, i64 1
  switch i32 %6, label %38 [
    i32 8001, label %31
    i32 7001, label %31
  ]

31:                                               ; preds = %27, %27, %8
  %32 = phi <2 x float> [ %30, %27 ], [ %30, %27 ], [ %12, %8 ]
  %33 = phi float [ %28, %27 ], [ %28, %27 ], [ %10, %8 ]
  %34 = extractelement <4 x float> %0, i64 0
  %35 = fmul float %34, 2.000000e+00
  %36 = tail call float @llvm.fma.f32(float %3, float %35, float %33)
  %37 = insertelement <2 x float> %32, float %36, i64 0
  br label %43

38:                                               ; preds = %27
  %39 = extractelement <4 x float> %0, i64 0
  %40 = fmul float %39, 2.000000e+00
  %41 = tail call float @llvm.fmuladd.f32(float %40, float %3, float %28)
  %42 = insertelement <2 x float> %30, float %41, i64 0
  br label %43

43:                                               ; preds = %31, %38
  %44 = phi <2 x float> [ %37, %31 ], [ %42, %38 ]
  %45 = extractelement <2 x float> %44, i64 1
  %46 = extractelement <2 x float> %44, i64 0
  %47 = fadd float %45, %46
  %48 = fsub float %47, %45
  %49 = fsub float %46, %48
  %50 = extractelement <4 x float> %0, i64 3
  %51 = fmul float %50, %50
  br i1 %7, label %52, label %57

52:                                               ; preds = %43
  %53 = fneg float %51
  %54 = tail call float @llvm.fma.f32(float %50, float %50, float %53)
  %55 = insertelement <2 x float> poison, float %54, i64 0
  %56 = insertelement <2 x float> %55, float %51, i64 1
  br label %75

57:                                               ; preds = %43
  switch i32 %6, label %58 [
    i32 8001, label %68
    i32 7001, label %68
  ]

58:                                               ; preds = %57
  %59 = bitcast float %50 to i32
  %60 = and i32 %59, -4096
  %61 = bitcast i32 %60 to float
  %62 = fsub float %50, %61
  %63 = fneg float %51
  %64 = tail call float @llvm.fmuladd.f32(float %61, float %61, float %63)
  %65 = fmul float %61, 2.000000e+00
  %66 = tail call float @llvm.fmuladd.f32(float %65, float %62, float %64)
  %67 = tail call float @llvm.fmuladd.f32(float %62, float %62, float %66)
  br label %71

68:                                               ; preds = %57, %57
  %69 = fneg float %51
  %70 = tail call float @llvm.fma.f32(float %50, float %50, float %69)
  br label %71

71:                                               ; preds = %68, %58
  %72 = phi float [ %70, %68 ], [ %67, %58 ]
  %73 = insertelement <2 x float> poison, float %72, i64 0
  %74 = insertelement <2 x float> %73, float %51, i64 1
  switch i32 %6, label %82 [
    i32 8001, label %75
    i32 7001, label %75
  ]

75:                                               ; preds = %71, %71, %52
  %76 = phi <2 x float> [ %74, %71 ], [ %74, %71 ], [ %56, %52 ]
  %77 = phi float [ %72, %71 ], [ %72, %71 ], [ %54, %52 ]
  %78 = extractelement <4 x float> %0, i64 2
  %79 = fmul float %78, 2.000000e+00
  %80 = tail call float @llvm.fma.f32(float %50, float %79, float %77)
  %81 = insertelement <2 x float> %76, float %80, i64 0
  br label %87

82:                                               ; preds = %71
  %83 = extractelement <4 x float> %0, i64 2
  %84 = fmul float %83, 2.000000e+00
  %85 = tail call float @llvm.fmuladd.f32(float %84, float %50, float %72)
  %86 = insertelement <2 x float> %74, float %85, i64 0
  br label %87

87:                                               ; preds = %75, %82
  %88 = phi <2 x float> [ %81, %75 ], [ %86, %82 ]
  %89 = extractelement <2 x float> %88, i64 1
  %90 = extractelement <2 x float> %88, i64 0
  %91 = fadd float %89, %90
  %92 = fsub float %91, %89
  %93 = fsub float %90, %92
  %94 = fadd float %47, %91
  %95 = fsub float %94, %47
  %96 = fsub float %94, %95
  %97 = fsub float %47, %96
  %98 = fsub float %91, %95
  %99 = fadd float %98, %97
  %100 = fadd float %49, %93
  %101 = fsub float %100, %49
  %102 = fsub float %100, %101
  %103 = fsub float %49, %102
  %104 = fsub float %93, %101
  %105 = fadd float %104, %103
  %106 = fadd float %100, %99
  %107 = fadd float %94, %106
  %108 = fsub float %107, %94
  %109 = fsub float %106, %108
  %110 = fadd float %105, %109
  %111 = fadd float %107, %110
  %112 = fsub float %111, %107
  %113 = fsub float %110, %112
  %114 = tail call float @llvm.sqrt.f32(float %111), !fpmath !18
  %115 = fmul float %114, %114
  br i1 %7, label %117, label %116

116:                                              ; preds = %87
  switch i32 %6, label %120 [
    i32 8001, label %117
    i32 7001, label %117
  ]

117:                                              ; preds = %116, %116, %87
  %118 = fneg float %115
  %119 = tail call float @llvm.fma.f32(float %114, float %114, float %118)
  br label %130

120:                                              ; preds = %116
  %121 = bitcast float %114 to i32
  %122 = and i32 %121, -4096
  %123 = bitcast i32 %122 to float
  %124 = fsub float %114, %123
  %125 = fneg float %115
  %126 = tail call float @llvm.fmuladd.f32(float %123, float %123, float %125)
  %127 = fmul float %123, 2.000000e+00
  %128 = tail call float @llvm.fmuladd.f32(float %127, float %124, float %126)
  %129 = tail call float @llvm.fmuladd.f32(float %124, float %124, float %128)
  br label %130

130:                                              ; preds = %117, %120
  %131 = phi float [ %129, %120 ], [ %119, %117 ]
  %132 = fsub float %111, %115
  %133 = fsub float %111, %132
  %134 = fsub float %133, %115
  %135 = fadd float %113, %134
  %136 = fsub float %135, %131
  %137 = fadd float %132, %136
  %138 = fmul float %114, 2.000000e+00
  %139 = tail call spir_func float @_Z12native_recipf(float noundef %138) #38
  %140 = fmul float %139, %137
  %141 = fcmp oeq float %111, 0.000000e+00
  %142 = select i1 %141, float 0.000000e+00, float %140
  %143 = fadd float %114, %142
  %144 = fsub float %143, %114
  %145 = fsub float %142, %144
  %146 = bitcast <2 x float> %2 to <2 x i32>
  %147 = extractelement <2 x i32> %146, i64 1
  %148 = icmp slt i32 %147, 0
  %149 = fneg <2 x float> %2
  %150 = select i1 %148, <2 x float> %149, <2 x float> %2
  %151 = extractelement <2 x float> %150, i64 1
  %152 = fadd float %151, %143
  %153 = fsub float %152, %143
  %154 = fsub float %151, %153
  %155 = extractelement <2 x float> %150, i64 0
  %156 = fadd float %155, %145
  %157 = fadd float %156, %154
  %158 = fadd float %152, %157
  %159 = fsub float %158, %152
  %160 = fsub float %157, %159
  %161 = insertelement <2 x float> poison, float %160, i64 0
  %162 = insertelement <2 x float> %161, float %158, i64 1
  %163 = fmul <2 x float> %162, <float 5.000000e-01, float 5.000000e-01>
  %164 = extractelement <2 x float> %163, i64 1
  %165 = tail call float @llvm.sqrt.f32(float %164), !fpmath !18
  %166 = fmul float %165, %165
  br i1 %7, label %168, label %167

167:                                              ; preds = %130
  switch i32 %6, label %171 [
    i32 8001, label %168
    i32 7001, label %168
  ]

168:                                              ; preds = %167, %167, %130
  %169 = fneg float %166
  %170 = tail call float @llvm.fma.f32(float %165, float %165, float %169)
  br label %181

171:                                              ; preds = %167
  %172 = bitcast float %165 to i32
  %173 = and i32 %172, -4096
  %174 = bitcast i32 %173 to float
  %175 = fsub float %165, %174
  %176 = fneg float %166
  %177 = tail call float @llvm.fmuladd.f32(float %174, float %174, float %176)
  %178 = fmul float %174, 2.000000e+00
  %179 = tail call float @llvm.fmuladd.f32(float %178, float %175, float %177)
  %180 = tail call float @llvm.fmuladd.f32(float %175, float %175, float %179)
  br label %181

181:                                              ; preds = %168, %171
  %182 = phi float [ %180, %171 ], [ %170, %168 ]
  %183 = fsub float %164, %166
  %184 = fsub float %164, %183
  %185 = fsub float %184, %166
  %186 = extractelement <2 x float> %163, i64 0
  %187 = fadd float %186, %185
  %188 = fsub float %187, %182
  %189 = fadd float %183, %188
  %190 = fmul float %165, 2.000000e+00
  %191 = tail call spir_func float @_Z12native_recipf(float noundef %190) #38
  %192 = fmul float %191, %189
  %193 = fcmp oeq float %164, 0.000000e+00
  %194 = select i1 %193, float 0.000000e+00, float %192
  %195 = fadd float %165, %194
  %196 = fsub float %195, %165
  %197 = fsub float %194, %196
  %198 = tail call spir_func float @_Z12native_recipf(float noundef %195) #38
  %199 = fmul float %50, %198
  %200 = fmul float %199, %195
  br i1 %7, label %201, label %206

201:                                              ; preds = %181
  %202 = fneg float %200
  %203 = tail call float @llvm.fma.f32(float %199, float %195, float %202)
  %204 = insertelement <2 x float> poison, float %203, i64 0
  %205 = insertelement <2 x float> %204, float %200, i64 1
  br label %228

206:                                              ; preds = %181
  switch i32 %6, label %207 [
    i32 8001, label %221
    i32 7001, label %221
  ]

207:                                              ; preds = %206
  %208 = bitcast float %199 to i32
  %209 = and i32 %208, -4096
  %210 = bitcast i32 %209 to float
  %211 = fsub float %199, %210
  %212 = bitcast float %195 to i32
  %213 = and i32 %212, -4096
  %214 = bitcast i32 %213 to float
  %215 = fsub float %195, %214
  %216 = fneg float %200
  %217 = tail call float @llvm.fmuladd.f32(float %210, float %214, float %216)
  %218 = tail call float @llvm.fmuladd.f32(float %210, float %215, float %217)
  %219 = tail call float @llvm.fmuladd.f32(float %211, float %214, float %218)
  %220 = tail call float @llvm.fmuladd.f32(float %211, float %215, float %219)
  br label %224

221:                                              ; preds = %206, %206
  %222 = fneg float %200
  %223 = tail call float @llvm.fma.f32(float %199, float %195, float %222)
  br label %224

224:                                              ; preds = %221, %207
  %225 = phi float [ %223, %221 ], [ %220, %207 ]
  %226 = insertelement <2 x float> poison, float %225, i64 0
  %227 = insertelement <2 x float> %226, float %200, i64 1
  switch i32 %6, label %233 [
    i32 8001, label %228
    i32 7001, label %228
  ]

228:                                              ; preds = %224, %224, %201
  %229 = phi <2 x float> [ %227, %224 ], [ %227, %224 ], [ %205, %201 ]
  %230 = phi float [ %225, %224 ], [ %225, %224 ], [ %203, %201 ]
  %231 = tail call float @llvm.fma.f32(float %199, float %197, float %230)
  %232 = insertelement <2 x float> %229, float %231, i64 0
  br label %236

233:                                              ; preds = %224
  %234 = tail call float @llvm.fmuladd.f32(float %199, float %197, float %225)
  %235 = insertelement <2 x float> %227, float %234, i64 0
  br label %236

236:                                              ; preds = %228, %233
  %237 = phi <2 x float> [ %232, %228 ], [ %235, %233 ]
  %238 = insertelement <2 x float> poison, float %197, i64 0
  %239 = insertelement <2 x float> %238, float %195, i64 1
  %240 = shufflevector <4 x float> %0, <4 x float> poison, <2 x i32> <i32 2, i32 3>
  %241 = extractelement <2 x float> %237, i64 1
  %242 = extractelement <2 x float> %237, i64 0
  %243 = fadd float %241, %242
  %244 = fsub float %243, %241
  %245 = fsub float %242, %244
  %246 = fsub float %50, %243
  %247 = fsub float %50, %246
  %248 = fsub float %247, %243
  %249 = fsub float %248, %245
  %250 = extractelement <4 x float> %0, i64 2
  %251 = fadd float %250, %249
  %252 = fadd float %246, %251
  %253 = fmul float %198, %252
  %254 = fadd float %199, %253
  %255 = fsub float %254, %199
  %256 = fsub float %253, %255
  %257 = insertelement <2 x float> poison, float %256, i64 0
  %258 = insertelement <2 x float> %257, float %254, i64 1
  %259 = fmul <2 x float> %258, <float 5.000000e-01, float 5.000000e-01>
  %260 = bitcast <2 x float> %259 to <2 x i32>
  %261 = extractelement <2 x i32> %260, i64 1
  %262 = icmp slt i32 %261, 0
  %263 = fneg <2 x float> %259
  %264 = select i1 %262, <2 x float> %263, <2 x float> %259
  %265 = fcmp oeq float %50, 0.000000e+00
  %266 = fcmp oeq float %195, 0.000000e+00
  %267 = and i1 %265, %266
  %268 = select i1 %267, <2 x float> %240, <2 x float> %264
  %269 = fcmp oge float %3, 0.000000e+00
  %270 = select i1 %269, <2 x float> %239, <2 x float> %268
  %271 = select i1 %269, <2 x float> %268, <2 x float> %239
  %272 = bitcast <2 x float> %271 to <2 x i32>
  %273 = bitcast <2 x float> %240 to <2 x i32>
  %274 = xor <2 x i32> %272, %273
  %275 = extractelement <2 x i32> %274, i64 1
  %276 = fneg <2 x float> %271
  %277 = icmp slt i32 %275, 0
  %278 = select i1 %277, <2 x float> %276, <2 x float> %271
  %279 = shufflevector <2 x float> %270, <2 x float> %278, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %279
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.umax.i32(i32, i32) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_casin_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x double> %0, i64 1
  %3 = fneg double %2
  %4 = insertelement <2 x double> poison, double %3, i64 0
  %5 = shufflevector <2 x double> %4, <2 x double> %0, <2 x i32> <i32 0, i32 2>
  %6 = tail call spir_func <2 x double> @__ocml_casinh_f64(<2 x double> noundef %5) #38
  %7 = extractelement <2 x double> %6, i64 1
  %8 = insertelement <2 x double> poison, double %7, i64 0
  %9 = extractelement <2 x double> %6, i64 0
  %10 = fneg double %9
  %11 = insertelement <2 x double> %8, double %10, i64 1
  ret <2 x double> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_casinh_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = extractelement <2 x double> %0, i64 0
  %4 = tail call double @llvm.fabs.f64(double %3)
  %5 = extractelement <2 x double> %0, i64 1
  %6 = tail call double @llvm.fabs.f64(double %5)
  %7 = fcmp olt double %4, 0x4350000000000000
  %8 = fcmp olt double %6, 0x4350000000000000
  %9 = and i1 %7, %8
  br i1 %9, label %10, label %123

10:                                               ; preds = %1
  %11 = fcmp oge double %6, 1.000000e+00
  %12 = fcmp oge double %4, 0x3CA0000000000000
  %13 = or i1 %11, %12
  br i1 %13, label %18, label %14

14:                                               ; preds = %10
  %15 = fsub double 1.000000e+00, %6
  %16 = fmul double %15, 0x3E50000000000000
  %17 = fcmp ogt double %4, %16
  br i1 %17, label %18, label %170

18:                                               ; preds = %14, %10
  %19 = fadd double %4, %6
  %20 = fsub double %19, %4
  %21 = fsub double %20, %19
  %22 = fadd double %4, %21
  %23 = fsub double %6, %20
  %24 = fadd double %23, %22
  %25 = fsub double %4, %6
  %26 = fsub double %25, %4
  %27 = fsub double %26, %25
  %28 = fadd double %4, %27
  %29 = fadd double %6, %26
  %30 = fsub double %28, %29
  %31 = fmul double %19, %25
  %32 = fneg double %31
  %33 = tail call double @llvm.fma.f64(double %19, double %25, double %32)
  %34 = tail call double @llvm.fma.f64(double %19, double %30, double %33)
  %35 = tail call double @llvm.fma.f64(double %24, double %25, double %34)
  %36 = fadd double %31, %35
  %37 = fsub double %36, %31
  %38 = fsub double %35, %37
  %39 = fadd double %36, 1.000000e+00
  %40 = fsub double %39, %36
  %41 = fsub double %39, %40
  %42 = fsub double %36, %41
  %43 = fsub double 1.000000e+00, %40
  %44 = fadd double %43, %42
  %45 = fadd double %38, %44
  %46 = fadd double %39, %45
  %47 = fsub double %39, %46
  %48 = fadd double %45, %47
  %49 = insertelement <2 x double> poison, double %48, i64 0
  %50 = insertelement <2 x double> %49, double %46, i64 1
  %51 = fmul double %6, %4
  %52 = fneg double %51
  %53 = tail call double @llvm.fma.f64(double %6, double %4, double %52)
  %54 = insertelement <2 x double> poison, double %53, i64 0
  %55 = insertelement <2 x double> %54, double %51, i64 1
  %56 = fmul <2 x double> %55, <double 2.000000e+00, double 2.000000e+00>
  %57 = shufflevector <2 x double> %50, <2 x double> %56, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %58 = tail call spir_func <4 x double> @__ocmlpriv_epcsqrtep_f64(<4 x double> noundef %57) #38
  %59 = extractelement <4 x double> %58, i64 1
  %60 = fadd double %4, %59
  %61 = fsub double %60, %59
  %62 = fsub double %60, %61
  %63 = fsub double %59, %62
  %64 = fsub double %4, %61
  %65 = fadd double %64, %63
  %66 = extractelement <4 x double> %58, i64 0
  %67 = fadd double %66, %65
  %68 = fadd double %60, %67
  %69 = fsub double %60, %68
  %70 = fadd double %67, %69
  %71 = extractelement <4 x double> %58, i64 3
  %72 = fadd double %6, %71
  %73 = fsub double %72, %71
  %74 = fsub double %72, %73
  %75 = fsub double %71, %74
  %76 = fsub double %6, %73
  %77 = fadd double %76, %75
  %78 = extractelement <4 x double> %58, i64 2
  %79 = fadd double %78, %77
  %80 = fadd double %72, %79
  %81 = fsub double %72, %80
  %82 = fadd double %79, %81
  %83 = fmul double %68, %68
  %84 = fneg double %83
  %85 = tail call double @llvm.fma.f64(double %68, double %68, double %84)
  %86 = fmul double %70, 2.000000e+00
  %87 = tail call double @llvm.fma.f64(double %68, double %86, double %85)
  %88 = fadd double %83, %87
  %89 = fsub double %88, %83
  %90 = fsub double %87, %89
  %91 = fmul double %80, %80
  %92 = fneg double %91
  %93 = tail call double @llvm.fma.f64(double %80, double %80, double %92)
  %94 = fmul double %82, 2.000000e+00
  %95 = tail call double @llvm.fma.f64(double %80, double %94, double %93)
  %96 = fadd double %91, %95
  %97 = fsub double %96, %91
  %98 = fsub double %95, %97
  %99 = fadd double %88, %96
  %100 = fsub double %99, %88
  %101 = fsub double %100, %99
  %102 = fadd double %88, %101
  %103 = fsub double %96, %100
  %104 = fadd double %103, %102
  %105 = fadd double %90, %98
  %106 = fsub double %105, %90
  %107 = fsub double %105, %106
  %108 = fsub double %90, %107
  %109 = fsub double %98, %106
  %110 = fadd double %109, %108
  %111 = fadd double %105, %104
  %112 = fadd double %99, %111
  %113 = fsub double %99, %112
  %114 = fadd double %111, %113
  %115 = fadd double %110, %114
  %116 = fadd double %112, %115
  %117 = fsub double %112, %116
  %118 = fadd double %115, %117
  %119 = insertelement <2 x double> poison, double %118, i64 0
  %120 = insertelement <2 x double> %119, double %116, i64 1
  %121 = insertelement <2 x double> poison, double %68, i64 0
  %122 = insertelement <2 x double> %121, double %80, i64 1
  br label %164

123:                                              ; preds = %1
  %124 = insertelement <2 x double> poison, double %4, i64 0
  %125 = insertelement <2 x double> %124, double %6, i64 1
  %126 = tail call double @llvm.maxnum.f64(double %4, double %6)
  %127 = fptrunc double %126 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %128 = addrspacecast ptr %2 to ptr addrspace(4)
  %129 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %127, ptr addrspace(4) noundef %128) #40
  %130 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %131 = sub nsw i32 0, %130
  %132 = call spir_func double @_Z5ldexpdi(double noundef %4, i32 noundef %131) #38
  %133 = call spir_func double @_Z5ldexpdi(double noundef %6, i32 noundef %131) #38
  %134 = fmul double %132, %132
  %135 = fneg double %134
  %136 = call double @llvm.fma.f64(double %132, double %132, double %135)
  %137 = fmul double %133, %133
  %138 = fneg double %137
  %139 = call double @llvm.fma.f64(double %133, double %133, double %138)
  %140 = fadd double %134, %137
  %141 = fsub double %140, %134
  %142 = fsub double %141, %140
  %143 = fadd double %134, %142
  %144 = fsub double %137, %141
  %145 = fadd double %144, %143
  %146 = fadd double %136, %139
  %147 = fsub double %146, %136
  %148 = fsub double %147, %146
  %149 = fadd double %136, %148
  %150 = fsub double %139, %147
  %151 = fadd double %150, %149
  %152 = fadd double %146, %145
  %153 = fadd double %140, %152
  %154 = fsub double %140, %153
  %155 = fadd double %152, %154
  %156 = fadd double %151, %155
  %157 = fadd double %153, %156
  %158 = fsub double %153, %157
  %159 = fadd double %156, %158
  %160 = insertelement <2 x double> poison, double %159, i64 0
  %161 = insertelement <2 x double> %160, double %157, i64 1
  %162 = shl nsw i32 %130, 1
  %163 = add nsw i32 %162, 2
  br label %164

164:                                              ; preds = %18, %123
  %165 = phi i32 [ %163, %123 ], [ 0, %18 ]
  %166 = phi <2 x double> [ %125, %123 ], [ %122, %18 ]
  %167 = phi <2 x double> [ %161, %123 ], [ %120, %18 ]
  %168 = call spir_func double @__ocmlpriv_lnep_f64(<2 x double> noundef %167, i32 noundef %165) #38
  %169 = fmul double %168, 5.000000e-01
  br label %198

170:                                              ; preds = %14
  %171 = fneg double %6
  %172 = tail call double @llvm.fma.f64(double %171, double %6, double 1.000000e+00)
  %173 = fcmp olt double %172, 0x1000000000000000
  %174 = select i1 %173, double 0x4FF0000000000000, double 1.000000e+00
  %175 = fmul double %172, %174
  %176 = fptrunc double %175 to float
  %177 = tail call spir_func float @_Z12native_rsqrtf(float noundef %176) #38
  %178 = fpext float %177 to double
  %179 = fmul double %175, %178
  %180 = fmul double %178, 5.000000e-01
  %181 = fneg double %180
  %182 = tail call double @llvm.fma.f64(double %181, double %179, double 5.000000e-01)
  %183 = tail call double @llvm.fma.f64(double %180, double %182, double %180)
  %184 = tail call double @llvm.fma.f64(double %179, double %182, double %179)
  %185 = fneg double %184
  %186 = tail call double @llvm.fma.f64(double %185, double %184, double %175)
  %187 = tail call double @llvm.fma.f64(double %186, double %183, double %184)
  %188 = fneg double %187
  %189 = tail call double @llvm.fma.f64(double %188, double %187, double %175)
  %190 = tail call double @llvm.fma.f64(double %189, double %183, double %187)
  %191 = select i1 %173, double 0x37F0000000000000, double 1.000000e+00
  %192 = fmul double %191, %190
  %193 = tail call i1 @llvm.is.fpclass.f64(double %175, i32 608)
  %194 = select i1 %193, double %175, double %192
  %195 = fdiv double %4, %194
  %196 = insertelement <2 x double> poison, double %194, i64 0
  %197 = insertelement <2 x double> %196, double %6, i64 1
  br label %198

198:                                              ; preds = %170, %164
  %199 = phi <2 x double> [ %166, %164 ], [ %197, %170 ]
  %200 = phi double [ %169, %164 ], [ %195, %170 ]
  %201 = call double @llvm.copysign.f64(double %200, double %3)
  %202 = extractelement <2 x double> %199, i64 1
  %203 = extractelement <2 x double> %199, i64 0
  %204 = call spir_func double @__ocml_atan2_f64(double noundef %202, double noundef %203) #38
  %205 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %206 = icmp eq i8 %205, 0
  br i1 %206, label %207, label %213

207:                                              ; preds = %198
  %208 = call double @llvm.copysign.f64(double 0x7FF0000000000000, double %3)
  %209 = fcmp oeq double %4, 0x7FF0000000000000
  %210 = fcmp oeq double %6, 0x7FF0000000000000
  %211 = or i1 %209, %210
  %212 = select i1 %211, double %208, double %201
  br label %213

213:                                              ; preds = %207, %198
  %214 = phi double [ %201, %198 ], [ %212, %207 ]
  %215 = call double @llvm.copysign.f64(double %204, double %5)
  %216 = insertelement <2 x double> poison, double %214, i64 0
  %217 = insertelement <2 x double> %216, double %215, i64 1
  ret <2 x double> %217
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i1 @llvm.is.fpclass.f64(double, i32 immarg) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_casin_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x float> %0, i64 1
  %3 = fneg float %2
  %4 = insertelement <2 x float> poison, float %3, i64 0
  %5 = shufflevector <2 x float> %4, <2 x float> %0, <2 x i32> <i32 0, i32 2>
  %6 = tail call spir_func <2 x float> @__ocml_casinh_f32(<2 x float> noundef %5) #38
  %7 = extractelement <2 x float> %6, i64 1
  %8 = insertelement <2 x float> poison, float %7, i64 0
  %9 = extractelement <2 x float> %6, i64 0
  %10 = fneg float %9
  %11 = insertelement <2 x float> %8, float %10, i64 1
  ret <2 x float> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_casinh_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = alloca float, align 8
  %4 = extractelement <2 x float> %0, i64 0
  %5 = tail call float @llvm.fabs.f32(float %4)
  %6 = extractelement <2 x float> %0, i64 1
  %7 = tail call float @llvm.fabs.f32(float %6)
  %8 = fcmp olt float %5, 0x4180000000000000
  %9 = fcmp olt float %7, 0x4180000000000000
  %10 = and i1 %8, %9
  br i1 %10, label %11, label %289

11:                                               ; preds = %1
  %12 = fcmp oge float %7, 1.000000e+00
  %13 = fcmp oge float %5, 0x3E70000000000000
  %14 = or i1 %12, %13
  br i1 %14, label %19, label %15

15:                                               ; preds = %11
  %16 = fsub float 1.000000e+00, %7
  %17 = fmul float %16, 0x3F30000000000000
  %18 = fcmp ogt float %5, %17
  br i1 %18, label %19, label %255

19:                                               ; preds = %15, %11
  %20 = fadd float %5, %7
  %21 = fsub float %20, %5
  %22 = fsub float %21, %20
  %23 = fadd float %5, %22
  %24 = fsub float %7, %21
  %25 = fadd float %24, %23
  %26 = fsub float %5, %7
  %27 = fsub float %26, %5
  %28 = fsub float %27, %26
  %29 = fadd float %5, %28
  %30 = fadd float %7, %27
  %31 = fsub float %29, %30
  %32 = fmul float %20, %26
  %33 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %34 = freeze i32 %33
  %35 = icmp sgt i32 %34, 8999
  br i1 %35, label %36, label %41

36:                                               ; preds = %19
  %37 = fneg float %32
  %38 = tail call float @llvm.fma.f32(float %20, float %26, float %37)
  %39 = insertelement <2 x float> poison, float %38, i64 0
  %40 = insertelement <2 x float> %39, float %32, i64 1
  br label %63

41:                                               ; preds = %19
  switch i32 %34, label %42 [
    i32 8001, label %56
    i32 7001, label %56
  ]

42:                                               ; preds = %41
  %43 = bitcast float %20 to i32
  %44 = and i32 %43, -4096
  %45 = bitcast i32 %44 to float
  %46 = fsub float %20, %45
  %47 = bitcast float %26 to i32
  %48 = and i32 %47, -4096
  %49 = bitcast i32 %48 to float
  %50 = fsub float %26, %49
  %51 = fneg float %32
  %52 = tail call float @llvm.fmuladd.f32(float %45, float %49, float %51)
  %53 = tail call float @llvm.fmuladd.f32(float %45, float %50, float %52)
  %54 = tail call float @llvm.fmuladd.f32(float %46, float %49, float %53)
  %55 = tail call float @llvm.fmuladd.f32(float %46, float %50, float %54)
  br label %59

56:                                               ; preds = %41, %41
  %57 = fneg float %32
  %58 = tail call float @llvm.fma.f32(float %20, float %26, float %57)
  br label %59

59:                                               ; preds = %56, %42
  %60 = phi float [ %58, %56 ], [ %55, %42 ]
  %61 = insertelement <2 x float> poison, float %60, i64 0
  %62 = insertelement <2 x float> %61, float %32, i64 1
  switch i32 %34, label %69 [
    i32 8001, label %63
    i32 7001, label %63
  ]

63:                                               ; preds = %59, %59, %36
  %64 = phi <2 x float> [ %62, %59 ], [ %62, %59 ], [ %40, %36 ]
  %65 = phi float [ %60, %59 ], [ %60, %59 ], [ %38, %36 ]
  %66 = tail call float @llvm.fma.f32(float %20, float %31, float %65)
  %67 = tail call float @llvm.fma.f32(float %25, float %26, float %66)
  %68 = insertelement <2 x float> %64, float %67, i64 0
  br label %74

69:                                               ; preds = %59
  %70 = fmul float %26, %25
  %71 = tail call float @llvm.fmuladd.f32(float %20, float %31, float %70)
  %72 = fadd float %71, %60
  %73 = insertelement <2 x float> %62, float %72, i64 0
  br label %74

74:                                               ; preds = %63, %69
  %75 = phi <2 x float> [ %68, %63 ], [ %73, %69 ]
  %76 = extractelement <2 x float> %75, i64 1
  %77 = extractelement <2 x float> %75, i64 0
  %78 = fadd float %76, %77
  %79 = fsub float %78, %76
  %80 = fsub float %77, %79
  %81 = fadd float %78, 1.000000e+00
  %82 = fsub float %81, %78
  %83 = fsub float %81, %82
  %84 = fsub float %78, %83
  %85 = fsub float 1.000000e+00, %82
  %86 = fadd float %85, %84
  %87 = fadd float %80, %86
  %88 = fadd float %81, %87
  %89 = fsub float %81, %88
  %90 = fadd float %87, %89
  %91 = insertelement <2 x float> poison, float %90, i64 0
  %92 = insertelement <2 x float> %91, float %88, i64 1
  %93 = fmul float %7, %5
  br i1 %35, label %95, label %94

94:                                               ; preds = %74
  switch i32 %34, label %98 [
    i32 8001, label %95
    i32 7001, label %95
  ]

95:                                               ; preds = %94, %94, %74
  %96 = fneg float %93
  %97 = tail call float @llvm.fma.f32(float %7, float %5, float %96)
  br label %112

98:                                               ; preds = %94
  %99 = bitcast float %7 to i32
  %100 = and i32 %99, -4096
  %101 = bitcast i32 %100 to float
  %102 = fsub float %7, %101
  %103 = bitcast float %5 to i32
  %104 = and i32 %103, -4096
  %105 = bitcast i32 %104 to float
  %106 = fsub float %5, %105
  %107 = fneg float %93
  %108 = tail call float @llvm.fmuladd.f32(float %101, float %105, float %107)
  %109 = tail call float @llvm.fmuladd.f32(float %101, float %106, float %108)
  %110 = tail call float @llvm.fmuladd.f32(float %102, float %105, float %109)
  %111 = tail call float @llvm.fmuladd.f32(float %102, float %106, float %110)
  br label %112

112:                                              ; preds = %95, %98
  %113 = phi float [ %111, %98 ], [ %97, %95 ]
  %114 = insertelement <2 x float> poison, float %113, i64 0
  %115 = insertelement <2 x float> %114, float %93, i64 1
  %116 = fmul <2 x float> %115, <float 2.000000e+00, float 2.000000e+00>
  %117 = shufflevector <2 x float> %92, <2 x float> %116, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %118 = tail call spir_func <4 x float> @__ocmlpriv_epcsqrtep_f32(<4 x float> noundef %117) #38
  %119 = extractelement <4 x float> %118, i64 1
  %120 = fadd float %5, %119
  %121 = fsub float %120, %119
  %122 = fsub float %120, %121
  %123 = fsub float %119, %122
  %124 = fsub float %5, %121
  %125 = fadd float %124, %123
  %126 = extractelement <4 x float> %118, i64 0
  %127 = fadd float %126, %125
  %128 = fadd float %120, %127
  %129 = fsub float %120, %128
  %130 = fadd float %127, %129
  %131 = extractelement <4 x float> %118, i64 3
  %132 = fadd float %7, %131
  %133 = fsub float %132, %131
  %134 = fsub float %132, %133
  %135 = fsub float %131, %134
  %136 = fsub float %7, %133
  %137 = fadd float %136, %135
  %138 = extractelement <4 x float> %118, i64 2
  %139 = fadd float %138, %137
  %140 = fadd float %132, %139
  %141 = fsub float %132, %140
  %142 = fadd float %139, %141
  %143 = fmul float %128, %128
  br i1 %35, label %144, label %149

144:                                              ; preds = %112
  %145 = fneg float %143
  %146 = tail call float @llvm.fma.f32(float %128, float %128, float %145)
  %147 = insertelement <2 x float> poison, float %146, i64 0
  %148 = insertelement <2 x float> %147, float %143, i64 1
  br label %174

149:                                              ; preds = %112
  switch i32 %34, label %150 [
    i32 8001, label %160
    i32 7001, label %160
  ]

150:                                              ; preds = %149
  %151 = bitcast float %128 to i32
  %152 = and i32 %151, -4096
  %153 = bitcast i32 %152 to float
  %154 = fsub float %128, %153
  %155 = fneg float %143
  %156 = tail call float @llvm.fmuladd.f32(float %153, float %153, float %155)
  %157 = fmul float %153, 2.000000e+00
  %158 = tail call float @llvm.fmuladd.f32(float %157, float %154, float %156)
  %159 = tail call float @llvm.fmuladd.f32(float %154, float %154, float %158)
  br label %163

160:                                              ; preds = %149, %149
  %161 = fneg float %143
  %162 = tail call float @llvm.fma.f32(float %128, float %128, float %161)
  br label %163

163:                                              ; preds = %160, %150
  %164 = phi float [ %162, %160 ], [ %159, %150 ]
  %165 = insertelement <2 x float> poison, float %164, i64 0
  %166 = insertelement <2 x float> %165, float %143, i64 1
  switch i32 %34, label %167 [
    i32 8001, label %174
    i32 7001, label %174
  ]

167:                                              ; preds = %163
  %168 = fmul float %130, 2.000000e+00
  %169 = tail call float @llvm.fmuladd.f32(float %168, float %128, float %164)
  %170 = fadd float %143, %169
  %171 = fsub float %170, %143
  %172 = fsub float %169, %171
  %173 = fmul float %140, %140
  br label %189

174:                                              ; preds = %144, %163, %163
  %175 = phi <2 x float> [ %166, %163 ], [ %166, %163 ], [ %148, %144 ]
  %176 = phi float [ %164, %163 ], [ %164, %163 ], [ %146, %144 ]
  %177 = fmul float %130, 2.000000e+00
  %178 = tail call float @llvm.fma.f32(float %128, float %177, float %176)
  %179 = extractelement <2 x float> %175, i64 1
  %180 = fadd float %179, %178
  %181 = fsub float %180, %179
  %182 = fsub float %178, %181
  %183 = fmul float %140, %140
  br i1 %35, label %184, label %189

184:                                              ; preds = %174
  %185 = fneg float %183
  %186 = tail call float @llvm.fma.f32(float %140, float %140, float %185)
  %187 = insertelement <2 x float> poison, float %186, i64 0
  %188 = insertelement <2 x float> %187, float %183, i64 1
  br label %210

189:                                              ; preds = %167, %174
  %190 = phi float [ %173, %167 ], [ %183, %174 ]
  %191 = phi float [ %172, %167 ], [ %182, %174 ]
  %192 = phi float [ %170, %167 ], [ %180, %174 ]
  switch i32 %34, label %193 [
    i32 8001, label %203
    i32 7001, label %203
  ]

193:                                              ; preds = %189
  %194 = bitcast float %140 to i32
  %195 = and i32 %194, -4096
  %196 = bitcast i32 %195 to float
  %197 = fsub float %140, %196
  %198 = fneg float %190
  %199 = tail call float @llvm.fmuladd.f32(float %196, float %196, float %198)
  %200 = fmul float %196, 2.000000e+00
  %201 = tail call float @llvm.fmuladd.f32(float %200, float %197, float %199)
  %202 = tail call float @llvm.fmuladd.f32(float %197, float %197, float %201)
  br label %206

203:                                              ; preds = %189, %189
  %204 = fneg float %190
  %205 = tail call float @llvm.fma.f32(float %140, float %140, float %204)
  br label %206

206:                                              ; preds = %203, %193
  %207 = phi float [ %205, %203 ], [ %202, %193 ]
  %208 = insertelement <2 x float> poison, float %207, i64 0
  %209 = insertelement <2 x float> %208, float %190, i64 1
  switch i32 %34, label %218 [
    i32 8001, label %210
    i32 7001, label %210
  ]

210:                                              ; preds = %206, %206, %184
  %211 = phi float [ %191, %206 ], [ %191, %206 ], [ %182, %184 ]
  %212 = phi float [ %192, %206 ], [ %192, %206 ], [ %180, %184 ]
  %213 = phi <2 x float> [ %209, %206 ], [ %209, %206 ], [ %188, %184 ]
  %214 = phi float [ %207, %206 ], [ %207, %206 ], [ %186, %184 ]
  %215 = fmul float %142, 2.000000e+00
  %216 = tail call float @llvm.fma.f32(float %140, float %215, float %214)
  %217 = insertelement <2 x float> %213, float %216, i64 0
  br label %222

218:                                              ; preds = %206
  %219 = fmul float %142, 2.000000e+00
  %220 = tail call float @llvm.fmuladd.f32(float %219, float %140, float %207)
  %221 = insertelement <2 x float> %209, float %220, i64 0
  br label %222

222:                                              ; preds = %210, %218
  %223 = phi float [ %211, %210 ], [ %191, %218 ]
  %224 = phi float [ %212, %210 ], [ %192, %218 ]
  %225 = phi <2 x float> [ %217, %210 ], [ %221, %218 ]
  %226 = extractelement <2 x float> %225, i64 1
  %227 = extractelement <2 x float> %225, i64 0
  %228 = fadd float %226, %227
  %229 = fsub float %228, %226
  %230 = fsub float %227, %229
  %231 = fadd float %224, %228
  %232 = fsub float %231, %224
  %233 = fsub float %231, %232
  %234 = fsub float %224, %233
  %235 = fsub float %228, %232
  %236 = fadd float %235, %234
  %237 = fadd float %223, %230
  %238 = fsub float %237, %223
  %239 = fsub float %237, %238
  %240 = fsub float %223, %239
  %241 = fsub float %230, %238
  %242 = fadd float %241, %240
  %243 = fadd float %237, %236
  %244 = fadd float %231, %243
  %245 = fsub float %244, %231
  %246 = fsub float %243, %245
  %247 = fadd float %242, %246
  %248 = fadd float %244, %247
  %249 = fsub float %248, %244
  %250 = fsub float %247, %249
  %251 = insertelement <2 x float> poison, float %250, i64 0
  %252 = insertelement <2 x float> %251, float %248, i64 1
  %253 = insertelement <2 x float> poison, float %128, i64 0
  %254 = insertelement <2 x float> %253, float %140, i64 1
  br label %370

255:                                              ; preds = %15
  %256 = fneg float %7
  %257 = tail call float @llvm.fma.f32(float %256, float %7, float 1.000000e+00)
  %258 = fcmp olt float %257, 0x39F0000000000000
  %259 = select i1 %258, float 0x41F0000000000000, float 1.000000e+00
  %260 = fmul float %257, %259
  %261 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %262 = icmp eq i8 %261, 0
  br i1 %262, label %263, label %278

263:                                              ; preds = %255
  %264 = tail call float @llvm.sqrt.f32(float %260), !fpmath !18
  %265 = bitcast float %264 to i32
  %266 = add nsw i32 %265, -1
  %267 = bitcast i32 %266 to float
  %268 = add nsw i32 %265, 1
  %269 = bitcast i32 %268 to float
  %270 = fneg float %267
  %271 = tail call float @llvm.fma.f32(float %270, float %264, float %260)
  %272 = fneg float %269
  %273 = tail call float @llvm.fma.f32(float %272, float %264, float %260)
  %274 = fcmp ole float %271, 0.000000e+00
  %275 = select i1 %274, float %267, float %264
  %276 = fcmp ogt float %273, 0.000000e+00
  %277 = select i1 %276, float %269, float %275
  br label %376

278:                                              ; preds = %255
  %279 = tail call spir_func float @_Z12native_rsqrtf(float noundef %260) #38
  %280 = fmul float %260, %279
  %281 = fmul float %279, 5.000000e-01
  %282 = fneg float %281
  %283 = tail call float @llvm.fma.f32(float %282, float %280, float 5.000000e-01)
  %284 = tail call float @llvm.fma.f32(float %281, float %283, float %281)
  %285 = tail call float @llvm.fma.f32(float %280, float %283, float %280)
  %286 = fneg float %285
  %287 = tail call float @llvm.fma.f32(float %286, float %285, float %260)
  %288 = tail call float @llvm.fma.f32(float %287, float %284, float %285)
  br label %376

289:                                              ; preds = %1
  %290 = insertelement <2 x float> poison, float %5, i64 0
  %291 = insertelement <2 x float> %290, float %7, i64 1
  %292 = bitcast float %5 to i32
  %293 = bitcast float %7 to i32
  %294 = tail call i32 @llvm.umax.i32(i32 %292, i32 %293)
  %295 = bitcast i32 %294 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %296 = addrspacecast ptr %2 to ptr addrspace(4)
  %297 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %295, ptr addrspace(4) noundef %296) #40
  %298 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %299 = sub nsw i32 0, %298
  %300 = call spir_func float @_Z5ldexpfi(float noundef %5, i32 noundef %299) #38
  %301 = call spir_func float @_Z5ldexpfi(float noundef %7, i32 noundef %299) #38
  %302 = fmul float %300, %300
  %303 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %304 = freeze i32 %303
  %305 = icmp sgt i32 %304, 8999
  br i1 %305, label %306, label %310

306:                                              ; preds = %289
  %307 = fneg float %302
  %308 = call float @llvm.fma.f32(float %300, float %300, float %307)
  %309 = fmul float %301, %301
  br label %327

310:                                              ; preds = %289
  switch i32 %304, label %311 [
    i32 8001, label %321
    i32 7001, label %321
  ]

311:                                              ; preds = %310
  %312 = bitcast float %300 to i32
  %313 = and i32 %312, -4096
  %314 = bitcast i32 %313 to float
  %315 = fsub float %300, %314
  %316 = fneg float %302
  %317 = call float @llvm.fmuladd.f32(float %314, float %314, float %316)
  %318 = fmul float %314, 2.000000e+00
  %319 = call float @llvm.fmuladd.f32(float %318, float %315, float %317)
  %320 = call float @llvm.fmuladd.f32(float %315, float %315, float %319)
  br label %324

321:                                              ; preds = %310, %310
  %322 = fneg float %302
  %323 = call float @llvm.fma.f32(float %300, float %300, float %322)
  br label %324

324:                                              ; preds = %321, %311
  %325 = phi float [ %320, %311 ], [ %323, %321 ]
  %326 = fmul float %301, %301
  switch i32 %304, label %332 [
    i32 8001, label %327
    i32 7001, label %327
  ]

327:                                              ; preds = %306, %324, %324
  %328 = phi float [ %326, %324 ], [ %326, %324 ], [ %309, %306 ]
  %329 = phi float [ %325, %324 ], [ %325, %324 ], [ %308, %306 ]
  %330 = fneg float %328
  %331 = call float @llvm.fma.f32(float %301, float %301, float %330)
  br label %342

332:                                              ; preds = %324
  %333 = bitcast float %301 to i32
  %334 = and i32 %333, -4096
  %335 = bitcast i32 %334 to float
  %336 = fsub float %301, %335
  %337 = fneg float %326
  %338 = call float @llvm.fmuladd.f32(float %335, float %335, float %337)
  %339 = fmul float %335, 2.000000e+00
  %340 = call float @llvm.fmuladd.f32(float %339, float %336, float %338)
  %341 = call float @llvm.fmuladd.f32(float %336, float %336, float %340)
  br label %342

342:                                              ; preds = %327, %332
  %343 = phi float [ %326, %332 ], [ %328, %327 ]
  %344 = phi float [ %325, %332 ], [ %329, %327 ]
  %345 = phi float [ %341, %332 ], [ %331, %327 ]
  %346 = fadd float %302, %343
  %347 = fsub float %346, %302
  %348 = fsub float %347, %346
  %349 = fadd float %302, %348
  %350 = fsub float %343, %347
  %351 = fadd float %350, %349
  %352 = fadd float %344, %345
  %353 = fsub float %352, %344
  %354 = fsub float %352, %353
  %355 = fsub float %344, %354
  %356 = fsub float %345, %353
  %357 = fadd float %356, %355
  %358 = fadd float %352, %351
  %359 = fadd float %346, %358
  %360 = fsub float %346, %359
  %361 = fadd float %358, %360
  %362 = fadd float %357, %361
  %363 = fadd float %359, %362
  %364 = fsub float %359, %363
  %365 = fadd float %362, %364
  %366 = insertelement <2 x float> poison, float %365, i64 0
  %367 = insertelement <2 x float> %366, float %363, i64 1
  %368 = shl nsw i32 %298, 1
  %369 = add nsw i32 %368, 2
  br label %370

370:                                              ; preds = %222, %342
  %371 = phi i32 [ %369, %342 ], [ 0, %222 ]
  %372 = phi <2 x float> [ %291, %342 ], [ %254, %222 ]
  %373 = phi <2 x float> [ %367, %342 ], [ %252, %222 ]
  %374 = call spir_func float @__ocmlpriv_lnep_f32(<2 x float> noundef %373, i32 noundef %371) #38
  %375 = fmul float %374, 5.000000e-01
  br label %390

376:                                              ; preds = %278, %263
  %377 = phi float [ %288, %278 ], [ %277, %263 ]
  %378 = select i1 %258, float 0x3EF0000000000000, float 1.000000e+00
  %379 = fmul float %378, %377
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %260, ptr %3, align 8, !tbaa !16
  %380 = addrspacecast ptr %3 to ptr addrspace(4)
  %381 = load i64, ptr addrspace(4) %380, align 8, !tbaa !12
  %382 = icmp ne i64 %381, 2139095040
  %383 = and i64 %381, 2147483647
  %384 = icmp ne i64 %383, 0
  %385 = and i1 %382, %384
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %386 = select i1 %385, float %379, float %260
  %387 = fdiv float %5, %386, !fpmath !15
  %388 = insertelement <2 x float> poison, float %386, i64 0
  %389 = insertelement <2 x float> %388, float %7, i64 1
  br label %390

390:                                              ; preds = %376, %370
  %391 = phi <2 x float> [ %372, %370 ], [ %389, %376 ]
  %392 = phi float [ %375, %370 ], [ %387, %376 ]
  %393 = call float @llvm.copysign.f32(float %392, float %4)
  %394 = extractelement <2 x float> %391, i64 1
  %395 = extractelement <2 x float> %391, i64 0
  %396 = call spir_func float @__ocml_atan2_f32(float noundef %394, float noundef %395) #38
  %397 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %398 = icmp eq i8 %397, 0
  br i1 %398, label %399, label %405

399:                                              ; preds = %390
  %400 = call float @llvm.copysign.f32(float 0x7FF0000000000000, float %4)
  %401 = fcmp oeq float %5, 0x7FF0000000000000
  %402 = fcmp oeq float %7, 0x7FF0000000000000
  %403 = or i1 %401, %402
  %404 = select i1 %403, float %400, float %393
  br label %405

405:                                              ; preds = %399, %390
  %406 = phi float [ %393, %390 ], [ %404, %399 ]
  %407 = call float @llvm.copysign.f32(float %396, float %6)
  %408 = insertelement <2 x float> poison, float %406, i64 0
  %409 = insertelement <2 x float> %408, float %407, i64 1
  ret <2 x float> %409
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_catan_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x double> %0, i64 1
  %3 = fneg double %2
  %4 = insertelement <2 x double> poison, double %3, i64 0
  %5 = shufflevector <2 x double> %4, <2 x double> %0, <2 x i32> <i32 0, i32 2>
  %6 = tail call spir_func <2 x double> @__ocml_catanh_f64(<2 x double> noundef %5) #38
  %7 = extractelement <2 x double> %6, i64 1
  %8 = insertelement <2 x double> poison, double %7, i64 0
  %9 = extractelement <2 x double> %6, i64 0
  %10 = fneg double %9
  %11 = insertelement <2 x double> %8, double %10, i64 1
  ret <2 x double> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_catanh_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca i32, align 4
  %4 = extractelement <2 x double> %0, i64 0
  %5 = tail call double @llvm.fabs.f64(double %4)
  %6 = extractelement <2 x double> %0, i64 1
  %7 = tail call double @llvm.fabs.f64(double %6)
  %8 = fcmp olt double %5, 0x4350000000000000
  %9 = fcmp olt double %7, 0x4350000000000000
  %10 = and i1 %8, %9
  br i1 %10, label %11, label %202

11:                                               ; preds = %1
  %12 = fsub double 1.000000e+00, %5
  %13 = fadd double %12, -1.000000e+00
  %14 = fsub double %13, %12
  %15 = fadd double %14, 1.000000e+00
  %16 = fadd double %5, %13
  %17 = fsub double %15, %16
  %18 = fadd double %5, 1.000000e+00
  %19 = fadd double %18, -1.000000e+00
  %20 = fsub double %19, %18
  %21 = fadd double %20, 1.000000e+00
  %22 = fsub double %5, %19
  %23 = fadd double %22, %21
  %24 = fmul double %6, %6
  %25 = fneg double %24
  %26 = tail call double @llvm.fma.f64(double %6, double %6, double %25)
  %27 = fmul double %12, %18
  %28 = fneg double %27
  %29 = tail call double @llvm.fma.f64(double %12, double %18, double %28)
  %30 = tail call double @llvm.fma.f64(double %12, double %23, double %29)
  %31 = tail call double @llvm.fma.f64(double %17, double %18, double %30)
  %32 = fadd double %27, %31
  %33 = fsub double %32, %27
  %34 = fsub double %31, %33
  %35 = fsub double %32, %24
  %36 = fsub double %35, %32
  %37 = fsub double %35, %36
  %38 = fsub double %32, %37
  %39 = fadd double %24, %36
  %40 = fsub double %38, %39
  %41 = fsub double %34, %26
  %42 = fsub double %41, %34
  %43 = fsub double %41, %42
  %44 = fsub double %34, %43
  %45 = fadd double %26, %42
  %46 = fsub double %44, %45
  %47 = fadd double %41, %40
  %48 = fadd double %35, %47
  %49 = fsub double %48, %35
  %50 = fsub double %47, %49
  %51 = fadd double %46, %50
  %52 = fadd double %48, %51
  %53 = fmul double %7, 2.000000e+00
  %54 = tail call spir_func double @__ocml_atan2_f64(double noundef %53, double noundef %52) #38
  %55 = fmul double %54, 5.000000e-01
  %56 = fmul double %18, %18
  %57 = fneg double %56
  %58 = tail call double @llvm.fma.f64(double %18, double %18, double %57)
  %59 = fmul double %23, 2.000000e+00
  %60 = tail call double @llvm.fma.f64(double %18, double %59, double %58)
  %61 = fadd double %56, %60
  %62 = fsub double %61, %56
  %63 = fsub double %60, %62
  %64 = fadd double %24, %61
  %65 = fsub double %64, %61
  %66 = fsub double %65, %64
  %67 = fadd double %61, %66
  %68 = fsub double %24, %65
  %69 = fadd double %68, %67
  %70 = fadd double %26, %63
  %71 = fsub double %70, %63
  %72 = fsub double %70, %71
  %73 = fsub double %63, %72
  %74 = fsub double %26, %71
  %75 = fadd double %74, %73
  %76 = fadd double %70, %69
  %77 = fadd double %64, %76
  %78 = fsub double %64, %77
  %79 = fadd double %76, %78
  %80 = fadd double %75, %79
  %81 = fadd double %77, %80
  %82 = fsub double %77, %81
  %83 = fadd double %80, %82
  %84 = fmul double %81, 1.250000e-01
  %85 = fcmp olt double %5, %84
  br i1 %85, label %86, label %120

86:                                               ; preds = %11
  %87 = fmul double %5, 4.000000e+00
  %88 = fptrunc double %81 to float
  %89 = tail call spir_func float @_Z12native_recipf(float noundef %88) #38
  %90 = fpext float %89 to double
  %91 = fneg double %81
  %92 = tail call double @llvm.fma.f64(double %91, double %90, double 1.000000e+00)
  %93 = tail call double @llvm.fma.f64(double %92, double %90, double %90)
  %94 = tail call double @llvm.fma.f64(double %91, double %93, double 1.000000e+00)
  %95 = tail call double @llvm.fma.f64(double %94, double %93, double %93)
  %96 = fmul double %87, %95
  %97 = fmul double %81, %96
  %98 = fneg double %97
  %99 = tail call double @llvm.fma.f64(double %96, double %81, double %98)
  %100 = tail call double @llvm.fma.f64(double %96, double %83, double %99)
  %101 = fadd double %97, %100
  %102 = fsub double %101, %97
  %103 = fsub double %100, %102
  %104 = fsub double %87, %101
  %105 = fsub double %87, %104
  %106 = fsub double %105, %101
  %107 = fsub double %106, %103
  %108 = fadd double %104, %107
  %109 = fmul double %95, %108
  %110 = fadd double %96, %109
  %111 = fsub double %110, %96
  %112 = fsub double 1.000000e+00, %110
  %113 = fsub double 1.000000e+00, %112
  %114 = fsub double %113, %110
  %115 = fsub double %111, %109
  %116 = fadd double %115, %114
  %117 = fadd double %112, %116
  %118 = fsub double %112, %117
  %119 = fadd double %116, %118
  br label %195

120:                                              ; preds = %11
  %121 = fmul double %12, %12
  %122 = fneg double %121
  %123 = tail call double @llvm.fma.f64(double %12, double %12, double %122)
  %124 = fmul double %17, 2.000000e+00
  %125 = tail call double @llvm.fma.f64(double %12, double %124, double %123)
  %126 = fadd double %121, %125
  %127 = fsub double %126, %121
  %128 = fsub double %125, %127
  %129 = fadd double %24, %126
  %130 = fsub double %129, %126
  %131 = fsub double %130, %129
  %132 = fadd double %126, %131
  %133 = fsub double %24, %130
  %134 = fadd double %133, %132
  %135 = fadd double %26, %128
  %136 = fsub double %135, %128
  %137 = fsub double %135, %136
  %138 = fsub double %128, %137
  %139 = fsub double %26, %136
  %140 = fadd double %139, %138
  %141 = fadd double %135, %134
  %142 = fadd double %129, %141
  %143 = fsub double %129, %142
  %144 = fadd double %141, %143
  %145 = fadd double %140, %144
  %146 = fadd double %142, %145
  %147 = fsub double %142, %146
  %148 = fadd double %145, %147
  %149 = fptrunc double %81 to float
  %150 = tail call spir_func float @_Z12native_recipf(float noundef %149) #38
  %151 = fpext float %150 to double
  %152 = fneg double %81
  %153 = tail call double @llvm.fma.f64(double %152, double %151, double 1.000000e+00)
  %154 = tail call double @llvm.fma.f64(double %153, double %151, double %151)
  %155 = tail call double @llvm.fma.f64(double %152, double %154, double 1.000000e+00)
  %156 = tail call double @llvm.fma.f64(double %155, double %154, double %154)
  %157 = fmul double %146, %156
  %158 = fmul double %81, %157
  %159 = fneg double %158
  %160 = tail call double @llvm.fma.f64(double %157, double %81, double %159)
  %161 = tail call double @llvm.fma.f64(double %157, double %83, double %160)
  %162 = fadd double %158, %161
  %163 = fsub double %162, %158
  %164 = fsub double %146, %162
  %165 = fsub double %146, %164
  %166 = fsub double %165, %162
  %167 = fadd double %148, %166
  %168 = fsub double %163, %161
  %169 = fadd double %168, %167
  %170 = fadd double %164, %169
  %171 = fsub double %170, %164
  %172 = fsub double %169, %171
  %173 = fmul double %156, %170
  %174 = fmul double %81, %173
  %175 = fneg double %174
  %176 = tail call double @llvm.fma.f64(double %173, double %81, double %175)
  %177 = tail call double @llvm.fma.f64(double %173, double %83, double %176)
  %178 = fadd double %174, %177
  %179 = fsub double %178, %174
  %180 = fsub double %177, %179
  %181 = fsub double %170, %178
  %182 = fsub double %170, %181
  %183 = fsub double %182, %178
  %184 = fadd double %172, %183
  %185 = fsub double %184, %180
  %186 = fadd double %181, %185
  %187 = fmul double %156, %186
  %188 = fadd double %157, %173
  %189 = fsub double %188, %157
  %190 = fsub double %173, %189
  %191 = fadd double %190, %187
  %192 = fadd double %188, %191
  %193 = fsub double %192, %188
  %194 = fsub double %191, %193
  br label %195

195:                                              ; preds = %120, %86
  %196 = phi double [ %194, %120 ], [ %119, %86 ]
  %197 = phi double [ %192, %120 ], [ %117, %86 ]
  %198 = insertelement <2 x double> poison, double %196, i64 0
  %199 = insertelement <2 x double> %198, double %197, i64 1
  %200 = tail call spir_func double @__ocmlpriv_lnep_f64(<2 x double> noundef %199, i32 noundef 0) #38
  %201 = fmul double %200, -2.500000e-01
  br label %215

202:                                              ; preds = %1
  %203 = tail call double @llvm.maxnum.f64(double %5, double %7)
  %204 = fptrunc double %203 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %205 = addrspacecast ptr %3 to ptr addrspace(4)
  %206 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %204, ptr addrspace(4) noundef %205) #40
  %207 = load i32, ptr %3, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %208 = sub nsw i32 0, %207
  %209 = call spir_func double @_Z5ldexpdi(double noundef %5, i32 noundef %208) #38
  %210 = call spir_func double @_Z5ldexpdi(double noundef %7, i32 noundef %208) #38
  %211 = fmul double %210, %210
  %212 = call double @llvm.fma.f64(double %209, double %209, double %211)
  %213 = fdiv double %209, %212
  %214 = call spir_func double @_Z5ldexpdi(double noundef %213, i32 noundef %208) #38
  br label %215

215:                                              ; preds = %202, %195
  %216 = phi double [ %55, %195 ], [ 0x3FF921FB54442D18, %202 ]
  %217 = phi double [ %201, %195 ], [ %214, %202 ]
  %218 = phi double [ %7, %195 ], [ %210, %202 ]
  %219 = phi double [ %5, %195 ], [ %209, %202 ]
  %220 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %221 = icmp eq i8 %220, 0
  br i1 %221, label %222, label %250

222:                                              ; preds = %215
  %223 = fcmp oeq double %219, 1.000000e+00
  %224 = fcmp oeq double %218, 0.000000e+00
  %225 = and i1 %224, %223
  %226 = select i1 %225, double 0x7FF0000000000000, double %217
  %227 = call i1 @llvm.is.fpclass.f64(double %219, i32 612)
  %228 = fcmp uno double %219, 0.000000e+00
  %229 = call double @llvm.fabs.f64(double %218)
  %230 = fcmp oeq double %229, 0x7FF0000000000000
  %231 = and i1 %228, %230
  %232 = or i1 %227, %231
  %233 = select i1 %232, double 0.000000e+00, double %226
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %218, ptr %2, align 8, !tbaa !19
  %234 = addrspacecast ptr %2 to ptr addrspace(4)
  %235 = load i128, ptr addrspace(4) %234, align 8, !tbaa !29
  %236 = and i128 %235, 9223372036854775807
  %237 = icmp eq i128 %236, 0
  br i1 %237, label %244, label %238

238:                                              ; preds = %222
  %239 = and i128 %235, 9218868437227405312
  %240 = icmp eq i128 %239, 0
  %241 = and i128 %235, 4503599627370495
  %242 = icmp ne i128 %241, 0
  %243 = and i1 %240, %242
  br label %244

244:                                              ; preds = %222, %238
  %245 = phi i1 [ true, %222 ], [ %243, %238 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %246 = and i1 %228, %245
  %247 = select i1 %246, double 0x7FF8000000000000, double %216
  %248 = fcmp uno double %218, 0.000000e+00
  %249 = select i1 %248, double %218, double %247
  br label %250

250:                                              ; preds = %244, %215
  %251 = phi double [ %216, %215 ], [ %249, %244 ]
  %252 = phi double [ %217, %215 ], [ %233, %244 ]
  %253 = call double @llvm.copysign.f64(double %252, double %4)
  %254 = call double @llvm.copysign.f64(double %251, double %6)
  %255 = insertelement <2 x double> poison, double %253, i64 0
  %256 = insertelement <2 x double> %255, double %254, i64 1
  ret <2 x double> %256
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_catan_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x float> %0, i64 1
  %3 = fneg float %2
  %4 = insertelement <2 x float> poison, float %3, i64 0
  %5 = shufflevector <2 x float> %4, <2 x float> %0, <2 x i32> <i32 0, i32 2>
  %6 = tail call spir_func <2 x float> @__ocml_catanh_f32(<2 x float> noundef %5) #38
  %7 = extractelement <2 x float> %6, i64 1
  %8 = insertelement <2 x float> poison, float %7, i64 0
  %9 = extractelement <2 x float> %6, i64 0
  %10 = fneg float %9
  %11 = insertelement <2 x float> %8, float %10, i64 1
  ret <2 x float> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_catanh_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca i32, align 4
  %4 = extractelement <2 x float> %0, i64 0
  %5 = tail call float @llvm.fabs.f32(float %4)
  %6 = extractelement <2 x float> %0, i64 1
  %7 = tail call float @llvm.fabs.f32(float %6)
  %8 = fcmp olt float %5, 0x4180000000000000
  %9 = fcmp olt float %7, 0x4180000000000000
  %10 = and i1 %8, %9
  br i1 %10, label %11, label %421

11:                                               ; preds = %1
  %12 = fsub float 1.000000e+00, %5
  %13 = fadd float %12, -1.000000e+00
  %14 = fsub float %13, %12
  %15 = fadd float %14, 1.000000e+00
  %16 = fadd float %5, %13
  %17 = fsub float %15, %16
  %18 = fadd float %5, 1.000000e+00
  %19 = fadd float %18, -1.000000e+00
  %20 = fsub float %19, %18
  %21 = fadd float %20, 1.000000e+00
  %22 = fsub float %5, %19
  %23 = fadd float %22, %21
  %24 = fmul float %6, %6
  %25 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %26 = freeze i32 %25
  %27 = icmp sgt i32 %26, 8999
  br i1 %27, label %42, label %28

28:                                               ; preds = %11
  switch i32 %26, label %29 [
    i32 8001, label %39
    i32 7001, label %39
  ]

29:                                               ; preds = %28
  %30 = bitcast float %7 to i32
  %31 = and i32 %30, -4096
  %32 = bitcast i32 %31 to float
  %33 = fsub float %7, %32
  %34 = fneg float %24
  %35 = tail call float @llvm.fmuladd.f32(float %32, float %32, float %34)
  %36 = fmul float %32, 2.000000e+00
  %37 = tail call float @llvm.fmuladd.f32(float %36, float %33, float %35)
  %38 = tail call float @llvm.fmuladd.f32(float %33, float %33, float %37)
  br label %50

39:                                               ; preds = %28, %28
  %40 = fneg float %24
  %41 = tail call float @llvm.fma.f32(float %6, float %6, float %40)
  br label %50

42:                                               ; preds = %11
  %43 = fneg float %24
  %44 = tail call float @llvm.fma.f32(float %6, float %6, float %43)
  %45 = fmul float %12, %18
  %46 = fneg float %45
  %47 = tail call float @llvm.fma.f32(float %12, float %18, float %46)
  %48 = insertelement <2 x float> poison, float %47, i64 0
  %49 = insertelement <2 x float> %48, float %45, i64 1
  br label %74

50:                                               ; preds = %39, %29
  %51 = phi float [ %38, %29 ], [ %41, %39 ]
  %52 = fmul float %12, %18
  switch i32 %26, label %53 [
    i32 8001, label %67
    i32 7001, label %67
  ]

53:                                               ; preds = %50
  %54 = bitcast float %12 to i32
  %55 = and i32 %54, -4096
  %56 = bitcast i32 %55 to float
  %57 = fsub float %12, %56
  %58 = bitcast float %18 to i32
  %59 = and i32 %58, -4096
  %60 = bitcast i32 %59 to float
  %61 = fsub float %18, %60
  %62 = fneg float %52
  %63 = tail call float @llvm.fmuladd.f32(float %56, float %60, float %62)
  %64 = tail call float @llvm.fmuladd.f32(float %56, float %61, float %63)
  %65 = tail call float @llvm.fmuladd.f32(float %57, float %60, float %64)
  %66 = tail call float @llvm.fmuladd.f32(float %57, float %61, float %65)
  br label %70

67:                                               ; preds = %50, %50
  %68 = fneg float %52
  %69 = tail call float @llvm.fma.f32(float %12, float %18, float %68)
  br label %70

70:                                               ; preds = %67, %53
  %71 = phi float [ %69, %67 ], [ %66, %53 ]
  %72 = insertelement <2 x float> poison, float %71, i64 0
  %73 = insertelement <2 x float> %72, float %52, i64 1
  switch i32 %26, label %81 [
    i32 8001, label %74
    i32 7001, label %74
  ]

74:                                               ; preds = %70, %70, %42
  %75 = phi float [ %51, %70 ], [ %51, %70 ], [ %44, %42 ]
  %76 = phi <2 x float> [ %73, %70 ], [ %73, %70 ], [ %49, %42 ]
  %77 = phi float [ %71, %70 ], [ %71, %70 ], [ %47, %42 ]
  %78 = tail call float @llvm.fma.f32(float %12, float %23, float %77)
  %79 = tail call float @llvm.fma.f32(float %17, float %18, float %78)
  %80 = insertelement <2 x float> %76, float %79, i64 0
  br label %86

81:                                               ; preds = %70
  %82 = fmul float %18, %17
  %83 = tail call float @llvm.fmuladd.f32(float %12, float %23, float %82)
  %84 = fadd float %83, %71
  %85 = insertelement <2 x float> %73, float %84, i64 0
  br label %86

86:                                               ; preds = %74, %81
  %87 = phi float [ %75, %74 ], [ %51, %81 ]
  %88 = phi <2 x float> [ %80, %74 ], [ %85, %81 ]
  %89 = extractelement <2 x float> %88, i64 1
  %90 = extractelement <2 x float> %88, i64 0
  %91 = fadd float %89, %90
  %92 = fsub float %91, %89
  %93 = fsub float %90, %92
  %94 = fsub float %91, %24
  %95 = fsub float %94, %91
  %96 = fsub float %94, %95
  %97 = fsub float %91, %96
  %98 = fadd float %24, %95
  %99 = fsub float %97, %98
  %100 = fsub float %93, %87
  %101 = fsub float %100, %93
  %102 = fsub float %100, %101
  %103 = fsub float %93, %102
  %104 = fadd float %87, %101
  %105 = fsub float %103, %104
  %106 = fadd float %100, %99
  %107 = fadd float %94, %106
  %108 = fsub float %107, %94
  %109 = fsub float %106, %108
  %110 = fadd float %105, %109
  %111 = fadd float %107, %110
  %112 = fmul float %7, 2.000000e+00
  %113 = tail call spir_func float @__ocml_atan2_f32(float noundef %112, float noundef %111) #38
  %114 = fmul float %113, 5.000000e-01
  %115 = fmul float %18, %18
  br i1 %27, label %116, label %121

116:                                              ; preds = %86
  %117 = fneg float %115
  %118 = tail call float @llvm.fma.f32(float %18, float %18, float %117)
  %119 = insertelement <2 x float> poison, float %118, i64 0
  %120 = insertelement <2 x float> %119, float %115, i64 1
  br label %139

121:                                              ; preds = %86
  switch i32 %26, label %122 [
    i32 8001, label %132
    i32 7001, label %132
  ]

122:                                              ; preds = %121
  %123 = bitcast float %18 to i32
  %124 = and i32 %123, -4096
  %125 = bitcast i32 %124 to float
  %126 = fsub float %18, %125
  %127 = fneg float %115
  %128 = tail call float @llvm.fmuladd.f32(float %125, float %125, float %127)
  %129 = fmul float %125, 2.000000e+00
  %130 = tail call float @llvm.fmuladd.f32(float %129, float %126, float %128)
  %131 = tail call float @llvm.fmuladd.f32(float %126, float %126, float %130)
  br label %135

132:                                              ; preds = %121, %121
  %133 = fneg float %115
  %134 = tail call float @llvm.fma.f32(float %18, float %18, float %133)
  br label %135

135:                                              ; preds = %132, %122
  %136 = phi float [ %134, %132 ], [ %131, %122 ]
  %137 = insertelement <2 x float> poison, float %136, i64 0
  %138 = insertelement <2 x float> %137, float %115, i64 1
  switch i32 %26, label %145 [
    i32 8001, label %139
    i32 7001, label %139
  ]

139:                                              ; preds = %135, %135, %116
  %140 = phi <2 x float> [ %138, %135 ], [ %138, %135 ], [ %120, %116 ]
  %141 = phi float [ %136, %135 ], [ %136, %135 ], [ %118, %116 ]
  %142 = fmul float %23, 2.000000e+00
  %143 = tail call float @llvm.fma.f32(float %18, float %142, float %141)
  %144 = insertelement <2 x float> %140, float %143, i64 0
  br label %149

145:                                              ; preds = %135
  %146 = fmul float %23, 2.000000e+00
  %147 = tail call float @llvm.fmuladd.f32(float %146, float %18, float %136)
  %148 = insertelement <2 x float> %138, float %147, i64 0
  br label %149

149:                                              ; preds = %139, %145
  %150 = phi <2 x float> [ %144, %139 ], [ %148, %145 ]
  %151 = extractelement <2 x float> %150, i64 1
  %152 = extractelement <2 x float> %150, i64 0
  %153 = fadd float %151, %152
  %154 = fsub float %153, %151
  %155 = fsub float %152, %154
  %156 = fadd float %24, %153
  %157 = fsub float %156, %153
  %158 = fsub float %156, %157
  %159 = fsub float %153, %158
  %160 = fsub float %24, %157
  %161 = fadd float %160, %159
  %162 = fadd float %87, %155
  %163 = fsub float %162, %155
  %164 = fsub float %162, %163
  %165 = fsub float %155, %164
  %166 = fsub float %87, %163
  %167 = fadd float %166, %165
  %168 = fadd float %162, %161
  %169 = fadd float %156, %168
  %170 = fsub float %156, %169
  %171 = fadd float %168, %170
  %172 = fadd float %167, %171
  %173 = fadd float %169, %172
  %174 = fsub float %169, %173
  %175 = fadd float %172, %174
  %176 = fmul float %173, 1.250000e-01
  %177 = fcmp olt float %5, %176
  br i1 %177, label %178, label %241

178:                                              ; preds = %149
  %179 = fmul float %5, 4.000000e+00
  %180 = tail call spir_func float @_Z12native_recipf(float noundef %173) #38
  %181 = fmul float %179, %180
  %182 = fmul float %173, %181
  br i1 %27, label %183, label %188

183:                                              ; preds = %178
  %184 = fneg float %182
  %185 = tail call float @llvm.fma.f32(float %181, float %173, float %184)
  %186 = insertelement <2 x float> poison, float %185, i64 0
  %187 = insertelement <2 x float> %186, float %182, i64 1
  br label %210

188:                                              ; preds = %178
  switch i32 %26, label %189 [
    i32 8001, label %203
    i32 7001, label %203
  ]

189:                                              ; preds = %188
  %190 = bitcast float %181 to i32
  %191 = and i32 %190, -4096
  %192 = bitcast i32 %191 to float
  %193 = fsub float %181, %192
  %194 = bitcast float %173 to i32
  %195 = and i32 %194, -4096
  %196 = bitcast i32 %195 to float
  %197 = fsub float %173, %196
  %198 = fneg float %182
  %199 = tail call float @llvm.fmuladd.f32(float %192, float %196, float %198)
  %200 = tail call float @llvm.fmuladd.f32(float %192, float %197, float %199)
  %201 = tail call float @llvm.fmuladd.f32(float %193, float %196, float %200)
  %202 = tail call float @llvm.fmuladd.f32(float %193, float %197, float %201)
  br label %206

203:                                              ; preds = %188, %188
  %204 = fneg float %182
  %205 = tail call float @llvm.fma.f32(float %181, float %173, float %204)
  br label %206

206:                                              ; preds = %203, %189
  %207 = phi float [ %205, %203 ], [ %202, %189 ]
  %208 = insertelement <2 x float> poison, float %207, i64 0
  %209 = insertelement <2 x float> %208, float %182, i64 1
  switch i32 %26, label %215 [
    i32 8001, label %210
    i32 7001, label %210
  ]

210:                                              ; preds = %206, %206, %183
  %211 = phi <2 x float> [ %209, %206 ], [ %209, %206 ], [ %187, %183 ]
  %212 = phi float [ %207, %206 ], [ %207, %206 ], [ %185, %183 ]
  %213 = tail call float @llvm.fma.f32(float %181, float %175, float %212)
  %214 = insertelement <2 x float> %211, float %213, i64 0
  br label %218

215:                                              ; preds = %206
  %216 = tail call float @llvm.fmuladd.f32(float %181, float %175, float %207)
  %217 = insertelement <2 x float> %209, float %216, i64 0
  br label %218

218:                                              ; preds = %210, %215
  %219 = phi <2 x float> [ %214, %210 ], [ %217, %215 ]
  %220 = extractelement <2 x float> %219, i64 1
  %221 = extractelement <2 x float> %219, i64 0
  %222 = fadd float %220, %221
  %223 = fsub float %222, %220
  %224 = fsub float %221, %223
  %225 = fsub float %179, %222
  %226 = fsub float %179, %225
  %227 = fsub float %226, %222
  %228 = fsub float %227, %224
  %229 = fadd float %225, %228
  %230 = fmul float %180, %229
  %231 = fadd float %181, %230
  %232 = fsub float %231, %181
  %233 = fsub float 1.000000e+00, %231
  %234 = fsub float 1.000000e+00, %233
  %235 = fsub float %234, %231
  %236 = fsub float %232, %230
  %237 = fadd float %236, %235
  %238 = fadd float %233, %237
  %239 = fsub float %233, %238
  %240 = fadd float %237, %239
  br label %414

241:                                              ; preds = %149
  %242 = fmul float %12, %12
  br i1 %27, label %243, label %248

243:                                              ; preds = %241
  %244 = fneg float %242
  %245 = tail call float @llvm.fma.f32(float %12, float %12, float %244)
  %246 = insertelement <2 x float> poison, float %245, i64 0
  %247 = insertelement <2 x float> %246, float %242, i64 1
  br label %266

248:                                              ; preds = %241
  switch i32 %26, label %249 [
    i32 8001, label %259
    i32 7001, label %259
  ]

249:                                              ; preds = %248
  %250 = bitcast float %12 to i32
  %251 = and i32 %250, -4096
  %252 = bitcast i32 %251 to float
  %253 = fsub float %12, %252
  %254 = fneg float %242
  %255 = tail call float @llvm.fmuladd.f32(float %252, float %252, float %254)
  %256 = fmul float %252, 2.000000e+00
  %257 = tail call float @llvm.fmuladd.f32(float %256, float %253, float %255)
  %258 = tail call float @llvm.fmuladd.f32(float %253, float %253, float %257)
  br label %262

259:                                              ; preds = %248, %248
  %260 = fneg float %242
  %261 = tail call float @llvm.fma.f32(float %12, float %12, float %260)
  br label %262

262:                                              ; preds = %259, %249
  %263 = phi float [ %261, %259 ], [ %258, %249 ]
  %264 = insertelement <2 x float> poison, float %263, i64 0
  %265 = insertelement <2 x float> %264, float %242, i64 1
  switch i32 %26, label %272 [
    i32 8001, label %266
    i32 7001, label %266
  ]

266:                                              ; preds = %262, %262, %243
  %267 = phi <2 x float> [ %265, %262 ], [ %265, %262 ], [ %247, %243 ]
  %268 = phi float [ %263, %262 ], [ %263, %262 ], [ %245, %243 ]
  %269 = fmul float %17, 2.000000e+00
  %270 = tail call float @llvm.fma.f32(float %12, float %269, float %268)
  %271 = insertelement <2 x float> %267, float %270, i64 0
  br label %276

272:                                              ; preds = %262
  %273 = fmul float %17, 2.000000e+00
  %274 = tail call float @llvm.fmuladd.f32(float %273, float %12, float %263)
  %275 = insertelement <2 x float> %265, float %274, i64 0
  br label %276

276:                                              ; preds = %266, %272
  %277 = phi <2 x float> [ %271, %266 ], [ %275, %272 ]
  %278 = extractelement <2 x float> %277, i64 1
  %279 = extractelement <2 x float> %277, i64 0
  %280 = fadd float %278, %279
  %281 = fsub float %280, %278
  %282 = fsub float %279, %281
  %283 = fadd float %24, %280
  %284 = fsub float %283, %280
  %285 = fsub float %283, %284
  %286 = fsub float %280, %285
  %287 = fsub float %24, %284
  %288 = fadd float %287, %286
  %289 = fadd float %87, %282
  %290 = fsub float %289, %282
  %291 = fsub float %289, %290
  %292 = fsub float %282, %291
  %293 = fsub float %87, %290
  %294 = fadd float %293, %292
  %295 = fadd float %289, %288
  %296 = fadd float %283, %295
  %297 = fsub float %283, %296
  %298 = fadd float %295, %297
  %299 = fadd float %294, %298
  %300 = fadd float %296, %299
  %301 = fsub float %296, %300
  %302 = fadd float %299, %301
  %303 = tail call spir_func float @_Z12native_recipf(float noundef %173) #38
  %304 = fmul float %303, %300
  %305 = fmul float %173, %304
  br i1 %27, label %306, label %311

306:                                              ; preds = %276
  %307 = fneg float %305
  %308 = tail call float @llvm.fma.f32(float %304, float %173, float %307)
  %309 = insertelement <2 x float> poison, float %308, i64 0
  %310 = insertelement <2 x float> %309, float %305, i64 1
  br label %333

311:                                              ; preds = %276
  switch i32 %26, label %312 [
    i32 8001, label %326
    i32 7001, label %326
  ]

312:                                              ; preds = %311
  %313 = bitcast float %304 to i32
  %314 = and i32 %313, -4096
  %315 = bitcast i32 %314 to float
  %316 = fsub float %304, %315
  %317 = bitcast float %173 to i32
  %318 = and i32 %317, -4096
  %319 = bitcast i32 %318 to float
  %320 = fsub float %173, %319
  %321 = fneg float %305
  %322 = tail call float @llvm.fmuladd.f32(float %315, float %319, float %321)
  %323 = tail call float @llvm.fmuladd.f32(float %315, float %320, float %322)
  %324 = tail call float @llvm.fmuladd.f32(float %316, float %319, float %323)
  %325 = tail call float @llvm.fmuladd.f32(float %316, float %320, float %324)
  br label %329

326:                                              ; preds = %311, %311
  %327 = fneg float %305
  %328 = tail call float @llvm.fma.f32(float %304, float %173, float %327)
  br label %329

329:                                              ; preds = %326, %312
  %330 = phi float [ %328, %326 ], [ %325, %312 ]
  %331 = insertelement <2 x float> poison, float %330, i64 0
  %332 = insertelement <2 x float> %331, float %305, i64 1
  switch i32 %26, label %338 [
    i32 8001, label %333
    i32 7001, label %333
  ]

333:                                              ; preds = %329, %329, %306
  %334 = phi <2 x float> [ %332, %329 ], [ %332, %329 ], [ %310, %306 ]
  %335 = phi float [ %330, %329 ], [ %330, %329 ], [ %308, %306 ]
  %336 = tail call float @llvm.fma.f32(float %304, float %175, float %335)
  %337 = insertelement <2 x float> %334, float %336, i64 0
  br label %341

338:                                              ; preds = %329
  %339 = tail call float @llvm.fmuladd.f32(float %304, float %175, float %330)
  %340 = insertelement <2 x float> %332, float %339, i64 0
  br label %341

341:                                              ; preds = %338, %333
  %342 = phi <2 x float> [ %337, %333 ], [ %340, %338 ]
  %343 = extractelement <2 x float> %342, i64 1
  %344 = extractelement <2 x float> %342, i64 0
  %345 = fadd float %343, %344
  %346 = fsub float %345, %343
  %347 = fsub float %300, %345
  %348 = fsub float %300, %347
  %349 = fsub float %348, %345
  %350 = fadd float %302, %349
  %351 = fsub float %346, %344
  %352 = fadd float %351, %350
  %353 = fadd float %347, %352
  %354 = fmul float %303, %353
  %355 = fmul float %173, %354
  br i1 %27, label %356, label %361

356:                                              ; preds = %341
  %357 = fneg float %355
  %358 = tail call float @llvm.fma.f32(float %354, float %173, float %357)
  %359 = insertelement <2 x float> poison, float %358, i64 0
  %360 = insertelement <2 x float> %359, float %355, i64 1
  br label %383

361:                                              ; preds = %341
  switch i32 %26, label %362 [
    i32 8001, label %376
    i32 7001, label %376
  ]

362:                                              ; preds = %361
  %363 = bitcast float %354 to i32
  %364 = and i32 %363, -4096
  %365 = bitcast i32 %364 to float
  %366 = fsub float %354, %365
  %367 = bitcast float %173 to i32
  %368 = and i32 %367, -4096
  %369 = bitcast i32 %368 to float
  %370 = fsub float %173, %369
  %371 = fneg float %355
  %372 = tail call float @llvm.fmuladd.f32(float %365, float %369, float %371)
  %373 = tail call float @llvm.fmuladd.f32(float %365, float %370, float %372)
  %374 = tail call float @llvm.fmuladd.f32(float %366, float %369, float %373)
  %375 = tail call float @llvm.fmuladd.f32(float %366, float %370, float %374)
  br label %379

376:                                              ; preds = %361, %361
  %377 = fneg float %355
  %378 = tail call float @llvm.fma.f32(float %354, float %173, float %377)
  br label %379

379:                                              ; preds = %376, %362
  %380 = phi float [ %378, %376 ], [ %375, %362 ]
  %381 = insertelement <2 x float> poison, float %380, i64 0
  %382 = insertelement <2 x float> %381, float %355, i64 1
  switch i32 %26, label %388 [
    i32 8001, label %383
    i32 7001, label %383
  ]

383:                                              ; preds = %379, %379, %356
  %384 = phi <2 x float> [ %382, %379 ], [ %382, %379 ], [ %360, %356 ]
  %385 = phi float [ %380, %379 ], [ %380, %379 ], [ %358, %356 ]
  %386 = tail call float @llvm.fma.f32(float %354, float %175, float %385)
  %387 = insertelement <2 x float> %384, float %386, i64 0
  br label %391

388:                                              ; preds = %379
  %389 = tail call float @llvm.fmuladd.f32(float %354, float %175, float %380)
  %390 = insertelement <2 x float> %382, float %389, i64 0
  br label %391

391:                                              ; preds = %383, %388
  %392 = phi <2 x float> [ %387, %383 ], [ %390, %388 ]
  %393 = fsub float %353, %347
  %394 = fsub float %352, %393
  %395 = extractelement <2 x float> %392, i64 1
  %396 = extractelement <2 x float> %392, i64 0
  %397 = fadd float %395, %396
  %398 = fsub float %397, %395
  %399 = fsub float %396, %398
  %400 = fsub float %353, %397
  %401 = fsub float %353, %400
  %402 = fsub float %401, %397
  %403 = fadd float %394, %402
  %404 = fsub float %403, %399
  %405 = fadd float %400, %404
  %406 = fmul float %303, %405
  %407 = fadd float %304, %354
  %408 = fsub float %407, %304
  %409 = fsub float %354, %408
  %410 = fadd float %409, %406
  %411 = fadd float %407, %410
  %412 = fsub float %411, %407
  %413 = fsub float %410, %412
  br label %414

414:                                              ; preds = %391, %218
  %415 = phi float [ %413, %391 ], [ %240, %218 ]
  %416 = phi float [ %411, %391 ], [ %238, %218 ]
  %417 = insertelement <2 x float> poison, float %415, i64 0
  %418 = insertelement <2 x float> %417, float %416, i64 1
  %419 = tail call spir_func float @__ocmlpriv_lnep_f32(<2 x float> noundef %418, i32 noundef 0) #38
  %420 = fmul float %419, -2.500000e-01
  br label %436

421:                                              ; preds = %1
  %422 = bitcast float %5 to i32
  %423 = bitcast float %7 to i32
  %424 = tail call i32 @llvm.umax.i32(i32 %422, i32 %423)
  %425 = bitcast i32 %424 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %426 = addrspacecast ptr %3 to ptr addrspace(4)
  %427 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %425, ptr addrspace(4) noundef %426) #40
  %428 = load i32, ptr %3, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %429 = sub nsw i32 0, %428
  %430 = call spir_func float @_Z5ldexpfi(float noundef %5, i32 noundef %429) #38
  %431 = call spir_func float @_Z5ldexpfi(float noundef %7, i32 noundef %429) #38
  %432 = fmul float %431, %431
  %433 = call spir_func float @__ocml_fmuladd_f32(float noundef %430, float noundef %430, float noundef %432) #38
  %434 = fdiv float %430, %433, !fpmath !15
  %435 = call spir_func float @_Z5ldexpfi(float noundef %434, i32 noundef %429) #38
  br label %436

436:                                              ; preds = %421, %414
  %437 = phi float [ %114, %414 ], [ 0x3FF921FB60000000, %421 ]
  %438 = phi float [ %420, %414 ], [ %435, %421 ]
  %439 = phi float [ %7, %414 ], [ %431, %421 ]
  %440 = phi float [ %5, %414 ], [ %430, %421 ]
  %441 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %442 = icmp eq i8 %441, 0
  br i1 %442, label %443, label %471

443:                                              ; preds = %436
  %444 = fcmp oeq float %440, 1.000000e+00
  %445 = fcmp oeq float %439, 0.000000e+00
  %446 = and i1 %445, %444
  %447 = select i1 %446, float 0x7FF0000000000000, float %438
  %448 = call i1 @llvm.is.fpclass.f32(float %440, i32 612)
  %449 = fcmp uno float %440, 0.000000e+00
  %450 = call float @llvm.fabs.f32(float %439)
  %451 = fcmp oeq float %450, 0x7FF0000000000000
  %452 = and i1 %449, %451
  %453 = or i1 %448, %452
  %454 = select i1 %453, float 0.000000e+00, float %447
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %439, ptr %2, align 8, !tbaa !16
  %455 = addrspacecast ptr %2 to ptr addrspace(4)
  %456 = load i64, ptr addrspace(4) %455, align 8, !tbaa !12
  %457 = and i64 %456, 2147483647
  %458 = icmp eq i64 %457, 0
  br i1 %458, label %465, label %459

459:                                              ; preds = %443
  %460 = and i64 %456, 2139095040
  %461 = icmp eq i64 %460, 0
  %462 = and i64 %456, 8388607
  %463 = icmp ne i64 %462, 0
  %464 = and i1 %461, %463
  br label %465

465:                                              ; preds = %443, %459
  %466 = phi i1 [ true, %443 ], [ %464, %459 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %467 = and i1 %449, %466
  %468 = select i1 %467, float 0x7FF8000000000000, float %437
  %469 = fcmp uno float %439, 0.000000e+00
  %470 = select i1 %469, float %439, float %468
  br label %471

471:                                              ; preds = %465, %436
  %472 = phi float [ %437, %436 ], [ %470, %465 ]
  %473 = phi float [ %438, %436 ], [ %454, %465 ]
  %474 = call float @llvm.copysign.f32(float %473, float %4)
  %475 = call float @llvm.copysign.f32(float %472, float %6)
  %476 = insertelement <2 x float> poison, float %474, i64 0
  %477 = insertelement <2 x float> %476, float %475, i64 1
  ret <2 x float> %477
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i1 @llvm.is.fpclass.f32(float, i32 immarg) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_cbrt_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca i32, align 4
  %4 = tail call double @llvm.fabs.f64(double %0)
  %5 = fptrunc double %4 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %6 = addrspacecast ptr %3 to ptr addrspace(4)
  %7 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %5, ptr addrspace(4) noundef %6) #40
  %8 = load i32, ptr %3, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %9 = sitofp i32 %8 to float
  %10 = fmul float %9, 0x3FD5555560000000
  %11 = call float @llvm.rint.f32(float %10)
  %12 = fptosi float %11 to i32
  %13 = mul nsw i32 %12, -3
  %14 = call spir_func double @_Z5ldexpdi(double noundef %4, i32 noundef %13) #38
  %15 = fptrunc double %14 to float
  %16 = call float @llvm.log2.f32(float %15)
  %17 = fmul float %16, 0x3FD5555560000000
  %18 = call float @llvm.exp2.f32(float %17)
  %19 = fpext float %18 to double
  %20 = fmul double %19, %19
  %21 = fneg double %19
  %22 = call double @llvm.fma.f64(double %21, double %20, double %14)
  %23 = fadd double %19, %19
  %24 = call double @llvm.fma.f64(double %23, double %20, double %14)
  %25 = fptrunc double %24 to float
  %26 = call spir_func float @_Z12native_recipf(float noundef %25) #38
  %27 = fpext float %26 to double
  %28 = fneg double %24
  %29 = call double @llvm.fma.f64(double %28, double %27, double 1.000000e+00)
  %30 = call double @llvm.fma.f64(double %29, double %27, double %27)
  %31 = call double @llvm.fma.f64(double %28, double %30, double 1.000000e+00)
  %32 = call double @llvm.fma.f64(double %31, double %30, double %30)
  %33 = fmul double %22, %32
  %34 = call double @llvm.fma.f64(double %28, double %33, double %22)
  %35 = call double @llvm.fma.f64(double %34, double %32, double %33)
  %36 = call double @llvm.fma.f64(double %19, double %35, double %19)
  %37 = call spir_func double @_Z5ldexpdi(double noundef %36, i32 noundef %12) #38
  %38 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %39 = icmp eq i8 %38, 0
  br i1 %39, label %40, label %51

40:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %0, ptr %2, align 8, !tbaa !19
  %41 = addrspacecast ptr %2 to ptr addrspace(4)
  %42 = load i128, ptr addrspace(4) %41, align 8, !tbaa !29
  switch i128 %42, label %44 [
    i128 9218868437227405312, label %43
    i128 18442240474082181120, label %43
  ]

43:                                               ; preds = %40, %40
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  br label %51

44:                                               ; preds = %40
  %45 = and i128 %42, 9221120237041090560
  %46 = icmp eq i128 %45, 0
  %47 = and i128 %42, 2251799813685247
  %48 = icmp ne i128 %47, 0
  %49 = and i1 %46, %48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %50 = select i1 %49, double %37, double %0
  br label %51

51:                                               ; preds = %44, %43, %1
  %52 = phi double [ %37, %1 ], [ %0, %43 ], [ %50, %44 ]
  %53 = call double @llvm.copysign.f64(double %52, double %0)
  ret double %53
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.rint.f32(float) #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.exp2.f32(float) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_cbrt_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca float, align 8
  %4 = alloca float, align 8
  %5 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %6 = icmp eq i8 %5, 0
  %7 = select i1 %6, float %0, float 0.000000e+00
  %8 = tail call float @llvm.fabs.f32(float %7)
  br i1 %6, label %9, label %19

9:                                                ; preds = %1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  store float %0, ptr %4, align 8, !tbaa !16
  %10 = addrspacecast ptr %4 to ptr addrspace(4)
  %11 = load i64, ptr addrspace(4) %10, align 8, !tbaa !12
  %12 = and i64 %11, 2139095040
  %13 = icmp ne i64 %12, 0
  %14 = and i64 %11, 8388607
  %15 = icmp eq i64 %14, 0
  %16 = or i1 %13, %15
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br i1 %16, label %19, label %17

17:                                               ; preds = %9
  %18 = tail call spir_func float @_Z5ldexpfi(float noundef %8, i32 noundef 24) #38
  br label %19

19:                                               ; preds = %17, %9, %1
  %20 = phi float [ %8, %1 ], [ %18, %17 ], [ %8, %9 ]
  %21 = tail call float @llvm.log2.f32(float %20)
  %22 = fmul float %21, 0x3FD5555560000000
  %23 = tail call float @llvm.exp2.f32(float %22)
  %24 = fmul float %23, %23
  %25 = tail call spir_func float @_Z12native_recipf(float noundef %24) #38
  %26 = fneg float %20
  %27 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %25, float noundef %26, float noundef %23) #38
  %28 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %27, float noundef 0xBFD5555560000000, float noundef %23) #38
  br i1 %6, label %29, label %39

29:                                               ; preds = %19
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %0, ptr %3, align 8, !tbaa !16
  %30 = addrspacecast ptr %3 to ptr addrspace(4)
  %31 = load i64, ptr addrspace(4) %30, align 8, !tbaa !12
  %32 = and i64 %31, 2139095040
  %33 = icmp ne i64 %32, 0
  %34 = and i64 %31, 8388607
  %35 = icmp eq i64 %34, 0
  %36 = or i1 %33, %35
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br i1 %36, label %39, label %37

37:                                               ; preds = %29
  %38 = tail call spir_func float @_Z5ldexpfi(float noundef %28, i32 noundef -8) #38
  br label %39

39:                                               ; preds = %37, %29, %19
  %40 = phi float [ %28, %19 ], [ %38, %37 ], [ %28, %29 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %7, ptr %2, align 8, !tbaa !16
  %41 = addrspacecast ptr %2 to ptr addrspace(4)
  %42 = load i64, ptr addrspace(4) %41, align 8, !tbaa !12
  switch i64 %42, label %43 [
    i64 2139095040, label %49
    i64 -8388608, label %49
  ]

43:                                               ; preds = %39
  %44 = and i64 %42, 2143289344
  %45 = icmp ne i64 %44, 0
  %46 = and i64 %42, 2147483647
  %47 = icmp eq i64 %46, 0
  %48 = or i1 %45, %47
  br i1 %48, label %49, label %50

49:                                               ; preds = %39, %39, %43
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %51

50:                                               ; preds = %43
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %51

51:                                               ; preds = %49, %50
  %52 = phi float [ %40, %50 ], [ %7, %49 ]
  %53 = tail call float @llvm.copysign.f32(float %52, float %7)
  ret float %53
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_cbrt_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_cbrt_f16(half noundef %2) #42
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_cbrt_f16(half noundef %5) #42
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_cbrt_f16(half noundef %0) local_unnamed_addr #26 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  %3 = fpext half %2 to float
  %4 = tail call float @llvm.log2.f32(float %3)
  %5 = fmul float %4, 0x3FD5555560000000
  %6 = tail call float @llvm.exp2.f32(float %5)
  %7 = fptrunc float %6 to half
  %8 = tail call half @llvm.copysign.f16(half %7, half %0)
  %9 = fptoui half %0 to i16
  %10 = tail call spir_func i32 @__builtin_generic_class_f16.25(i16 noundef zeroext %9) #39
  %11 = icmp eq i32 %10, 0
  %12 = select i1 %11, half %8, half %0
  ret half %12
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16.25(i16 noundef zeroext %0) unnamed_addr #25 {
  switch i16 %0, label %2 [
    i16 31744, label %9
    i16 -1024, label %9
  ]

2:                                                ; preds = %1
  %3 = and i16 %0, 32256
  %4 = icmp ne i16 %3, 0
  %5 = and i16 %0, 511
  %6 = icmp eq i16 %5, 0
  %7 = or i1 %4, %6
  %8 = sext i1 %7 to i32
  br label %9

9:                                                ; preds = %2, %1, %1
  %10 = phi i32 [ -1, %1 ], [ -1, %1 ], [ %8, %2 ]
  ret i32 %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_ccos_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x double> %0, i64 1
  %3 = fneg double %2
  %4 = insertelement <2 x double> poison, double %3, i64 0
  %5 = shufflevector <2 x double> %4, <2 x double> %0, <2 x i32> <i32 0, i32 2>
  %6 = tail call spir_func <2 x double> @__ocml_ccosh_f64(<2 x double> noundef %5) #38
  ret <2 x double> %6
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_ccosh_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca double, align 8
  %4 = extractelement <2 x double> %0, i64 0
  %5 = tail call double @llvm.fabs.f64(double %4)
  %6 = fadd double %5, 0xBFF62E42FEFA39EF
  %7 = fsub double %6, %5
  %8 = fsub double %7, %6
  %9 = fadd double %5, %8
  %10 = fadd double %7, 0x3FF62E42FEFA39EF
  %11 = fsub double %9, %10
  %12 = fadd double %11, 0xBC8ABC9E3B39803F
  %13 = fadd double %6, %12
  %14 = fsub double %6, %13
  %15 = fadd double %12, %14
  %16 = insertelement <2 x double> poison, double %15, i64 0
  %17 = insertelement <2 x double> %16, double %13, i64 1
  %18 = tail call spir_func <2 x double> @__ocmlpriv_epexpep_f64(<2 x double> noundef %17) #38
  %19 = extractelement <2 x double> %18, i64 1
  %20 = fptrunc double %19 to float
  %21 = tail call spir_func float @_Z12native_recipf(float noundef %20) #38
  %22 = fpext float %21 to double
  %23 = fneg double %19
  %24 = tail call double @llvm.fma.f64(double %23, double %22, double 1.000000e+00)
  %25 = tail call double @llvm.fma.f64(double %24, double %22, double %22)
  %26 = tail call double @llvm.fma.f64(double %23, double %25, double 1.000000e+00)
  %27 = tail call double @llvm.fma.f64(double %26, double %25, double %25)
  %28 = fmul double %19, %27
  %29 = fneg double %28
  %30 = tail call double @llvm.fma.f64(double %27, double %19, double %29)
  %31 = extractelement <2 x double> %18, i64 0
  %32 = tail call double @llvm.fma.f64(double %27, double %31, double %30)
  %33 = fadd double %28, %32
  %34 = fsub double %33, %28
  %35 = fsub double 1.000000e+00, %33
  %36 = fsub double 1.000000e+00, %35
  %37 = fsub double %36, %33
  %38 = fsub double %34, %32
  %39 = fadd double %38, %37
  %40 = fadd double %35, %39
  %41 = fsub double %35, %40
  %42 = fadd double %39, %41
  %43 = fmul double %27, %40
  %44 = fmul double %19, %43
  %45 = fneg double %44
  %46 = tail call double @llvm.fma.f64(double %43, double %19, double %45)
  %47 = tail call double @llvm.fma.f64(double %43, double %31, double %46)
  %48 = fadd double %44, %47
  %49 = fsub double %48, %44
  %50 = fsub double %40, %48
  %51 = fsub double %40, %50
  %52 = fsub double %51, %48
  %53 = fadd double %42, %52
  %54 = fsub double %49, %47
  %55 = fadd double %54, %53
  %56 = fadd double %50, %55
  %57 = fmul double %27, %56
  %58 = fadd double %27, %43
  %59 = fsub double %58, %27
  %60 = fsub double %43, %59
  %61 = fadd double %60, %57
  %62 = fadd double %58, %61
  %63 = fsub double %62, %58
  %64 = fsub double %61, %63
  %65 = tail call spir_func double @_Z5ldexpdi(double noundef %62, i32 noundef -4) #38
  %66 = tail call spir_func double @_Z5ldexpdi(double noundef %64, i32 noundef -4) #38
  %67 = fadd double %19, %65
  %68 = fsub double %67, %19
  %69 = fsub double %65, %68
  %70 = fadd double %31, %66
  %71 = fadd double %70, %69
  %72 = fadd double %67, %71
  %73 = fsub double %19, %65
  %74 = fsub double %19, %73
  %75 = fsub double %74, %65
  %76 = fadd double %31, %75
  %77 = fsub double %76, %66
  %78 = fadd double %73, %77
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #39
  %79 = extractelement <2 x double> %0, i64 1
  %80 = call spir_func double @__ocml_sincos_f64(double noundef %79, ptr noundef nonnull %3) #40
  %81 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %82 = icmp eq i8 %81, 0
  %83 = fcmp oge double %5, 0x4086395A2079B70C
  %84 = and i1 %83, %82
  %85 = select i1 %84, double 0x7FF0000000000000, double %78
  %86 = select i1 %84, double 0x7FF0000000000000, double %72
  %87 = load double, ptr %3, align 8, !tbaa !19
  %88 = fmul double %87, %86
  %89 = call spir_func double @_Z5ldexpdi(double noundef %88, i32 noundef 1) #38
  %90 = fcmp oge double %5, 0x3E40000000000000
  %91 = select i1 %90, double %85, double %5
  %92 = call double @llvm.copysign.f64(double %91, double %4)
  %93 = fmul double %80, %92
  %94 = zext i1 %90 to i32
  %95 = call spir_func double @_Z5ldexpdi(double noundef %93, i32 noundef %94) #38
  br i1 %82, label %96, label %115

96:                                               ; preds = %1
  %97 = fcmp oeq double %4, 0.000000e+00
  %98 = fcmp oeq double %79, 0.000000e+00
  %99 = or i1 %97, %98
  %100 = call double @llvm.copysign.f64(double 0.000000e+00, double %79)
  %101 = select i1 %99, double %100, double %95
  %102 = fcmp une double %5, 0x7FF0000000000000
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %79, ptr %2, align 8, !tbaa !19
  %103 = addrspacecast ptr %2 to ptr addrspace(4)
  %104 = load i128, ptr addrspace(4) %103, align 8, !tbaa !29
  switch i128 %104, label %105 [
    i128 9218868437227405312, label %111
    i128 18442240474082181120, label %111
  ]

105:                                              ; preds = %96
  %106 = and i128 %104, 9221120237041090560
  %107 = icmp eq i128 %106, 0
  %108 = and i128 %104, 2251799813685247
  %109 = icmp ne i128 %108, 0
  %110 = and i1 %107, %109
  br label %111

111:                                              ; preds = %96, %96, %105
  %112 = phi i1 [ false, %96 ], [ false, %96 ], [ %110, %105 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %113 = or i1 %102, %112
  %114 = select i1 %113, double %89, double %5
  br label %115

115:                                              ; preds = %111, %1
  %116 = phi double [ %89, %1 ], [ %114, %111 ]
  %117 = phi double [ %95, %1 ], [ %101, %111 ]
  %118 = insertelement <2 x double> poison, double %116, i64 0
  %119 = insertelement <2 x double> %118, double %117, i64 1
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #39
  ret <2 x double> %119
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocmlpriv_epexpep_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x double> %0, i64 1
  %3 = fmul double %2, 0x3FF71547652B82FE
  %4 = tail call double @llvm.rint.f64(double %3)
  %5 = tail call double @llvm.fma.f64(double %4, double 0xBFE62E42FEFA3000, double %2)
  %6 = extractelement <2 x double> %0, i64 0
  %7 = fadd double %6, %5
  %8 = fsub double %7, %5
  %9 = fsub double %6, %8
  %10 = fmul double %4, 0x3D53DE6AF278E000
  %11 = fsub double %7, %10
  %12 = fsub double %7, %11
  %13 = fsub double %12, %10
  %14 = fadd double %9, %13
  %15 = fadd double %11, %14
  %16 = fsub double %15, %11
  %17 = fsub double %14, %16
  %18 = fmul double %4, 0x3AC9CC01F97B57A0
  %19 = fsub double %15, %18
  %20 = fsub double %15, %19
  %21 = fsub double %20, %18
  %22 = fadd double %17, %21
  %23 = fadd double %19, %22
  %24 = fsub double %23, %19
  %25 = fsub double %22, %24
  %26 = tail call double @llvm.fma.f64(double %23, double 0x3E5ADE156A5DCB37, double 0x3E928AF3FCA7AB0C)
  %27 = tail call double @llvm.fma.f64(double %23, double %26, double 0x3EC71DEE623FDE64)
  %28 = tail call double @llvm.fma.f64(double %23, double %27, double 0x3EFA01997C89E6B0)
  %29 = tail call double @llvm.fma.f64(double %23, double %28, double 0x3F2A01A014761F6E)
  %30 = tail call double @llvm.fma.f64(double %23, double %29, double 0x3F56C16C1852B7B0)
  %31 = tail call double @llvm.fma.f64(double %23, double %30, double 0x3F81111111122322)
  %32 = tail call double @llvm.fma.f64(double %23, double %31, double 0x3FA55555555502A1)
  %33 = tail call double @llvm.fma.f64(double %23, double %32, double 0x3FC5555555555511)
  %34 = tail call double @llvm.fma.f64(double %23, double %33, double 0x3FE000000000000B)
  %35 = fmul double %23, %23
  %36 = fneg double %35
  %37 = tail call double @llvm.fma.f64(double %23, double %23, double %36)
  %38 = fmul double %25, 2.000000e+00
  %39 = tail call double @llvm.fma.f64(double %23, double %38, double %37)
  %40 = fadd double %35, %39
  %41 = fsub double %40, %35
  %42 = fsub double %39, %41
  %43 = fmul double %40, %34
  %44 = fneg double %43
  %45 = tail call double @llvm.fma.f64(double %40, double %34, double %44)
  %46 = tail call double @llvm.fma.f64(double %42, double %34, double %45)
  %47 = fadd double %43, %46
  %48 = fsub double %47, %43
  %49 = fsub double %46, %48
  %50 = fadd double %23, %47
  %51 = fsub double %50, %23
  %52 = fsub double %47, %51
  %53 = fadd double %25, %49
  %54 = fadd double %53, %52
  %55 = fadd double %50, %54
  %56 = fsub double %55, %50
  %57 = fsub double %54, %56
  %58 = fadd double %55, 1.000000e+00
  %59 = fadd double %58, -1.000000e+00
  %60 = fsub double %55, %59
  %61 = fadd double %57, %60
  %62 = fadd double %58, %61
  %63 = fsub double %62, %58
  %64 = fsub double %61, %63
  %65 = fptosi double %4 to i32
  %66 = tail call spir_func double @_Z5ldexpdi(double noundef %62, i32 noundef %65) #38
  %67 = tail call spir_func double @_Z5ldexpdi(double noundef %64, i32 noundef %65) #38
  %68 = insertelement <2 x double> poison, double %67, i64 0
  %69 = insertelement <2 x double> %68, double %66, i64 1
  ret <2 x double> %69
}

; Function Attrs: convergent mustprogress norecurse nounwind willreturn memory(argmem: write)
define protected spir_func double @__ocml_sincos_f64(double noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #27 {
  %3 = alloca double, align 8
  %4 = alloca %struct.redret, align 8
  %5 = alloca %struct.scret, align 8
  %6 = tail call double @llvm.fabs.f64(double %0)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4) #39
  call spir_func void @__ocmlpriv_trigred_f64(ptr dead_on_unwind nonnull writable sret(%struct.redret) align 8 %4, double noundef %6) #43
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %5) #39
  %7 = getelementptr inbounds %struct.redret, ptr %4, i64 0, i32 1
  %8 = load double, ptr %7, align 8, !tbaa !31
  %9 = load double, ptr %4, align 8, !tbaa !33
  call spir_func void @__ocmlpriv_sincosred2_f64(ptr dead_on_unwind nonnull writable sret(%struct.scret) align 8 %5, double noundef %8, double noundef %9) #43
  %10 = getelementptr inbounds %struct.redret, ptr %4, i64 0, i32 2
  %11 = load i32, ptr %10, align 8, !tbaa !34
  %12 = icmp sgt i32 %11, 1
  %13 = select i1 %12, i32 -2147483648, i32 0
  %14 = and i32 %11, 1
  %15 = icmp eq i32 %14, 0
  %16 = getelementptr inbounds %struct.scret, ptr %5, i64 0, i32 1
  %17 = load double, ptr %16, align 8
  %18 = load double, ptr %5, align 8
  %19 = select i1 %15, double %18, double %17
  %20 = bitcast double %19 to <2 x i32>
  %21 = bitcast double %0 to <2 x i32>
  %22 = extractelement <2 x i32> %21, i64 1
  %23 = and i32 %22, -2147483648
  %24 = extractelement <2 x i32> %20, i64 1
  %25 = xor i32 %23, %24
  %26 = xor i32 %25, %13
  %27 = insertelement <2 x i32> %20, i32 %26, i64 1
  %28 = fneg double %18
  %29 = select i1 %15, double %17, double %28
  %30 = bitcast double %29 to <2 x i32>
  %31 = extractelement <2 x i32> %30, i64 1
  %32 = xor i32 %31, %13
  %33 = insertelement <2 x i32> %30, i32 %32, i64 1
  %34 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %36, label %51

36:                                               ; preds = %2
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %0, ptr %3, align 8, !tbaa !19
  %37 = addrspacecast ptr %3 to ptr addrspace(4)
  %38 = load i128, ptr addrspace(4) %37, align 8, !tbaa !29
  %39 = and i128 %38, 9223372036854775807
  %40 = icmp eq i128 %39, 0
  br i1 %40, label %41, label %42

41:                                               ; preds = %36
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  br label %51

42:                                               ; preds = %36
  %43 = and i128 %38, 9218868437227405312
  %44 = icmp ne i128 %43, 0
  %45 = and i128 %38, 4503599627370495
  %46 = icmp eq i128 %45, 0
  %47 = or i1 %44, %46
  %48 = freeze i1 %47
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  %49 = select i1 %48, <2 x i32> <i32 0, i32 2146959360>, <2 x i32> %33
  %50 = select i1 %48, <2 x i32> <i32 0, i32 2146959360>, <2 x i32> %27
  br label %51

51:                                               ; preds = %42, %41, %2
  %52 = phi <2 x i32> [ %33, %2 ], [ %33, %41 ], [ %49, %42 ]
  %53 = phi <2 x i32> [ %27, %2 ], [ %27, %41 ], [ %50, %42 ]
  store <2 x i32> %52, ptr %1, align 8, !tbaa !19
  %54 = bitcast <2 x i32> %53 to double
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %5) #39
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4) #39
  ret double %54
}

; Function Attrs: convergent mustprogress norecurse nounwind willreturn memory(argmem: readwrite)
define protected spir_func void @__ocmlpriv_trigred_f64(ptr dead_on_unwind noalias writable sret(%struct.redret) align 8 %0, double noundef %1) local_unnamed_addr #28 {
  %3 = fcmp olt double %1, 0x41D0000000000000
  br i1 %3, label %4, label %5

4:                                                ; preds = %2
  tail call spir_func void @__ocmlpriv_trigredsmall_f64(ptr dead_on_unwind writable sret(%struct.redret) align 8 %0, double noundef %1) #43
  br label %6

5:                                                ; preds = %2
  tail call spir_func void @__ocmlpriv_trigredlarge_f64(ptr dead_on_unwind writable sret(%struct.redret) align 8 %0, double noundef %1) #43
  br label %6

6:                                                ; preds = %5, %4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_sincosred2_f64(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.scret) align 8 %0, double noundef %1, double noundef %2) local_unnamed_addr #29 {
  %4 = fmul double %1, %1
  %5 = fmul double %4, 5.000000e-01
  %6 = fsub double 1.000000e+00, %5
  %7 = fsub double 1.000000e+00, %6
  %8 = fsub double %7, %5
  %9 = fmul double %4, %4
  %10 = tail call double @llvm.fma.f64(double %4, double 0xBDA907DB46CC5E42, double 0x3E21EEB69037AB78)
  %11 = tail call double @llvm.fma.f64(double %4, double %10, double 0xBE927E4FA17F65F6)
  %12 = tail call double @llvm.fma.f64(double %4, double %11, double 0x3EFA01A019F4EC90)
  %13 = tail call double @llvm.fma.f64(double %4, double %12, double 0xBF56C16C16C16967)
  %14 = tail call double @llvm.fma.f64(double %4, double %13, double 0x3FA5555555555555)
  %15 = fneg double %2
  %16 = tail call double @llvm.fma.f64(double %1, double %15, double %8)
  %17 = tail call double @llvm.fma.f64(double %9, double %14, double %16)
  %18 = fadd double %6, %17
  %19 = tail call double @llvm.fma.f64(double %4, double 0x3DE5E0B2F9A43BB8, double 0xBE5AE600B42FDFA7)
  %20 = tail call double @llvm.fma.f64(double %4, double %19, double 0x3EC71DE3796CDE01)
  %21 = tail call double @llvm.fma.f64(double %4, double %20, double 0xBF2A01A019E83E5C)
  %22 = tail call double @llvm.fma.f64(double %4, double %21, double 0x3F81111111110BB3)
  %23 = fneg double %4
  %24 = fmul double %23, %1
  %25 = fmul double %2, 5.000000e-01
  %26 = tail call double @llvm.fma.f64(double %24, double %22, double %25)
  %27 = tail call double @llvm.fma.f64(double %4, double %26, double %15)
  %28 = tail call double @llvm.fma.f64(double %24, double 0xBFC5555555555555, double %27)
  %29 = fsub double %1, %28
  %30 = getelementptr inbounds %struct.scret, ptr %0, i64 0, i32 1
  store double %18, ptr %30, align 8, !tbaa !35
  store double %29, ptr %0, align 8, !tbaa !37
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_trigredsmall_f64(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.redret) align 8 %0, double noundef %1) local_unnamed_addr #29 {
  %3 = fmul double %1, 0x3FE45F306DC9C883
  %4 = tail call double @llvm.rint.f64(double %3)
  %5 = tail call double @llvm.fma.f64(double %4, double 0xBFF921FB54442D18, double %1)
  %6 = tail call double @llvm.fma.f64(double %4, double 0xBC91A62633145C00, double %5)
  %7 = fmul double %4, 0x3C91A62633145C00
  %8 = fneg double %7
  %9 = tail call double @llvm.fma.f64(double %4, double 0x3C91A62633145C00, double %8)
  %10 = fsub double %5, %7
  %11 = fsub double %5, %10
  %12 = fsub double %11, %7
  %13 = fsub double %10, %6
  %14 = fadd double %13, %12
  %15 = fsub double %14, %9
  %16 = tail call double @llvm.fma.f64(double %4, double 0xB97B839A252049C0, double %15)
  %17 = fadd double %6, %16
  %18 = fsub double %17, %6
  %19 = fsub double %16, %18
  %20 = getelementptr inbounds %struct.redret, ptr %0, i64 0, i32 1
  store double %17, ptr %20, align 8, !tbaa !31
  store double %19, ptr %0, align 8, !tbaa !33
  %21 = fptosi double %4 to i32
  %22 = and i32 %21, 3
  %23 = getelementptr inbounds %struct.redret, ptr %0, i64 0, i32 2
  store i32 %22, ptr %23, align 8, !tbaa !34
  ret void
}

; Function Attrs: convergent mustprogress norecurse nounwind willreturn memory(argmem: readwrite)
define protected spir_func void @__ocmlpriv_trigredlarge_f64(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.redret) align 8 %0, double noundef %1) local_unnamed_addr #28 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  store i32 0, ptr %5, align 4, !tbaa !4
  %6 = addrspacecast ptr %5 to ptr addrspace(4)
  %7 = call spir_func double @_Z5frexpdPU3AS4i(double noundef %1, ptr addrspace(4) noundef %6) #40
  %8 = load i32, ptr %5, align 4, !tbaa !4
  %9 = icmp sgt i32 %8, 1077
  %10 = add nsw i32 %8, -1077
  %11 = select i1 %9, i32 %10, i32 0
  %12 = lshr i32 %11, 3
  %13 = zext nneg i32 %12 to i64
  %14 = getelementptr inbounds i8, ptr addrspace(1) @PIBITS_TBL, i64 %13
  %15 = addrspacecast ptr addrspace(1) %14 to ptr addrspace(4)
  %16 = load i64, ptr addrspace(4) %15, align 8, !tbaa !12
  %17 = icmp sgt i32 %8, 1967
  %18 = select i1 %17, i32 75, i32 -53
  %19 = sub i32 %18, %11
  %20 = and i64 %16, 9007199254740991
  %21 = bitcast i64 %20 to double
  %22 = call spir_func double @_Z5ldexpdi(double noundef %21, i32 noundef %19) #38
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  store i32 0, ptr %4, align 4, !tbaa !4
  %23 = addrspacecast ptr %4 to ptr addrspace(4)
  %24 = call spir_func double @_Z5frexpdPU3AS4i(double noundef %1, ptr addrspace(4) noundef %23) #40
  %25 = load i32, ptr %4, align 4, !tbaa !4
  %26 = icmp sgt i32 %25, 1077
  %27 = add nsw i32 %25, -1024
  %28 = select i1 %26, i32 %27, i32 53
  %29 = lshr i32 %28, 3
  %30 = zext nneg i32 %29 to i64
  %31 = getelementptr inbounds i8, ptr addrspace(1) @PIBITS_TBL, i64 %30
  %32 = addrspacecast ptr addrspace(1) %31 to ptr addrspace(4)
  %33 = load i64, ptr addrspace(4) %32, align 8, !tbaa !12
  %34 = icmp sgt i32 %25, 1967
  %35 = select i1 %34, i32 75, i32 -53
  %36 = sub i32 %35, %28
  %37 = and i64 %33, 9007199254740991
  %38 = bitcast i64 %37 to double
  %39 = call spir_func double @_Z5ldexpdi(double noundef %38, i32 noundef %36) #38
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  store i32 0, ptr %3, align 4, !tbaa !4
  %40 = addrspacecast ptr %3 to ptr addrspace(4)
  %41 = call spir_func double @_Z5frexpdPU3AS4i(double noundef %1, ptr addrspace(4) noundef %40) #40
  %42 = load i32, ptr %3, align 4, !tbaa !4
  %43 = icmp sgt i32 %42, 1077
  %44 = add nsw i32 %42, -971
  %45 = select i1 %43, i32 %44, i32 106
  %46 = lshr i32 %45, 3
  %47 = zext nneg i32 %46 to i64
  %48 = getelementptr inbounds i8, ptr addrspace(1) @PIBITS_TBL, i64 %47
  %49 = addrspacecast ptr addrspace(1) %48 to ptr addrspace(4)
  %50 = load i64, ptr addrspace(4) %49, align 8, !tbaa !12
  %51 = icmp sgt i32 %42, 1967
  %52 = select i1 %51, i32 75, i32 -53
  %53 = sub nsw i32 %52, %45
  %54 = and i64 %50, 9007199254740991
  %55 = bitcast i64 %54 to double
  %56 = call spir_func double @_Z5ldexpdi(double noundef %55, i32 noundef %53) #38
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %57 = fcmp ult double %1, 0x7B00000000000000
  br i1 %57, label %60, label %58

58:                                               ; preds = %2
  %59 = call spir_func double @_Z5ldexpdi(double noundef %1, i32 noundef -128) #38
  br label %60

60:                                               ; preds = %2, %58
  %61 = phi double [ %59, %58 ], [ %1, %2 ]
  %62 = fmul double %56, %61
  %63 = fneg double %62
  %64 = call double @llvm.fma.f64(double %56, double %61, double %63)
  %65 = fmul double %39, %61
  %66 = fneg double %65
  %67 = call double @llvm.fma.f64(double %39, double %61, double %66)
  %68 = fmul double %22, %61
  %69 = fneg double %68
  %70 = call double @llvm.fma.f64(double %22, double %61, double %69)
  %71 = fadd double %65, %70
  %72 = fsub double %71, %65
  %73 = fsub double %71, %72
  %74 = fsub double %70, %72
  %75 = fsub double %65, %73
  %76 = fadd double %74, %75
  %77 = fadd double %62, %67
  %78 = fsub double %77, %62
  %79 = fsub double %77, %78
  %80 = fsub double %67, %78
  %81 = fsub double %62, %79
  %82 = fadd double %80, %81
  %83 = fadd double %77, %76
  %84 = fsub double %83, %77
  %85 = fsub double %83, %84
  %86 = fsub double %76, %84
  %87 = fsub double %77, %85
  %88 = fadd double %86, %87
  %89 = fadd double %82, %88
  %90 = fadd double %64, %89
  %91 = fadd double %68, %71
  %92 = fsub double %91, %68
  %93 = fsub double %71, %92
  %94 = fadd double %93, %83
  %95 = fsub double %94, %93
  %96 = fsub double %83, %95
  %97 = fadd double %96, %90
  %98 = call spir_func double @_Z5ldexpdi(double noundef %91, i32 noundef -2) #38
  %99 = fptosi double %98 to i64
  %100 = sitofp i64 %99 to double
  %101 = fsub double %98, %100
  %102 = call double @llvm.fabs.f64(double %98)
  %103 = bitcast double %102 to i64
  %104 = icmp eq i64 %103, 9218868437227405312
  %105 = select i1 %104, double 0.000000e+00, double %101
  %106 = call spir_func double @_Z5ldexpdi(double noundef %105, i32 noundef 2) #38
  %107 = fadd double %106, %94
  %108 = fcmp olt double %107, 0.000000e+00
  %109 = select i1 %108, double 4.000000e+00, double 0.000000e+00
  %110 = fadd double %106, %109
  %111 = fadd double %94, %110
  %112 = fptosi double %111 to i32
  %113 = sitofp i32 %112 to double
  %114 = fsub double %110, %113
  %115 = fadd double %94, %114
  %116 = fsub double %115, %114
  %117 = fsub double %94, %116
  %118 = fadd double %97, %117
  %119 = fcmp oge double %115, 5.000000e-01
  %120 = zext i1 %119 to i32
  %121 = add nsw i32 %120, %112
  %122 = select i1 %119, double 1.000000e+00, double 0.000000e+00
  %123 = fsub double %115, %122
  %124 = fadd double %123, %118
  %125 = fsub double %124, %123
  %126 = fsub double %118, %125
  %127 = fmul double %124, 0x3FF921FB54442D18
  %128 = fneg double %127
  %129 = call double @llvm.fma.f64(double %124, double 0x3FF921FB54442D18, double %128)
  %130 = call double @llvm.fma.f64(double %124, double 0x3C91A62633145C07, double %129)
  %131 = call double @llvm.fma.f64(double %126, double 0x3FF921FB54442D18, double %130)
  %132 = fadd double %127, %131
  %133 = fsub double %132, %127
  %134 = fsub double %131, %133
  %135 = getelementptr inbounds %struct.redret, ptr %0, i64 0, i32 1
  store double %132, ptr %135, align 8, !tbaa !31
  store double %134, ptr %0, align 8, !tbaa !33
  %136 = and i32 %121, 3
  %137 = getelementptr inbounds %struct.redret, ptr %0, i64 0, i32 2
  store i32 %136, ptr %137, align 8, !tbaa !34
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.rint.f64(double) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_ccos_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x float> %0, i64 1
  %3 = fneg float %2
  %4 = insertelement <2 x float> poison, float %3, i64 0
  %5 = shufflevector <2 x float> %4, <2 x float> %0, <2 x i32> <i32 0, i32 2>
  %6 = tail call spir_func <2 x float> @__ocml_ccosh_f32(<2 x float> noundef %5) #38
  ret <2 x float> %6
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_ccosh_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca float, align 4
  %4 = extractelement <2 x float> %0, i64 0
  %5 = tail call float @llvm.fabs.f32(float %4)
  %6 = fadd float %5, 0xBFF62E4300000000
  %7 = fsub float %6, %5
  %8 = fsub float %7, %6
  %9 = fadd float %5, %8
  %10 = fadd float %7, 0x3FF62E4300000000
  %11 = fsub float %9, %10
  %12 = fadd float %11, 0x3E305C6100000000
  %13 = fadd float %6, %12
  %14 = fsub float %6, %13
  %15 = fadd float %12, %14
  %16 = insertelement <2 x float> poison, float %15, i64 0
  %17 = insertelement <2 x float> %16, float %13, i64 1
  %18 = tail call spir_func <2 x float> @__ocmlpriv_epexpep_f32(<2 x float> noundef %17) #38
  %19 = extractelement <2 x float> %18, i64 1
  %20 = tail call spir_func float @_Z12native_recipf(float noundef %19) #38
  %21 = fmul float %19, %20
  %22 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %23 = freeze i32 %22
  %24 = icmp sgt i32 %23, 8999
  br i1 %24, label %25, label %30

25:                                               ; preds = %1
  %26 = fneg float %21
  %27 = tail call float @llvm.fma.f32(float %20, float %19, float %26)
  %28 = insertelement <2 x float> poison, float %27, i64 0
  %29 = insertelement <2 x float> %28, float %21, i64 1
  br label %52

30:                                               ; preds = %1
  switch i32 %23, label %31 [
    i32 8001, label %45
    i32 7001, label %45
  ]

31:                                               ; preds = %30
  %32 = bitcast float %20 to i32
  %33 = and i32 %32, -4096
  %34 = bitcast i32 %33 to float
  %35 = fsub float %20, %34
  %36 = bitcast float %19 to i32
  %37 = and i32 %36, -4096
  %38 = bitcast i32 %37 to float
  %39 = fsub float %19, %38
  %40 = fneg float %21
  %41 = tail call float @llvm.fmuladd.f32(float %34, float %38, float %40)
  %42 = tail call float @llvm.fmuladd.f32(float %34, float %39, float %41)
  %43 = tail call float @llvm.fmuladd.f32(float %35, float %38, float %42)
  %44 = tail call float @llvm.fmuladd.f32(float %35, float %39, float %43)
  br label %48

45:                                               ; preds = %30, %30
  %46 = fneg float %21
  %47 = tail call float @llvm.fma.f32(float %20, float %19, float %46)
  br label %48

48:                                               ; preds = %45, %31
  %49 = phi float [ %47, %45 ], [ %44, %31 ]
  %50 = insertelement <2 x float> poison, float %49, i64 0
  %51 = insertelement <2 x float> %50, float %21, i64 1
  switch i32 %23, label %58 [
    i32 8001, label %52
    i32 7001, label %52
  ]

52:                                               ; preds = %48, %48, %25
  %53 = phi <2 x float> [ %51, %48 ], [ %51, %48 ], [ %29, %25 ]
  %54 = phi float [ %49, %48 ], [ %49, %48 ], [ %27, %25 ]
  %55 = extractelement <2 x float> %18, i64 0
  %56 = tail call float @llvm.fma.f32(float %20, float %55, float %54)
  %57 = insertelement <2 x float> %53, float %56, i64 0
  br label %62

58:                                               ; preds = %48
  %59 = extractelement <2 x float> %18, i64 0
  %60 = tail call float @llvm.fmuladd.f32(float %20, float %59, float %49)
  %61 = insertelement <2 x float> %51, float %60, i64 0
  br label %62

62:                                               ; preds = %58, %52
  %63 = phi <2 x float> [ %57, %52 ], [ %61, %58 ]
  %64 = extractelement <2 x float> %63, i64 1
  %65 = extractelement <2 x float> %63, i64 0
  %66 = fadd float %64, %65
  %67 = fsub float %66, %64
  %68 = fsub float 1.000000e+00, %66
  %69 = fsub float 1.000000e+00, %68
  %70 = fsub float %69, %66
  %71 = fsub float %67, %65
  %72 = fadd float %71, %70
  %73 = fadd float %68, %72
  %74 = fmul float %20, %73
  %75 = fmul float %19, %74
  br i1 %24, label %76, label %81

76:                                               ; preds = %62
  %77 = fneg float %75
  %78 = tail call float @llvm.fma.f32(float %74, float %19, float %77)
  %79 = insertelement <2 x float> poison, float %78, i64 0
  %80 = insertelement <2 x float> %79, float %75, i64 1
  br label %103

81:                                               ; preds = %62
  switch i32 %23, label %82 [
    i32 8001, label %96
    i32 7001, label %96
  ]

82:                                               ; preds = %81
  %83 = bitcast float %74 to i32
  %84 = and i32 %83, -4096
  %85 = bitcast i32 %84 to float
  %86 = fsub float %74, %85
  %87 = bitcast float %19 to i32
  %88 = and i32 %87, -4096
  %89 = bitcast i32 %88 to float
  %90 = fsub float %19, %89
  %91 = fneg float %75
  %92 = tail call float @llvm.fmuladd.f32(float %85, float %89, float %91)
  %93 = tail call float @llvm.fmuladd.f32(float %85, float %90, float %92)
  %94 = tail call float @llvm.fmuladd.f32(float %86, float %89, float %93)
  %95 = tail call float @llvm.fmuladd.f32(float %86, float %90, float %94)
  br label %99

96:                                               ; preds = %81, %81
  %97 = fneg float %75
  %98 = tail call float @llvm.fma.f32(float %74, float %19, float %97)
  br label %99

99:                                               ; preds = %96, %82
  %100 = phi float [ %98, %96 ], [ %95, %82 ]
  %101 = insertelement <2 x float> poison, float %100, i64 0
  %102 = insertelement <2 x float> %101, float %75, i64 1
  switch i32 %23, label %109 [
    i32 8001, label %103
    i32 7001, label %103
  ]

103:                                              ; preds = %99, %99, %76
  %104 = phi <2 x float> [ %102, %99 ], [ %102, %99 ], [ %80, %76 ]
  %105 = phi float [ %100, %99 ], [ %100, %99 ], [ %78, %76 ]
  %106 = extractelement <2 x float> %18, i64 0
  %107 = tail call float @llvm.fma.f32(float %74, float %106, float %105)
  %108 = insertelement <2 x float> %104, float %107, i64 0
  br label %113

109:                                              ; preds = %99
  %110 = extractelement <2 x float> %18, i64 0
  %111 = tail call float @llvm.fmuladd.f32(float %74, float %110, float %100)
  %112 = insertelement <2 x float> %102, float %111, i64 0
  br label %113

113:                                              ; preds = %103, %109
  %114 = phi float [ %106, %103 ], [ %110, %109 ]
  %115 = phi <2 x float> [ %108, %103 ], [ %112, %109 ]
  %116 = fsub float %68, %73
  %117 = fadd float %72, %116
  %118 = extractelement <2 x float> %115, i64 1
  %119 = extractelement <2 x float> %115, i64 0
  %120 = fadd float %118, %119
  %121 = fsub float %120, %118
  %122 = fsub float %73, %120
  %123 = fsub float %73, %122
  %124 = fsub float %123, %120
  %125 = fadd float %117, %124
  %126 = fsub float %121, %119
  %127 = fadd float %126, %125
  %128 = fadd float %122, %127
  %129 = fmul float %20, %128
  %130 = fadd float %20, %74
  %131 = fsub float %130, %20
  %132 = fsub float %74, %131
  %133 = fadd float %132, %129
  %134 = fadd float %130, %133
  %135 = fsub float %134, %130
  %136 = fsub float %133, %135
  %137 = tail call spir_func float @_Z5ldexpfi(float noundef %134, i32 noundef -4) #38
  %138 = tail call spir_func float @_Z5ldexpfi(float noundef %136, i32 noundef -4) #38
  %139 = fadd float %19, %137
  %140 = fsub float %139, %19
  %141 = fsub float %137, %140
  %142 = fadd float %114, %138
  %143 = fadd float %142, %141
  %144 = fadd float %139, %143
  %145 = fsub float %19, %137
  %146 = fsub float %19, %145
  %147 = fsub float %146, %137
  %148 = fadd float %114, %147
  %149 = fsub float %148, %138
  %150 = fadd float %145, %149
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %151 = extractelement <2 x float> %0, i64 1
  %152 = call spir_func float @__ocml_sincos_f32(float noundef %151, ptr noundef nonnull %3) #40
  %153 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %154 = icmp eq i8 %153, 0
  %155 = fcmp oge float %5, 0x405686FC00000000
  %156 = and i1 %155, %154
  %157 = select i1 %156, float 0x7FF0000000000000, float %150
  %158 = select i1 %156, float 0x7FF0000000000000, float %144
  %159 = load float, ptr %3, align 4, !tbaa !16
  %160 = fmul float %159, %158
  %161 = call spir_func float @_Z5ldexpfi(float noundef %160, i32 noundef 1) #38
  %162 = fcmp oge float %5, 0x3F30000000000000
  %163 = select i1 %162, float %157, float %5
  %164 = call float @llvm.copysign.f32(float %163, float %4)
  %165 = fmul float %152, %164
  %166 = zext i1 %162 to i32
  %167 = call spir_func float @_Z5ldexpfi(float noundef %165, i32 noundef %166) #38
  br i1 %154, label %168, label %187

168:                                              ; preds = %113
  %169 = fcmp oeq float %4, 0.000000e+00
  %170 = fcmp oeq float %151, 0.000000e+00
  %171 = or i1 %169, %170
  %172 = call float @llvm.copysign.f32(float 0.000000e+00, float %151)
  %173 = select i1 %171, float %172, float %167
  %174 = fcmp une float %5, 0x7FF0000000000000
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %151, ptr %2, align 8, !tbaa !16
  %175 = addrspacecast ptr %2 to ptr addrspace(4)
  %176 = load i64, ptr addrspace(4) %175, align 8, !tbaa !12
  switch i64 %176, label %177 [
    i64 2139095040, label %183
    i64 -8388608, label %183
  ]

177:                                              ; preds = %168
  %178 = and i64 %176, 2143289344
  %179 = icmp eq i64 %178, 0
  %180 = and i64 %176, 4194303
  %181 = icmp ne i64 %180, 0
  %182 = and i1 %179, %181
  br label %183

183:                                              ; preds = %168, %168, %177
  %184 = phi i1 [ false, %168 ], [ false, %168 ], [ %182, %177 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %185 = or i1 %174, %184
  %186 = select i1 %185, float %161, float %5
  br label %187

187:                                              ; preds = %183, %113
  %188 = phi float [ %161, %113 ], [ %186, %183 ]
  %189 = phi float [ %167, %113 ], [ %173, %183 ]
  %190 = insertelement <2 x float> poison, float %188, i64 0
  %191 = insertelement <2 x float> %190, float %189, i64 1
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  ret <2 x float> %191
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocmlpriv_epexpep_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x float> %0, i64 1
  %3 = fmul float %2, 0x3FF7154760000000
  %4 = tail call float @llvm.rint.f32(float %3)
  %5 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %4, float noundef 0xBFE62E4000000000, float noundef %2) #38
  %6 = extractelement <2 x float> %0, i64 0
  %7 = fadd float %6, %5
  %8 = fsub float %7, %5
  %9 = fsub float %6, %8
  %10 = fmul float %4, 0x3EB7F78000000000
  %11 = fsub float %7, %10
  %12 = fsub float %7, %11
  %13 = fsub float %12, %10
  %14 = fadd float %9, %13
  %15 = fadd float %11, %14
  %16 = fsub float %15, %11
  %17 = fsub float %14, %16
  %18 = fmul float %4, 0x3DD473DE60000000
  %19 = fsub float %15, %18
  %20 = fsub float %15, %19
  %21 = fsub float %20, %18
  %22 = fadd float %17, %21
  %23 = fadd float %19, %22
  %24 = fsub float %23, %19
  %25 = fsub float %22, %24
  %26 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %23, float noundef 0x3F56850E40000000, float noundef 0x3F8123BCC0000000) #38
  %27 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %23, float noundef %26, float noundef 0x3FA555B980000000) #38
  %28 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %23, float noundef %27, float noundef 0x3FC55548E0000000) #38
  %29 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %23, float noundef %28, float noundef 0x3FDFFFFF80000000) #38
  %30 = fmul float %23, %23
  %31 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %32 = freeze i32 %31
  %33 = icmp sgt i32 %32, 8999
  br i1 %33, label %34, label %39

34:                                               ; preds = %1
  %35 = fneg float %30
  %36 = tail call float @llvm.fma.f32(float %23, float %23, float %35)
  %37 = insertelement <2 x float> poison, float %36, i64 0
  %38 = insertelement <2 x float> %37, float %30, i64 1
  br label %64

39:                                               ; preds = %1
  switch i32 %32, label %40 [
    i32 8001, label %50
    i32 7001, label %50
  ]

40:                                               ; preds = %39
  %41 = bitcast float %23 to i32
  %42 = and i32 %41, -4096
  %43 = bitcast i32 %42 to float
  %44 = fsub float %23, %43
  %45 = fneg float %30
  %46 = tail call float @llvm.fmuladd.f32(float %43, float %43, float %45)
  %47 = fmul float %43, 2.000000e+00
  %48 = tail call float @llvm.fmuladd.f32(float %47, float %44, float %46)
  %49 = tail call float @llvm.fmuladd.f32(float %44, float %44, float %48)
  br label %53

50:                                               ; preds = %39, %39
  %51 = fneg float %30
  %52 = tail call float @llvm.fma.f32(float %23, float %23, float %51)
  br label %53

53:                                               ; preds = %50, %40
  %54 = phi float [ %52, %50 ], [ %49, %40 ]
  %55 = insertelement <2 x float> poison, float %54, i64 0
  %56 = insertelement <2 x float> %55, float %30, i64 1
  switch i32 %32, label %57 [
    i32 8001, label %64
    i32 7001, label %64
  ]

57:                                               ; preds = %53
  %58 = fmul float %25, 2.000000e+00
  %59 = tail call float @llvm.fmuladd.f32(float %58, float %23, float %54)
  %60 = fadd float %30, %59
  %61 = fsub float %60, %30
  %62 = fsub float %59, %61
  %63 = fmul float %29, %60
  br label %79

64:                                               ; preds = %34, %53, %53
  %65 = phi <2 x float> [ %56, %53 ], [ %56, %53 ], [ %38, %34 ]
  %66 = phi float [ %54, %53 ], [ %54, %53 ], [ %36, %34 ]
  %67 = fmul float %25, 2.000000e+00
  %68 = tail call float @llvm.fma.f32(float %23, float %67, float %66)
  %69 = extractelement <2 x float> %65, i64 1
  %70 = fadd float %69, %68
  %71 = fsub float %70, %69
  %72 = fsub float %68, %71
  %73 = fmul float %29, %70
  br i1 %33, label %74, label %79

74:                                               ; preds = %64
  %75 = fneg float %73
  %76 = tail call float @llvm.fma.f32(float %70, float %29, float %75)
  %77 = insertelement <2 x float> poison, float %76, i64 0
  %78 = insertelement <2 x float> %77, float %73, i64 1
  br label %104

79:                                               ; preds = %57, %64
  %80 = phi float [ %63, %57 ], [ %73, %64 ]
  %81 = phi float [ %62, %57 ], [ %72, %64 ]
  %82 = phi float [ %60, %57 ], [ %70, %64 ]
  switch i32 %32, label %83 [
    i32 8001, label %97
    i32 7001, label %97
  ]

83:                                               ; preds = %79
  %84 = bitcast float %82 to i32
  %85 = and i32 %84, -4096
  %86 = bitcast i32 %85 to float
  %87 = fsub float %82, %86
  %88 = bitcast float %29 to i32
  %89 = and i32 %88, -4096
  %90 = bitcast i32 %89 to float
  %91 = fsub float %29, %90
  %92 = fneg float %80
  %93 = tail call float @llvm.fmuladd.f32(float %86, float %90, float %92)
  %94 = tail call float @llvm.fmuladd.f32(float %86, float %91, float %93)
  %95 = tail call float @llvm.fmuladd.f32(float %87, float %90, float %94)
  %96 = tail call float @llvm.fmuladd.f32(float %87, float %91, float %95)
  br label %100

97:                                               ; preds = %79, %79
  %98 = fneg float %80
  %99 = tail call float @llvm.fma.f32(float %82, float %29, float %98)
  br label %100

100:                                              ; preds = %97, %83
  %101 = phi float [ %99, %97 ], [ %96, %83 ]
  %102 = insertelement <2 x float> poison, float %101, i64 0
  %103 = insertelement <2 x float> %102, float %80, i64 1
  switch i32 %32, label %110 [
    i32 8001, label %104
    i32 7001, label %104
  ]

104:                                              ; preds = %100, %100, %74
  %105 = phi float [ %81, %100 ], [ %81, %100 ], [ %72, %74 ]
  %106 = phi <2 x float> [ %103, %100 ], [ %103, %100 ], [ %78, %74 ]
  %107 = phi float [ %101, %100 ], [ %101, %100 ], [ %76, %74 ]
  %108 = tail call float @llvm.fma.f32(float %105, float %29, float %107)
  %109 = insertelement <2 x float> %106, float %108, i64 0
  br label %113

110:                                              ; preds = %100
  %111 = tail call float @llvm.fmuladd.f32(float %81, float %29, float %101)
  %112 = insertelement <2 x float> %103, float %111, i64 0
  br label %113

113:                                              ; preds = %104, %110
  %114 = phi <2 x float> [ %109, %104 ], [ %112, %110 ]
  %115 = extractelement <2 x float> %114, i64 1
  %116 = extractelement <2 x float> %114, i64 0
  %117 = fadd float %115, %116
  %118 = fsub float %117, %115
  %119 = fsub float %116, %118
  %120 = fadd float %23, %117
  %121 = fsub float %120, %23
  %122 = fsub float %117, %121
  %123 = fadd float %25, %119
  %124 = fadd float %123, %122
  %125 = fadd float %120, %124
  %126 = fsub float %125, %120
  %127 = fsub float %124, %126
  %128 = fadd float %125, 1.000000e+00
  %129 = fadd float %128, -1.000000e+00
  %130 = fsub float %125, %129
  %131 = fadd float %127, %130
  %132 = fadd float %128, %131
  %133 = fsub float %132, %128
  %134 = fsub float %131, %133
  %135 = fptosi float %4 to i32
  %136 = tail call spir_func float @_Z5ldexpfi(float noundef %132, i32 noundef %135) #38
  %137 = tail call spir_func float @_Z5ldexpfi(float noundef %134, i32 noundef %135) #38
  %138 = insertelement <2 x float> poison, float %137, i64 0
  %139 = insertelement <2 x float> %138, float %136, i64 1
  ret <2 x float> %139
}

; Function Attrs: convergent mustprogress norecurse nounwind willreturn memory(argmem: write)
define protected spir_func float @__ocml_sincos_f32(float noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #27 {
  %3 = alloca float, align 8
  %4 = alloca %struct.redret.0, align 4
  %5 = alloca %struct.scret.1, align 4
  %6 = tail call float @llvm.fabs.f32(float %0)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #39
  call spir_func void @__ocmlpriv_trigred_f32(ptr dead_on_unwind nonnull writable sret(%struct.redret.0) align 4 %4, float noundef %6) #43
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5) #39
  %7 = load float, ptr %4, align 4, !tbaa !38
  call spir_func void @__ocmlpriv_sincosred_f32(ptr dead_on_unwind nonnull writable sret(%struct.scret.1) align 4 %5, float noundef %7) #43
  %8 = getelementptr inbounds %struct.redret.0, ptr %4, i64 0, i32 1
  %9 = load i32, ptr %8, align 4, !tbaa !40
  %10 = icmp sgt i32 %9, 1
  %11 = select i1 %10, i32 -2147483648, i32 0
  %12 = and i32 %9, 1
  %13 = icmp eq i32 %12, 0
  %14 = getelementptr inbounds %struct.scret.1, ptr %5, i64 0, i32 1
  %15 = load float, ptr %14, align 4
  %16 = load float, ptr %5, align 4
  %17 = select i1 %13, float %16, float %15
  %18 = bitcast float %17 to i32
  %19 = bitcast float %6 to i32
  %20 = bitcast float %0 to i32
  %21 = xor i32 %19, %20
  %22 = xor i32 %21, %18
  %23 = xor i32 %22, %11
  %24 = bitcast i32 %23 to float
  %25 = fneg float %16
  %26 = select i1 %13, float %15, float %25
  %27 = bitcast float %26 to i32
  %28 = xor i32 %11, %27
  %29 = bitcast i32 %28 to float
  %30 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %32, label %47

32:                                               ; preds = %2
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %6, ptr %3, align 8, !tbaa !16
  %33 = addrspacecast ptr %3 to ptr addrspace(4)
  %34 = load i64, ptr addrspace(4) %33, align 8, !tbaa !12
  %35 = and i64 %34, 2147483647
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %37, label %38

37:                                               ; preds = %32
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br label %47

38:                                               ; preds = %32
  %39 = and i64 %34, 2139095040
  %40 = icmp ne i64 %39, 0
  %41 = and i64 %34, 8388607
  %42 = icmp eq i64 %41, 0
  %43 = or i1 %40, %42
  %44 = freeze i1 %43
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %45 = select i1 %44, float 0x7FF8000000000000, float %29
  %46 = select i1 %44, float 0x7FF8000000000000, float %24
  br label %47

47:                                               ; preds = %38, %37, %2
  %48 = phi float [ %29, %2 ], [ %29, %37 ], [ %45, %38 ]
  %49 = phi float [ %24, %2 ], [ %24, %37 ], [ %46, %38 ]
  store float %48, ptr %1, align 4, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5) #39
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #39
  ret float %49
}

; Function Attrs: convergent mustprogress norecurse nounwind willreturn memory(argmem: readwrite)
define protected spir_func void @__ocmlpriv_trigred_f32(ptr dead_on_unwind noalias writable sret(%struct.redret.0) align 4 %0, float noundef %1) local_unnamed_addr #28 {
  %3 = fcmp olt float %1, 1.310720e+05
  br i1 %3, label %4, label %5

4:                                                ; preds = %2
  tail call spir_func void @__ocmlpriv_trigredsmall_f32(ptr dead_on_unwind writable sret(%struct.redret.0) align 4 %0, float noundef %1) #43
  br label %6

5:                                                ; preds = %2
  tail call spir_func void @__ocmlpriv_trigredlarge_f32(ptr dead_on_unwind writable sret(%struct.redret.0) align 4 %0, float noundef %1) #43
  br label %6

6:                                                ; preds = %5, %4
  ret void
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_sincosred_f32(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.scret.1) align 4 %0, float noundef %1) local_unnamed_addr #30 {
  %3 = fmul float %1, %1
  %4 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef 0xBF29833040000000, float noundef 0x3F81103880000000) #38
  %5 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %4, float noundef 0xBFC55553A0000000) #38
  %6 = fmul float %3, %5
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %1, float noundef %6, float noundef %1) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef 0x3EFAEA6680000000, float noundef 0xBF56C9E760000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %8, float noundef 0x3FA5557EE0000000) #38
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %9, float noundef 0xBFE0000080000000) #38
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %10, float noundef 1.000000e+00) #38
  %12 = getelementptr inbounds %struct.scret.1, ptr %0, i64 0, i32 1
  store float %11, ptr %12, align 4, !tbaa !41
  store float %7, ptr %0, align 4, !tbaa !43
  ret void
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_trigredsmall_f32(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.redret.0) align 4 %0, float noundef %1) local_unnamed_addr #30 {
  %3 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %4 = freeze i32 %3
  %5 = icmp sgt i32 %4, 8999
  br i1 %5, label %7, label %6

6:                                                ; preds = %2
  switch i32 %4, label %13 [
    i32 8001, label %7
    i32 7001, label %7
  ]

7:                                                ; preds = %6, %6, %2
  %8 = fmul float %1, 0x3FE45F3060000000
  %9 = tail call float @llvm.rint.f32(float %8)
  %10 = tail call float @llvm.fma.f32(float %9, float 0xBFF921FB40000000, float %1)
  %11 = tail call float @llvm.fma.f32(float %9, float 0xBE74442D00000000, float %10)
  %12 = tail call float @llvm.fma.f32(float %9, float 0xBCF8469880000000, float %11)
  br label %43

13:                                               ; preds = %6
  %14 = fmul float %1, 0x3FE45F3060000000
  %15 = tail call float @llvm.rint.f32(float %14)
  %16 = bitcast float %15 to i32
  %17 = and i32 %16, -4096
  %18 = bitcast i32 %17 to float
  %19 = fsub float %15, %18
  %20 = fmul float %15, 0x3FF921FB40000000
  %21 = fneg float %20
  %22 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %18, float noundef 0x3FF9200000000000, float noundef %21) #38
  %23 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %18, float noundef 0x3F3FB40000000000, float noundef %22) #38
  %24 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef 0x3FF9200000000000, float noundef %23) #38
  %25 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef 0x3F3FB40000000000, float noundef %24) #38
  %26 = fsub float %1, %20
  %27 = fsub float %1, %26
  %28 = fsub float %27, %20
  %29 = fsub float %28, %25
  %30 = fadd float %26, %29
  %31 = fmul float %15, 0x3E74442D00000000
  %32 = fneg float %31
  %33 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %18, float noundef 0x3E74440000000000, float noundef %32) #38
  %34 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %18, float noundef 0x3D86800000000000, float noundef %33) #38
  %35 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef 0x3E74440000000000, float noundef %34) #38
  %36 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef 0x3D86800000000000, float noundef %35) #38
  %37 = fsub float %30, %31
  %38 = fsub float %30, %37
  %39 = fsub float %38, %31
  %40 = fsub float %39, %36
  %41 = fadd float %37, %40
  %42 = tail call spir_func float @__ocml_fmuladd_f32(float noundef 0xBCF8469880000000, float noundef %15, float noundef %41) #38
  br label %43

43:                                               ; preds = %13, %7
  %44 = phi float [ %42, %13 ], [ %12, %7 ]
  %45 = phi float [ %15, %13 ], [ %9, %7 ]
  store float %44, ptr %0, align 4, !tbaa !38
  %46 = fptosi float %45 to i32
  %47 = and i32 %46, 3
  %48 = getelementptr inbounds %struct.redret.0, ptr %0, i64 0, i32 1
  store i32 %47, ptr %48, align 4, !tbaa !40
  ret void
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_trigredlarge_f32(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.redret.0) align 4 %0, float noundef %1) local_unnamed_addr #30 {
  %3 = bitcast float %1 to i32
  %4 = lshr i32 %3, 23
  %5 = and i32 %3, 8388607
  %6 = or disjoint i32 %5, 8388608
  %7 = zext nneg i32 %6 to i64
  %8 = mul nuw nsw i64 %7, 4266746795
  %9 = trunc i64 %8 to i32
  %10 = lshr i64 %8, 32
  %11 = mul nuw nsw i64 %7, 1011060801
  %12 = add nuw nsw i64 %10, %11
  %13 = trunc i64 %12 to i32
  %14 = lshr i64 %12, 32
  %15 = mul nuw nsw i64 %7, 3680671129
  %16 = add nuw nsw i64 %14, %15
  %17 = trunc i64 %16 to i32
  %18 = lshr i64 %16, 32
  %19 = mul nuw nsw i64 %7, 4113882560
  %20 = add nuw nsw i64 %18, %19
  %21 = trunc i64 %20 to i32
  %22 = lshr i64 %20, 32
  %23 = mul nuw nsw i64 %7, 4230436817
  %24 = add nuw nsw i64 %22, %23
  %25 = trunc i64 %24 to i32
  %26 = lshr i64 %24, 32
  %27 = mul nuw nsw i64 %7, 1313084713
  %28 = add nuw nsw i64 %26, %27
  %29 = trunc i64 %28 to i32
  %30 = lshr i64 %28, 32
  %31 = mul nuw nsw i64 %7, 2734261102
  %32 = add nuw nsw i64 %30, %31
  %33 = trunc i64 %32 to i32
  %34 = lshr i64 %32, 32
  %35 = trunc i64 %34 to i32
  %36 = add nsw i32 %4, -120
  %37 = icmp ugt i32 %36, 63
  %38 = select i1 %37, i32 %29, i32 %35
  %39 = select i1 %37, i32 %25, i32 %33
  %40 = select i1 %37, i32 %21, i32 %29
  %41 = select i1 %37, i32 %17, i32 %25
  %42 = select i1 %37, i32 %13, i32 %21
  %43 = select i1 %37, i32 %9, i32 %17
  %44 = select i1 %37, i32 -64, i32 0
  %45 = add nsw i32 %44, %36
  %46 = icmp ugt i32 %45, 31
  %47 = select i1 %46, i32 %39, i32 %38
  %48 = select i1 %46, i32 %40, i32 %39
  %49 = select i1 %46, i32 %41, i32 %40
  %50 = select i1 %46, i32 %42, i32 %41
  %51 = select i1 %46, i32 %43, i32 %42
  %52 = select i1 %46, i32 -32, i32 0
  %53 = add nsw i32 %52, %45
  %54 = icmp ugt i32 %53, 31
  %55 = select i1 %54, i32 %48, i32 %47
  %56 = select i1 %54, i32 %49, i32 %48
  %57 = select i1 %54, i32 %50, i32 %49
  %58 = select i1 %54, i32 %51, i32 %50
  %59 = select i1 %54, i32 -32, i32 0
  %60 = sub nsw i32 0, %53
  %61 = icmp eq i32 %59, %60
  %62 = sub nsw i32 24, %4
  %63 = and i32 %36, 31
  %64 = shl i32 %55, %63
  %65 = and i32 %62, 31
  %66 = lshr i32 %56, %65
  %67 = or i32 %64, %66
  %68 = shl i32 %56, %63
  %69 = lshr i32 %57, %65
  %70 = or i32 %68, %69
  %71 = shl i32 %57, %63
  %72 = lshr i32 %58, %65
  %73 = or i32 %71, %72
  %74 = select i1 %61, i32 %55, i32 %67
  %75 = select i1 %61, i32 %56, i32 %70
  %76 = select i1 %61, i32 %57, i32 %73
  %77 = lshr i32 %74, 29
  %78 = tail call i32 @llvm.fshl.i32(i32 %74, i32 %75, i32 2)
  %79 = tail call i32 @llvm.fshl.i32(i32 %75, i32 %76, i32 2)
  %80 = tail call i32 @llvm.fshl.i32(i32 %76, i32 %58, i32 2)
  %81 = and i32 %77, 1
  %82 = sub nsw i32 0, %81
  %83 = shl i32 %77, 31
  %84 = xor i32 %78, %82
  %85 = xor i32 %79, %82
  %86 = xor i32 %80, %82
  %87 = tail call i32 @llvm.ctlz.i32(i32 %84, i1 false), !range !44
  %88 = add nuw nsw i32 %87, 1
  %89 = sub nsw i32 31, %87
  %90 = and i32 %88, 31
  %91 = shl i32 %84, %90
  %92 = and i32 %89, 31
  %93 = lshr i32 %85, %92
  %94 = or i32 %91, %93
  %95 = shl i32 %85, %90
  %96 = lshr i32 %86, %92
  %97 = or i32 %95, %96
  %98 = shl nuw nsw i32 %87, 23
  %99 = lshr i32 %94, 9
  %100 = sub nsw i32 %99, %98
  %101 = add nsw i32 %100, 1056964608
  %102 = add nuw nsw i32 %101, %83
  %103 = bitcast i32 %102 to float
  %104 = tail call i32 @llvm.fshl.i32(i32 %94, i32 %97, i32 23)
  %105 = tail call i32 @llvm.ctlz.i32(i32 %104, i1 false), !range !44
  %106 = add nuw nsw i32 %105, 1
  %107 = sub nsw i32 31, %105
  %108 = and i32 %106, 31
  %109 = shl i32 %104, %108
  %110 = and i32 %107, 31
  %111 = lshr i32 %97, %110
  %112 = or i32 %109, %111
  %113 = add nuw nsw i32 %105, %87
  %114 = shl nuw nsw i32 %113, 23
  %115 = lshr i32 %112, 9
  %116 = sub nsw i32 %115, %114
  %117 = add nsw i32 %116, 855638016
  %118 = or i32 %117, %83
  %119 = bitcast i32 %118 to float
  %120 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %121 = freeze i32 %120
  %122 = icmp sgt i32 %121, 8999
  br i1 %122, label %124, label %123

123:                                              ; preds = %2
  switch i32 %121, label %130 [
    i32 8001, label %124
    i32 7001, label %124
  ]

124:                                              ; preds = %123, %123, %2
  %125 = fmul float %103, 0x3FF921FB40000000
  %126 = fneg float %125
  %127 = tail call float @llvm.fma.f32(float %103, float 0x3FF921FB40000000, float %126)
  %128 = tail call float @llvm.fma.f32(float %103, float 0x3E74442D00000000, float %127)
  %129 = tail call float @llvm.fma.f32(float %119, float 0x3FF921FB40000000, float %128)
  br label %143

130:                                              ; preds = %123
  %131 = and i32 %102, -1073745920
  %132 = bitcast i32 %131 to float
  %133 = fsub float %103, %132
  %134 = fmul float %103, 0x3FF921FB40000000
  %135 = fneg float %134
  %136 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %132, float noundef 0x3FF9200000000000, float noundef %135) #38
  %137 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %132, float noundef 0x3F3FB40000000000, float noundef %136) #38
  %138 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %133, float noundef 0x3FF9200000000000, float noundef %137) #38
  %139 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %133, float noundef 0x3F3FB40000000000, float noundef %138) #38
  %140 = fmul float %103, 0x3E74442D00000000
  %141 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %119, float noundef 0x3FF921FB40000000, float noundef %140) #38
  %142 = fadd float %139, %141
  br label %143

143:                                              ; preds = %130, %124
  %144 = phi float [ %129, %124 ], [ %142, %130 ]
  %145 = phi float [ %125, %124 ], [ %134, %130 ]
  %146 = fadd float %144, %145
  store float %146, ptr %0, align 4, !tbaa !38
  %147 = lshr i32 %74, 30
  %148 = add nuw nsw i32 %81, %147
  %149 = and i32 %148, 3
  %150 = getelementptr inbounds %struct.redret.0, ptr %0, i64 0, i32 1
  store i32 %149, ptr %150, align 4, !tbaa !40
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.fshl.i32(i32, i32, i32) #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.ctlz.i32(i32, i1 immarg) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_cdiv_f64(<2 x double> noundef %0, <2 x double> noundef %1) local_unnamed_addr #21 {
  %3 = alloca double, align 8
  %4 = alloca double, align 8
  %5 = alloca double, align 8
  %6 = alloca double, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = extractelement <2 x double> %1, i64 0
  %10 = extractelement <2 x double> %1, i64 1
  %11 = tail call double @llvm.fabs.f64(double %9)
  %12 = tail call double @llvm.fabs.f64(double %10)
  %13 = fcmp ogt double %11, %12
  %14 = select i1 %13, double %9, double %10
  %15 = fptrunc double %14 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8) #39
  %16 = addrspacecast ptr %8 to ptr addrspace(4)
  %17 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %15, ptr addrspace(4) noundef %16) #40
  %18 = load i32, ptr %8, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8) #39
  %19 = extractelement <2 x double> %0, i64 0
  %20 = call double @llvm.fabs.f64(double %19)
  %21 = extractelement <2 x double> %0, i64 1
  %22 = call double @llvm.fabs.f64(double %21)
  %23 = call double @llvm.maxnum.f64(double %20, double %22)
  %24 = fptrunc double %23 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7) #39
  %25 = addrspacecast ptr %7 to ptr addrspace(4)
  %26 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %24, ptr addrspace(4) noundef %25) #40
  %27 = load i32, ptr %7, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7) #39
  %28 = sub nsw i32 1022, %18
  %29 = sub nsw i32 %28, %18
  %30 = sub nsw i32 %28, %27
  %31 = call i32 @llvm.smin.i32(i32 %28, i32 %29)
  %32 = call i32 @llvm.smin.i32(i32 %31, i32 %30)
  %33 = ashr i32 %32, 1
  %34 = call spir_func double @_Z5ldexpdi(double noundef %9, i32 noundef %33) #38
  %35 = call spir_func double @_Z5ldexpdi(double noundef %10, i32 noundef %33) #38
  %36 = select i1 %13, double %34, double %35
  %37 = select i1 %13, double %35, double %34
  %38 = fmul double %37, %37
  %39 = call double @llvm.fma.f64(double %36, double %36, double %38)
  %40 = call spir_func double @_Z5ldexpdi(double noundef %34, i32 noundef %33) #38
  %41 = call spir_func double @_Z5ldexpdi(double noundef %35, i32 noundef %33) #38
  %42 = fmul double %21, %41
  %43 = fneg double %42
  %44 = call double @llvm.fma.f64(double %21, double %41, double %43)
  %45 = call double @llvm.fma.f64(double %19, double %40, double %42)
  %46 = fadd double %45, %44
  %47 = fneg double %19
  %48 = fmul double %41, %47
  %49 = fneg double %48
  %50 = call double @llvm.fma.f64(double %47, double %41, double %49)
  %51 = call double @llvm.fma.f64(double %21, double %40, double %48)
  %52 = fadd double %51, %50
  %53 = fdiv double %46, %39
  %54 = fdiv double %52, %39
  %55 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %56 = icmp eq i8 %55, 0
  %57 = fcmp uno double %53, 0.000000e+00
  %58 = select i1 %56, i1 %57, i1 false
  %59 = fcmp uno double %54, 0.000000e+00
  %60 = select i1 %58, i1 %59, i1 false
  br i1 %60, label %61, label %150

61:                                               ; preds = %2
  %62 = fcmp oeq double %39, 0.000000e+00
  br i1 %62, label %63, label %71

63:                                               ; preds = %61
  %64 = fcmp uno double %19, 0.000000e+00
  %65 = fcmp uno double %21, 0.000000e+00
  %66 = and i1 %64, %65
  br i1 %66, label %71, label %67

67:                                               ; preds = %63
  %68 = call double @llvm.copysign.f64(double 0x7FF0000000000000, double %9)
  %69 = fmul double %19, %68
  %70 = fmul double %21, %68
  br label %150

71:                                               ; preds = %63, %61
  %72 = fcmp oeq double %20, 0x7FF0000000000000
  %73 = fcmp oeq double %22, 0x7FF0000000000000
  %74 = or i1 %72, %73
  br i1 %74, label %75, label %111

75:                                               ; preds = %71
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %6)
  store double %9, ptr %6, align 8, !tbaa !19
  %76 = addrspacecast ptr %6 to ptr addrspace(4)
  %77 = load i128, ptr addrspace(4) %76, align 8, !tbaa !29
  %78 = and i128 %77, 9223372036854775807
  %79 = icmp eq i128 %78, 0
  br i1 %79, label %80, label %81

80:                                               ; preds = %75
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %6)
  br label %87

81:                                               ; preds = %75
  %82 = and i128 %77, 9218868437227405312
  %83 = icmp ne i128 %82, 0
  %84 = and i128 %77, 4503599627370495
  %85 = icmp eq i128 %84, 0
  %86 = or i1 %83, %85
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %6)
  br i1 %86, label %111, label %87

87:                                               ; preds = %80, %81
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5)
  store double %10, ptr %5, align 8, !tbaa !19
  %88 = addrspacecast ptr %5 to ptr addrspace(4)
  %89 = load i128, ptr addrspace(4) %88, align 8, !tbaa !29
  %90 = and i128 %89, 9223372036854775807
  %91 = icmp eq i128 %90, 0
  br i1 %91, label %92, label %93

92:                                               ; preds = %87
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5)
  br label %99

93:                                               ; preds = %87
  %94 = and i128 %89, 9218868437227405312
  %95 = icmp ne i128 %94, 0
  %96 = and i128 %89, 4503599627370495
  %97 = icmp eq i128 %96, 0
  %98 = or i1 %95, %97
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5)
  br i1 %98, label %111, label %99

99:                                               ; preds = %92, %93
  %100 = select i1 %72, double 1.000000e+00, double 0.000000e+00
  %101 = call double @llvm.copysign.f64(double %100, double %19)
  %102 = select i1 %73, double 1.000000e+00, double 0.000000e+00
  %103 = call double @llvm.copysign.f64(double %102, double %21)
  %104 = fmul double %10, %103
  %105 = call double @llvm.fma.f64(double %101, double %9, double %104)
  %106 = fmul double %105, 0x7FF0000000000000
  %107 = fneg double %101
  %108 = fmul double %10, %107
  %109 = call double @llvm.fma.f64(double %103, double %9, double %108)
  %110 = fmul double %109, 0x7FF0000000000000
  br label %150

111:                                              ; preds = %71, %93, %81
  %112 = fcmp oeq double %11, 0x7FF0000000000000
  %113 = fcmp oeq double %12, 0x7FF0000000000000
  %114 = or i1 %112, %113
  br i1 %114, label %115, label %150

115:                                              ; preds = %111
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  store double %19, ptr %4, align 8, !tbaa !19
  %116 = addrspacecast ptr %4 to ptr addrspace(4)
  %117 = load i128, ptr addrspace(4) %116, align 8, !tbaa !29
  %118 = and i128 %117, 9223372036854775807
  %119 = icmp eq i128 %118, 0
  br i1 %119, label %120, label %121

120:                                              ; preds = %115
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  br label %127

121:                                              ; preds = %115
  %122 = and i128 %117, 9218868437227405312
  %123 = icmp ne i128 %122, 0
  %124 = and i128 %117, 4503599627370495
  %125 = icmp eq i128 %124, 0
  %126 = or i1 %123, %125
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  br i1 %126, label %150, label %127

127:                                              ; preds = %120, %121
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %21, ptr %3, align 8, !tbaa !19
  %128 = addrspacecast ptr %3 to ptr addrspace(4)
  %129 = load i128, ptr addrspace(4) %128, align 8, !tbaa !29
  %130 = and i128 %129, 9223372036854775807
  %131 = icmp eq i128 %130, 0
  br i1 %131, label %132, label %133

132:                                              ; preds = %127
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  br label %139

133:                                              ; preds = %127
  %134 = and i128 %129, 9218868437227405312
  %135 = icmp ne i128 %134, 0
  %136 = and i128 %129, 4503599627370495
  %137 = icmp eq i128 %136, 0
  %138 = or i1 %135, %137
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  br i1 %138, label %150, label %139

139:                                              ; preds = %132, %133
  %140 = select i1 %112, double 1.000000e+00, double 0.000000e+00
  %141 = call double @llvm.copysign.f64(double %140, double %9)
  %142 = select i1 %113, double 1.000000e+00, double 0.000000e+00
  %143 = call double @llvm.copysign.f64(double %142, double %10)
  %144 = fmul double %21, %143
  %145 = call double @llvm.fma.f64(double %19, double %141, double %144)
  %146 = fmul double %145, 0.000000e+00
  %147 = fmul double %143, %47
  %148 = call double @llvm.fma.f64(double %21, double %141, double %147)
  %149 = fmul double %148, 0.000000e+00
  br label %150

150:                                              ; preds = %111, %99, %139, %133, %121, %67, %2
  %151 = phi double [ %54, %2 ], [ %110, %99 ], [ %149, %139 ], [ %54, %133 ], [ %54, %121 ], [ %70, %67 ], [ %54, %111 ]
  %152 = phi double [ %53, %2 ], [ %106, %99 ], [ %146, %139 ], [ %53, %133 ], [ %53, %121 ], [ %69, %67 ], [ %53, %111 ]
  %153 = insertelement <2 x double> poison, double %152, i64 0
  %154 = insertelement <2 x double> %153, double %151, i64 1
  ret <2 x double> %154
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_cdiv_f32(<2 x float> noundef %0, <2 x float> noundef %1) local_unnamed_addr #21 {
  %3 = alloca float, align 8
  %4 = alloca float, align 8
  %5 = alloca float, align 8
  %6 = alloca float, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = extractelement <2 x float> %1, i64 0
  %10 = extractelement <2 x float> %1, i64 1
  %11 = tail call float @llvm.fabs.f32(float %9)
  %12 = tail call float @llvm.fabs.f32(float %10)
  %13 = fcmp ogt float %11, %12
  %14 = select i1 %13, float %9, float %10
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %8) #39
  %15 = addrspacecast ptr %8 to ptr addrspace(4)
  %16 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %14, ptr addrspace(4) noundef %15) #40
  %17 = load i32, ptr %8, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %8) #39
  %18 = extractelement <2 x float> %0, i64 0
  %19 = call float @llvm.fabs.f32(float %18)
  %20 = extractelement <2 x float> %0, i64 1
  %21 = call float @llvm.fabs.f32(float %20)
  %22 = call float @llvm.maxnum.f32(float %19, float %21)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7) #39
  %23 = addrspacecast ptr %7 to ptr addrspace(4)
  %24 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %22, ptr addrspace(4) noundef %23) #40
  %25 = load i32, ptr %7, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7) #39
  %26 = sub nsw i32 126, %17
  %27 = sub nsw i32 %26, %17
  %28 = sub nsw i32 %26, %25
  %29 = call i32 @llvm.smin.i32(i32 %26, i32 %27)
  %30 = call i32 @llvm.smin.i32(i32 %29, i32 %28)
  %31 = ashr i32 %30, 1
  %32 = call spir_func float @_Z5ldexpfi(float noundef %9, i32 noundef %31) #38
  %33 = call spir_func float @_Z5ldexpfi(float noundef %10, i32 noundef %31) #38
  %34 = select i1 %13, float %32, float %33
  %35 = select i1 %13, float %33, float %32
  %36 = fmul float %35, %35
  %37 = call float @llvm.fma.f32(float %34, float %34, float %36)
  %38 = call spir_func float @_Z5ldexpfi(float noundef %32, i32 noundef %31) #38
  %39 = call spir_func float @_Z5ldexpfi(float noundef %33, i32 noundef %31) #38
  %40 = fmul float %20, %39
  %41 = fneg float %40
  %42 = call float @llvm.fma.f32(float %20, float %39, float %41)
  %43 = call float @llvm.fma.f32(float %18, float %38, float %40)
  %44 = fadd float %43, %42
  %45 = fneg float %18
  %46 = fmul float %39, %45
  %47 = fneg float %46
  %48 = call float @llvm.fma.f32(float %45, float %39, float %47)
  %49 = call float @llvm.fma.f32(float %20, float %38, float %46)
  %50 = fadd float %49, %48
  %51 = fdiv float %44, %37, !fpmath !15
  %52 = fdiv float %50, %37, !fpmath !15
  %53 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %54 = icmp eq i8 %53, 0
  %55 = fcmp uno float %51, 0.000000e+00
  %56 = select i1 %54, i1 %55, i1 false
  %57 = fcmp uno float %52, 0.000000e+00
  %58 = select i1 %56, i1 %57, i1 false
  br i1 %58, label %59, label %148

59:                                               ; preds = %2
  %60 = fcmp oeq float %37, 0.000000e+00
  br i1 %60, label %61, label %69

61:                                               ; preds = %59
  %62 = fcmp uno float %18, 0.000000e+00
  %63 = fcmp uno float %20, 0.000000e+00
  %64 = and i1 %62, %63
  br i1 %64, label %69, label %65

65:                                               ; preds = %61
  %66 = call float @llvm.copysign.f32(float 0x7FF0000000000000, float %9)
  %67 = fmul float %18, %66
  %68 = fmul float %20, %66
  br label %148

69:                                               ; preds = %61, %59
  %70 = fcmp oeq float %19, 0x7FF0000000000000
  %71 = fcmp oeq float %21, 0x7FF0000000000000
  %72 = or i1 %70, %71
  br i1 %72, label %73, label %109

73:                                               ; preds = %69
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6)
  store float %9, ptr %6, align 8, !tbaa !16
  %74 = addrspacecast ptr %6 to ptr addrspace(4)
  %75 = load i64, ptr addrspace(4) %74, align 8, !tbaa !12
  %76 = and i64 %75, 2147483647
  %77 = icmp eq i64 %76, 0
  br i1 %77, label %78, label %79

78:                                               ; preds = %73
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br label %85

79:                                               ; preds = %73
  %80 = and i64 %75, 2139095040
  %81 = icmp ne i64 %80, 0
  %82 = and i64 %75, 8388607
  %83 = icmp eq i64 %82, 0
  %84 = or i1 %81, %83
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6)
  br i1 %84, label %109, label %85

85:                                               ; preds = %78, %79
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  store float %10, ptr %5, align 8, !tbaa !16
  %86 = addrspacecast ptr %5 to ptr addrspace(4)
  %87 = load i64, ptr addrspace(4) %86, align 8, !tbaa !12
  %88 = and i64 %87, 2147483647
  %89 = icmp eq i64 %88, 0
  br i1 %89, label %90, label %91

90:                                               ; preds = %85
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  br label %97

91:                                               ; preds = %85
  %92 = and i64 %87, 2139095040
  %93 = icmp ne i64 %92, 0
  %94 = and i64 %87, 8388607
  %95 = icmp eq i64 %94, 0
  %96 = or i1 %93, %95
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  br i1 %96, label %109, label %97

97:                                               ; preds = %90, %91
  %98 = select i1 %70, float 1.000000e+00, float 0.000000e+00
  %99 = call float @llvm.copysign.f32(float %98, float %18)
  %100 = select i1 %71, float 1.000000e+00, float 0.000000e+00
  %101 = call float @llvm.copysign.f32(float %100, float %20)
  %102 = fmul float %10, %101
  %103 = call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef %9, float noundef %102) #38
  %104 = fmul float %103, 0x7FF0000000000000
  %105 = fneg float %99
  %106 = fmul float %10, %105
  %107 = call spir_func float @__ocml_fmuladd_f32(float noundef %101, float noundef %9, float noundef %106) #38
  %108 = fmul float %107, 0x7FF0000000000000
  br label %148

109:                                              ; preds = %69, %91, %79
  %110 = fcmp oeq float %11, 0x7FF0000000000000
  %111 = fcmp oeq float %12, 0x7FF0000000000000
  %112 = or i1 %110, %111
  br i1 %112, label %113, label %148

113:                                              ; preds = %109
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  store float %18, ptr %4, align 8, !tbaa !16
  %114 = addrspacecast ptr %4 to ptr addrspace(4)
  %115 = load i64, ptr addrspace(4) %114, align 8, !tbaa !12
  %116 = and i64 %115, 2147483647
  %117 = icmp eq i64 %116, 0
  br i1 %117, label %118, label %119

118:                                              ; preds = %113
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %125

119:                                              ; preds = %113
  %120 = and i64 %115, 2139095040
  %121 = icmp ne i64 %120, 0
  %122 = and i64 %115, 8388607
  %123 = icmp eq i64 %122, 0
  %124 = or i1 %121, %123
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br i1 %124, label %148, label %125

125:                                              ; preds = %118, %119
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %20, ptr %3, align 8, !tbaa !16
  %126 = addrspacecast ptr %3 to ptr addrspace(4)
  %127 = load i64, ptr addrspace(4) %126, align 8, !tbaa !12
  %128 = and i64 %127, 2147483647
  %129 = icmp eq i64 %128, 0
  br i1 %129, label %130, label %131

130:                                              ; preds = %125
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br label %137

131:                                              ; preds = %125
  %132 = and i64 %127, 2139095040
  %133 = icmp ne i64 %132, 0
  %134 = and i64 %127, 8388607
  %135 = icmp eq i64 %134, 0
  %136 = or i1 %133, %135
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br i1 %136, label %148, label %137

137:                                              ; preds = %130, %131
  %138 = select i1 %110, float 1.000000e+00, float 0.000000e+00
  %139 = call float @llvm.copysign.f32(float %138, float %9)
  %140 = select i1 %111, float 1.000000e+00, float 0.000000e+00
  %141 = call float @llvm.copysign.f32(float %140, float %10)
  %142 = fmul float %20, %141
  %143 = call spir_func float @__ocml_fmuladd_f32(float noundef %18, float noundef %139, float noundef %142) #38
  %144 = fmul float %143, 0.000000e+00
  %145 = fmul float %141, %45
  %146 = call spir_func float @__ocml_fmuladd_f32(float noundef %20, float noundef %139, float noundef %145) #38
  %147 = fmul float %146, 0.000000e+00
  br label %148

148:                                              ; preds = %109, %97, %137, %131, %119, %65, %2
  %149 = phi float [ %52, %2 ], [ %108, %97 ], [ %147, %137 ], [ %52, %131 ], [ %52, %119 ], [ %68, %65 ], [ %52, %109 ]
  %150 = phi float [ %51, %2 ], [ %104, %97 ], [ %144, %137 ], [ %51, %131 ], [ %51, %119 ], [ %67, %65 ], [ %51, %109 ]
  %151 = insertelement <2 x float> poison, float %150, i64 0
  %152 = insertelement <2 x float> %151, float %149, i64 1
  ret <2 x float> %152
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_ceil_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.ceil.f64(double %0)
  ret double %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.ceil.f64(double) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_ceil_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.ceil.f32(float %0)
  ret float %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.ceil.f32(float) #2

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_ceil_2f16(<2 x half> noundef %0) local_unnamed_addr #31 {
  %2 = tail call spir_func <2 x half> @llvm.ceil.v2f16(<2 x half> noundef %0) #38
  ret <2 x half> %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x half> @llvm.ceil.v2f16(<2 x half>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_ceil_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.ceil.f16(half %0)
  ret half %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.ceil.f16(half) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_cexp_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca double, align 8
  %4 = alloca double, align 8
  %5 = alloca double, align 8
  %6 = extractelement <2 x double> %0, i64 0
  %7 = extractelement <2 x double> %0, i64 1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5) #39
  %8 = call spir_func double @__ocml_sincos_f64(double noundef %7, ptr noundef nonnull %5) #40
  %9 = fcmp ogt double %6, 7.090000e+02
  %10 = select i1 %9, double 1.000000e+00, double 0.000000e+00
  %11 = fsub double %6, %10
  %12 = call spir_func double @__ocml_exp_f64(double noundef %11) #38
  %13 = select i1 %9, double 0x4005BF0A8B145769, double 1.000000e+00
  %14 = load double, ptr %5, align 8, !tbaa !19
  %15 = fmul double %13, %14
  %16 = fmul double %13, %8
  %17 = fmul double %12, %15
  %18 = fmul double %12, %16
  %19 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %58

21:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  store double %7, ptr %4, align 8, !tbaa !19
  %22 = addrspacecast ptr %4 to ptr addrspace(4)
  %23 = load i128, ptr addrspace(4) %22, align 8, !tbaa !29
  switch i128 %23, label %28 [
    i128 9218868437227405312, label %24
    i128 18442240474082181120, label %24
  ]

24:                                               ; preds = %21, %21
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %6, ptr %3, align 8, !tbaa !19
  %25 = addrspacecast ptr %3 to ptr addrspace(4)
  %26 = load i128, ptr addrspace(4) %25, align 8, !tbaa !29
  %27 = icmp eq i128 %26, 18442240474082181120
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  br label %34

28:                                               ; preds = %21
  %29 = and i128 %23, 9221120237041090560
  %30 = icmp eq i128 %29, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %6, ptr %3, align 8, !tbaa !19
  %31 = addrspacecast ptr %3 to ptr addrspace(4)
  %32 = load i128, ptr addrspace(4) %31, align 8, !tbaa !29
  %33 = icmp eq i128 %32, 18442240474082181120
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  br i1 %30, label %40, label %34

34:                                               ; preds = %28, %24
  %35 = phi i1 [ %27, %24 ], [ %33, %28 ]
  %36 = select i1 %35, double 0.000000e+00, double %18
  %37 = select i1 %35, double 0.000000e+00, double %17
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %6, ptr %2, align 8, !tbaa !19
  %38 = addrspacecast ptr %2 to ptr addrspace(4)
  %39 = load i128, ptr addrspace(4) %38, align 8, !tbaa !29
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  br label %44

40:                                               ; preds = %28
  %41 = select i1 %33, double 0.000000e+00, double %17
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %6, ptr %2, align 8, !tbaa !19
  %42 = addrspacecast ptr %2 to ptr addrspace(4)
  %43 = load i128, ptr addrspace(4) %42, align 8, !tbaa !29
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  br label %44

44:                                               ; preds = %34, %40
  %45 = phi i128 [ %43, %40 ], [ %39, %34 ]
  %46 = phi double [ %41, %40 ], [ %37, %34 ]
  %47 = phi double [ %18, %40 ], [ %36, %34 ]
  %48 = phi double [ %18, %40 ], [ 0x7FF8000000000000, %34 ]
  %49 = phi double [ %41, %40 ], [ 0x7FF0000000000000, %34 ]
  %50 = icmp eq i128 %45, 9218868437227405312
  %51 = fcmp oeq double %7, 0.000000e+00
  %52 = select i1 %51, double %7, double %48
  %53 = select i1 %50, double %52, double %47
  %54 = select i1 %50, double %49, double %46
  %55 = fcmp uno double %6, 0.000000e+00
  %56 = and i1 %55, %51
  %57 = select i1 %56, double %7, double %53
  br label %58

58:                                               ; preds = %44, %1
  %59 = phi double [ %18, %1 ], [ %57, %44 ]
  %60 = phi double [ %17, %1 ], [ %54, %44 ]
  %61 = insertelement <2 x double> poison, double %60, i64 0
  %62 = insertelement <2 x double> %61, double %59, i64 1
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5) #39
  ret <2 x double> %62
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_exp_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = fmul double %0, 0x3FF71547652B82FE
  %3 = tail call double @llvm.rint.f64(double %2)
  %4 = fneg double %3
  %5 = tail call double @llvm.fma.f64(double %4, double 0x3FE62E42FEFA39EF, double %0)
  %6 = tail call double @llvm.fma.f64(double %4, double 0x3C7ABC9E3B39803F, double %5)
  %7 = tail call double @llvm.fma.f64(double %6, double 0x3E5ADE156A5DCB37, double 0x3E928AF3FCA7AB0C)
  %8 = tail call double @llvm.fma.f64(double %6, double %7, double 0x3EC71DEE623FDE64)
  %9 = tail call double @llvm.fma.f64(double %6, double %8, double 0x3EFA01997C89E6B0)
  %10 = tail call double @llvm.fma.f64(double %6, double %9, double 0x3F2A01A014761F6E)
  %11 = tail call double @llvm.fma.f64(double %6, double %10, double 0x3F56C16C1852B7B0)
  %12 = tail call double @llvm.fma.f64(double %6, double %11, double 0x3F81111111122322)
  %13 = tail call double @llvm.fma.f64(double %6, double %12, double 0x3FA55555555502A1)
  %14 = tail call double @llvm.fma.f64(double %6, double %13, double 0x3FC5555555555511)
  %15 = tail call double @llvm.fma.f64(double %6, double %14, double 0x3FE000000000000B)
  %16 = tail call double @llvm.fma.f64(double %6, double %15, double 1.000000e+00)
  %17 = tail call double @llvm.fma.f64(double %6, double %16, double 1.000000e+00)
  %18 = fptosi double %3 to i32
  %19 = tail call spir_func double @_Z5ldexpdi(double noundef %17, i32 noundef %18) #38
  %20 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %21 = icmp eq i8 %20, 0
  %22 = fcmp ogt double %0, 1.024000e+03
  %23 = and i1 %22, %21
  %24 = select i1 %23, double 0x7FF0000000000000, double %19
  %25 = fcmp olt double %0, -1.075000e+03
  %26 = select i1 %25, double 0.000000e+00, double %24
  ret double %26
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_cexp_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca float, align 8
  %4 = alloca float, align 8
  %5 = alloca float, align 4
  %6 = extractelement <2 x float> %0, i64 0
  %7 = extractelement <2 x float> %0, i64 1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %8 = call spir_func float @__ocml_sincos_f32(float noundef %7, ptr noundef nonnull %5) #40
  %9 = fcmp ogt float %6, 8.800000e+01
  %10 = select i1 %9, float 1.000000e+00, float 0.000000e+00
  %11 = fsub float %6, %10
  %12 = call spir_func float @__ocml_exp_f32(float noundef %11) #38
  %13 = select i1 %9, float 0x4005BF0A80000000, float 1.000000e+00
  %14 = load float, ptr %5, align 4, !tbaa !16
  %15 = fmul float %13, %14
  %16 = fmul float %13, %8
  %17 = fmul float %12, %15
  %18 = fmul float %12, %16
  %19 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %58

21:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  store float %7, ptr %4, align 8, !tbaa !16
  %22 = addrspacecast ptr %4 to ptr addrspace(4)
  %23 = load i64, ptr addrspace(4) %22, align 8, !tbaa !12
  switch i64 %23, label %28 [
    i64 2139095040, label %24
    i64 -8388608, label %24
  ]

24:                                               ; preds = %21, %21
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %6, ptr %3, align 8, !tbaa !16
  %25 = addrspacecast ptr %3 to ptr addrspace(4)
  %26 = load i64, ptr addrspace(4) %25, align 8, !tbaa !12
  %27 = icmp eq i64 %26, -8388608
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br label %34

28:                                               ; preds = %21
  %29 = and i64 %23, 2143289344
  %30 = icmp eq i64 %29, 0
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %6, ptr %3, align 8, !tbaa !16
  %31 = addrspacecast ptr %3 to ptr addrspace(4)
  %32 = load i64, ptr addrspace(4) %31, align 8, !tbaa !12
  %33 = icmp eq i64 %32, -8388608
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br i1 %30, label %40, label %34

34:                                               ; preds = %28, %24
  %35 = phi i1 [ %27, %24 ], [ %33, %28 ]
  %36 = select i1 %35, float 0.000000e+00, float %18
  %37 = select i1 %35, float 0.000000e+00, float %17
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %6, ptr %2, align 8, !tbaa !16
  %38 = addrspacecast ptr %2 to ptr addrspace(4)
  %39 = load i64, ptr addrspace(4) %38, align 8, !tbaa !12
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %44

40:                                               ; preds = %28
  %41 = select i1 %33, float 0.000000e+00, float %17
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %6, ptr %2, align 8, !tbaa !16
  %42 = addrspacecast ptr %2 to ptr addrspace(4)
  %43 = load i64, ptr addrspace(4) %42, align 8, !tbaa !12
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %44

44:                                               ; preds = %34, %40
  %45 = phi i64 [ %43, %40 ], [ %39, %34 ]
  %46 = phi float [ %41, %40 ], [ %37, %34 ]
  %47 = phi float [ %18, %40 ], [ %36, %34 ]
  %48 = phi float [ %18, %40 ], [ 0x7FF8000000000000, %34 ]
  %49 = phi float [ %41, %40 ], [ 0x7FF0000000000000, %34 ]
  %50 = icmp eq i64 %45, 2139095040
  %51 = fcmp oeq float %7, 0.000000e+00
  %52 = select i1 %51, float %7, float %48
  %53 = select i1 %50, float %52, float %47
  %54 = select i1 %50, float %49, float %46
  %55 = fcmp uno float %6, 0.000000e+00
  %56 = and i1 %55, %51
  %57 = select i1 %56, float %7, float %53
  br label %58

58:                                               ; preds = %44, %1
  %59 = phi float [ %18, %1 ], [ %57, %44 ]
  %60 = phi float [ %17, %1 ], [ %54, %44 ]
  %61 = insertelement <2 x float> poison, float %60, i64 0
  %62 = insertelement <2 x float> %61, float %59, i64 1
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  ret <2 x float> %62
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_exp_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %3 = icmp eq i8 %2, 0
  %4 = load i8, ptr addrspace(2) @__oclc_unsafe_math_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %5 = icmp eq i8 %4, 0
  br i1 %3, label %42, label %6

6:                                                ; preds = %1
  br i1 %5, label %10, label %7

7:                                                ; preds = %6
  %8 = fmul float %0, 0x3FF7154760000000
  %9 = tail call float @llvm.exp2.f32(float %8)
  br label %83

10:                                               ; preds = %6
  %11 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %12 = freeze i32 %11
  %13 = icmp sgt i32 %12, 8999
  br i1 %13, label %15, label %14

14:                                               ; preds = %10
  switch i32 %12, label %20 [
    i32 8001, label %15
    i32 7001, label %15
  ]

15:                                               ; preds = %14, %14, %10
  %16 = fmul float %0, 0x3FF7154760000000
  %17 = fneg float %16
  %18 = tail call float @llvm.fma.f32(float %0, float 0x3FF7154760000000, float %17)
  %19 = tail call float @llvm.fma.f32(float %0, float 0x3E54AE0BE0000000, float %18)
  br label %29

20:                                               ; preds = %14
  %21 = bitcast float %0 to i32
  %22 = and i32 %21, -4096
  %23 = bitcast i32 %22 to float
  %24 = fsub float %0, %23
  %25 = fmul float %23, 0x3FF7140000000000
  %26 = fmul float %24, 0x3F347652A0000000
  %27 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %24, float noundef 0x3FF7140000000000, float noundef %26) #38
  %28 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %23, float noundef 0x3F347652A0000000, float noundef %27) #38
  br label %29

29:                                               ; preds = %20, %15
  %30 = phi float [ %19, %15 ], [ %28, %20 ]
  %31 = phi float [ %16, %15 ], [ %25, %20 ]
  %32 = tail call float @llvm.rint.f32(float %31)
  %33 = fsub float %31, %32
  %34 = fadd float %30, %33
  %35 = tail call float @llvm.exp2.f32(float %34)
  %36 = fptosi float %32 to i32
  %37 = tail call spir_func float @_Z5ldexpfi(float noundef %35, i32 noundef %36) #38
  %38 = fcmp olt float %0, 0xC055D58A00000000
  %39 = select i1 %38, float 0.000000e+00, float %37
  %40 = fcmp ogt float %0, 0x40562E4300000000
  %41 = select i1 %40, float 0x7FF0000000000000, float %39
  br label %83

42:                                               ; preds = %1
  br i1 %5, label %51, label %43

43:                                               ; preds = %42
  %44 = fcmp olt float %0, 0xC055D58A00000000
  %45 = select i1 %44, float 6.400000e+01, float 0.000000e+00
  %46 = fadd float %45, %0
  %47 = fmul float %46, 0x3FF7154760000000
  %48 = tail call float @llvm.exp2.f32(float %47)
  %49 = select i1 %44, float 0x3A2969D480000000, float 1.000000e+00
  %50 = fmul float %49, %48
  br label %83

51:                                               ; preds = %42
  %52 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %53 = freeze i32 %52
  %54 = icmp sgt i32 %53, 8999
  br i1 %54, label %56, label %55

55:                                               ; preds = %51
  switch i32 %53, label %61 [
    i32 8001, label %56
    i32 7001, label %56
  ]

56:                                               ; preds = %55, %55, %51
  %57 = fmul float %0, 0x3FF7154760000000
  %58 = fneg float %57
  %59 = tail call float @llvm.fma.f32(float %0, float 0x3FF7154760000000, float %58)
  %60 = tail call float @llvm.fma.f32(float %0, float 0x3E54AE0BE0000000, float %59)
  br label %70

61:                                               ; preds = %55
  %62 = bitcast float %0 to i32
  %63 = and i32 %62, -4096
  %64 = bitcast i32 %63 to float
  %65 = fsub float %0, %64
  %66 = fmul float %64, 0x3FF7140000000000
  %67 = fmul float %65, 0x3F347652A0000000
  %68 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %65, float noundef 0x3FF7140000000000, float noundef %67) #38
  %69 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %64, float noundef 0x3F347652A0000000, float noundef %68) #38
  br label %70

70:                                               ; preds = %61, %56
  %71 = phi float [ %60, %56 ], [ %69, %61 ]
  %72 = phi float [ %57, %56 ], [ %66, %61 ]
  %73 = tail call float @llvm.rint.f32(float %72)
  %74 = fsub float %72, %73
  %75 = fadd float %71, %74
  %76 = tail call float @llvm.exp2.f32(float %75)
  %77 = fptosi float %73 to i32
  %78 = tail call spir_func float @_Z5ldexpfi(float noundef %76, i32 noundef %77) #38
  %79 = fcmp olt float %0, 0xC059D1DA00000000
  %80 = select i1 %79, float 0.000000e+00, float %78
  %81 = fcmp ogt float %0, 0x40562E4300000000
  %82 = select i1 %81, float 0x7FF0000000000000, float %80
  br label %83

83:                                               ; preds = %70, %43, %29, %7
  %84 = phi float [ %9, %7 ], [ %41, %29 ], [ %50, %43 ], [ %82, %70 ]
  ret float %84
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_clog_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = extractelement <2 x double> %0, i64 0
  %4 = extractelement <2 x double> %0, i64 1
  %5 = tail call double @llvm.fabs.f64(double %3)
  %6 = tail call double @llvm.fabs.f64(double %4)
  %7 = tail call double @llvm.maxnum.f64(double %5, double %6)
  %8 = fptrunc double %7 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %9 = addrspacecast ptr %2 to ptr addrspace(4)
  %10 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %8, ptr addrspace(4) noundef %9) #40
  %11 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %12 = sub nsw i32 0, %11
  %13 = call spir_func double @_Z5ldexpdi(double noundef %5, i32 noundef %12) #38
  %14 = call spir_func double @_Z5ldexpdi(double noundef %6, i32 noundef %12) #38
  %15 = fmul double %13, %13
  %16 = fneg double %15
  %17 = call double @llvm.fma.f64(double %13, double %13, double %16)
  %18 = fmul double %14, %14
  %19 = fneg double %18
  %20 = call double @llvm.fma.f64(double %14, double %14, double %19)
  %21 = fadd double %15, %18
  %22 = fsub double %21, %15
  %23 = fsub double %22, %21
  %24 = fadd double %15, %23
  %25 = fsub double %18, %22
  %26 = fadd double %25, %24
  %27 = fadd double %17, %20
  %28 = fsub double %27, %17
  %29 = fsub double %28, %27
  %30 = fadd double %17, %29
  %31 = fsub double %20, %28
  %32 = fadd double %31, %30
  %33 = fadd double %27, %26
  %34 = fadd double %21, %33
  %35 = fsub double %21, %34
  %36 = fadd double %33, %35
  %37 = fadd double %32, %36
  %38 = fadd double %34, %37
  %39 = fsub double %34, %38
  %40 = fadd double %37, %39
  %41 = insertelement <2 x double> poison, double %40, i64 0
  %42 = insertelement <2 x double> %41, double %38, i64 1
  %43 = shl nsw i32 %11, 1
  %44 = call spir_func double @__ocmlpriv_lnep_f64(<2 x double> noundef %42, i32 noundef %43) #38
  %45 = fmul double %44, 5.000000e-01
  %46 = call spir_func double @__ocml_atan2_f64(double noundef %4, double noundef %3) #38
  %47 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %48 = icmp eq i8 %47, 0
  br i1 %48, label %49, label %58

49:                                               ; preds = %1
  %50 = fcmp oeq double %3, 0.000000e+00
  %51 = fcmp oeq double %4, 0.000000e+00
  %52 = and i1 %50, %51
  %53 = select i1 %52, double 0xFFF0000000000000, double %45
  %54 = fcmp oeq double %5, 0x7FF0000000000000
  %55 = fcmp oeq double %6, 0x7FF0000000000000
  %56 = or i1 %54, %55
  %57 = select i1 %56, double 0x7FF0000000000000, double %53
  br label %58

58:                                               ; preds = %49, %1
  %59 = phi double [ %45, %1 ], [ %57, %49 ]
  %60 = insertelement <2 x double> poison, double %59, i64 0
  %61 = insertelement <2 x double> %60, double %46, i64 1
  ret <2 x double> %61
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_clog_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = extractelement <2 x float> %0, i64 0
  %4 = extractelement <2 x float> %0, i64 1
  %5 = tail call float @llvm.fabs.f32(float %3)
  %6 = tail call float @llvm.fabs.f32(float %4)
  %7 = bitcast float %5 to i32
  %8 = bitcast float %6 to i32
  %9 = tail call i32 @llvm.umax.i32(i32 %7, i32 %8)
  %10 = bitcast i32 %9 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %11 = addrspacecast ptr %2 to ptr addrspace(4)
  %12 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %10, ptr addrspace(4) noundef %11) #40
  %13 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %14 = sub nsw i32 0, %13
  %15 = call spir_func float @_Z5ldexpfi(float noundef %5, i32 noundef %14) #38
  %16 = call spir_func float @_Z5ldexpfi(float noundef %6, i32 noundef %14) #38
  %17 = fmul float %15, %15
  %18 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %19 = freeze i32 %18
  %20 = icmp sgt i32 %19, 8999
  br i1 %20, label %21, label %25

21:                                               ; preds = %1
  %22 = fneg float %17
  %23 = call float @llvm.fma.f32(float %15, float %15, float %22)
  %24 = fmul float %16, %16
  br label %42

25:                                               ; preds = %1
  switch i32 %19, label %26 [
    i32 8001, label %36
    i32 7001, label %36
  ]

26:                                               ; preds = %25
  %27 = bitcast float %15 to i32
  %28 = and i32 %27, -4096
  %29 = bitcast i32 %28 to float
  %30 = fsub float %15, %29
  %31 = fneg float %17
  %32 = call float @llvm.fmuladd.f32(float %29, float %29, float %31)
  %33 = fmul float %29, 2.000000e+00
  %34 = call float @llvm.fmuladd.f32(float %33, float %30, float %32)
  %35 = call float @llvm.fmuladd.f32(float %30, float %30, float %34)
  br label %39

36:                                               ; preds = %25, %25
  %37 = fneg float %17
  %38 = call float @llvm.fma.f32(float %15, float %15, float %37)
  br label %39

39:                                               ; preds = %36, %26
  %40 = phi float [ %35, %26 ], [ %38, %36 ]
  %41 = fmul float %16, %16
  switch i32 %19, label %47 [
    i32 8001, label %42
    i32 7001, label %42
  ]

42:                                               ; preds = %21, %39, %39
  %43 = phi float [ %41, %39 ], [ %41, %39 ], [ %24, %21 ]
  %44 = phi float [ %40, %39 ], [ %40, %39 ], [ %23, %21 ]
  %45 = fneg float %43
  %46 = call float @llvm.fma.f32(float %16, float %16, float %45)
  br label %57

47:                                               ; preds = %39
  %48 = bitcast float %16 to i32
  %49 = and i32 %48, -4096
  %50 = bitcast i32 %49 to float
  %51 = fsub float %16, %50
  %52 = fneg float %41
  %53 = call float @llvm.fmuladd.f32(float %50, float %50, float %52)
  %54 = fmul float %50, 2.000000e+00
  %55 = call float @llvm.fmuladd.f32(float %54, float %51, float %53)
  %56 = call float @llvm.fmuladd.f32(float %51, float %51, float %55)
  br label %57

57:                                               ; preds = %42, %47
  %58 = phi float [ %41, %47 ], [ %43, %42 ]
  %59 = phi float [ %40, %47 ], [ %44, %42 ]
  %60 = phi float [ %56, %47 ], [ %46, %42 ]
  %61 = fadd float %17, %58
  %62 = fsub float %61, %17
  %63 = fsub float %62, %61
  %64 = fadd float %17, %63
  %65 = fsub float %58, %62
  %66 = fadd float %65, %64
  %67 = fadd float %59, %60
  %68 = fsub float %67, %59
  %69 = fsub float %67, %68
  %70 = fsub float %59, %69
  %71 = fsub float %60, %68
  %72 = fadd float %71, %70
  %73 = fadd float %67, %66
  %74 = fadd float %61, %73
  %75 = fsub float %61, %74
  %76 = fadd float %73, %75
  %77 = fadd float %72, %76
  %78 = fadd float %74, %77
  %79 = fsub float %74, %78
  %80 = fadd float %77, %79
  %81 = insertelement <2 x float> poison, float %80, i64 0
  %82 = insertelement <2 x float> %81, float %78, i64 1
  %83 = shl nsw i32 %13, 1
  %84 = call spir_func float @__ocmlpriv_lnep_f32(<2 x float> noundef %82, i32 noundef %83) #38
  %85 = fmul float %84, 5.000000e-01
  %86 = call spir_func float @__ocml_atan2_f32(float noundef %4, float noundef %3) #38
  %87 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %88 = icmp eq i8 %87, 0
  br i1 %88, label %89, label %98

89:                                               ; preds = %57
  %90 = fcmp oeq float %3, 0.000000e+00
  %91 = fcmp oeq float %4, 0.000000e+00
  %92 = and i1 %90, %91
  %93 = select i1 %92, float 0xFFF0000000000000, float %85
  %94 = fcmp oeq float %5, 0x7FF0000000000000
  %95 = fcmp oeq float %6, 0x7FF0000000000000
  %96 = or i1 %94, %95
  %97 = select i1 %96, float 0x7FF0000000000000, float %93
  br label %98

98:                                               ; preds = %89, %57
  %99 = phi float [ %85, %57 ], [ %97, %89 ]
  %100 = insertelement <2 x float> poison, float %99, i64 0
  %101 = insertelement <2 x float> %100, float %86, i64 1
  ret <2 x float> %101
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_copysign_f64(double noundef %0, double noundef %1) local_unnamed_addr #23 {
  %3 = tail call double @llvm.copysign.f64(double %0, double %1)
  ret double %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_copysign_f32(float noundef %0, float noundef %1) local_unnamed_addr #23 {
  %3 = tail call float @llvm.copysign.f32(float %0, float %1)
  ret float %3
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_copysign_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #31 {
  %3 = tail call spir_func <2 x half> @llvm.copysign.v2f16(<2 x half> noundef %0, <2 x half> noundef %1) #38
  ret <2 x half> %3
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x half> @llvm.copysign.v2f16(<2 x half>, <2 x half>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_copysign_f16(half noundef %0, half noundef %1) local_unnamed_addr #23 {
  %3 = tail call half @llvm.copysign.f16(half %0, half %1)
  ret half %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_cos_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca %struct.redret, align 8
  %4 = alloca %struct.scret, align 8
  %5 = tail call double @llvm.fabs.f64(double %0)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3) #39
  call spir_func void @__ocmlpriv_trigred_f64(ptr dead_on_unwind nonnull writable sret(%struct.redret) align 8 %3, double noundef %5) #43
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #39
  %6 = getelementptr inbounds %struct.redret, ptr %3, i64 0, i32 1
  %7 = load double, ptr %6, align 8, !tbaa !31
  %8 = load double, ptr %3, align 8, !tbaa !33
  call spir_func void @__ocmlpriv_sincosred2_f64(ptr dead_on_unwind nonnull writable sret(%struct.scret) align 8 %4, double noundef %7, double noundef %8) #43
  %9 = load double, ptr %4, align 8, !tbaa !37
  %10 = fneg double %9
  %11 = getelementptr inbounds %struct.redret, ptr %3, i64 0, i32 2
  %12 = load i32, ptr %11, align 8, !tbaa !34
  %13 = and i32 %12, 1
  %14 = icmp eq i32 %13, 0
  %15 = getelementptr inbounds %struct.scret, ptr %4, i64 0, i32 1
  %16 = load double, ptr %15, align 8
  %17 = select i1 %14, double %16, double %10
  %18 = bitcast double %17 to <2 x i32>
  %19 = icmp sgt i32 %12, 1
  %20 = select i1 %19, i32 -2147483648, i32 0
  %21 = extractelement <2 x i32> %18, i64 1
  %22 = xor i32 %21, %20
  %23 = insertelement <2 x i32> %18, i32 %22, i64 1
  %24 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %26, label %40

26:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %5, ptr %2, align 8, !tbaa !19
  %27 = addrspacecast ptr %2 to ptr addrspace(4)
  %28 = load i128, ptr addrspace(4) %27, align 8, !tbaa !29
  %29 = and i128 %28, 9223372036854775807
  %30 = icmp eq i128 %29, 0
  br i1 %30, label %31, label %32

31:                                               ; preds = %26
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  br label %40

32:                                               ; preds = %26
  %33 = and i128 %28, 9218868437227405312
  %34 = icmp ne i128 %33, 0
  %35 = and i128 %28, 4503599627370495
  %36 = icmp eq i128 %35, 0
  %37 = or i1 %34, %36
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %38 = freeze i1 %37
  %39 = select i1 %38, <2 x i32> <i32 0, i32 2146959360>, <2 x i32> %23
  br label %40

40:                                               ; preds = %32, %31, %1
  %41 = phi <2 x i32> [ %23, %1 ], [ %23, %31 ], [ %39, %32 ]
  %42 = bitcast <2 x i32> %41 to double
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3) #39
  ret double %42
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_cos_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca %struct.redret.0, align 4
  %4 = alloca %struct.scret.1, align 4
  %5 = tail call float @llvm.fabs.f32(float %0)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #39
  call spir_func void @__ocmlpriv_trigred_f32(ptr dead_on_unwind nonnull writable sret(%struct.redret.0) align 4 %3, float noundef %5) #43
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #39
  %6 = load float, ptr %3, align 4, !tbaa !38
  call spir_func void @__ocmlpriv_sincosred_f32(ptr dead_on_unwind nonnull writable sret(%struct.scret.1) align 4 %4, float noundef %6) #43
  %7 = load float, ptr %4, align 4, !tbaa !43
  %8 = fneg float %7
  %9 = getelementptr inbounds %struct.redret.0, ptr %3, i64 0, i32 1
  %10 = load i32, ptr %9, align 4, !tbaa !40
  %11 = and i32 %10, 1
  %12 = icmp eq i32 %11, 0
  %13 = getelementptr inbounds %struct.scret.1, ptr %4, i64 0, i32 1
  %14 = load float, ptr %13, align 4
  %15 = select i1 %12, float %14, float %8
  %16 = bitcast float %15 to i32
  %17 = icmp sgt i32 %10, 1
  %18 = select i1 %17, i32 -2147483648, i32 0
  %19 = xor i32 %18, %16
  %20 = bitcast i32 %19 to float
  %21 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %37

23:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %5, ptr %2, align 8, !tbaa !16
  %24 = addrspacecast ptr %2 to ptr addrspace(4)
  %25 = load i64, ptr addrspace(4) %24, align 8, !tbaa !12
  %26 = and i64 %25, 2147483647
  %27 = icmp eq i64 %26, 0
  br i1 %27, label %28, label %29

28:                                               ; preds = %23
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %37

29:                                               ; preds = %23
  %30 = and i64 %25, 2139095040
  %31 = icmp ne i64 %30, 0
  %32 = and i64 %25, 8388607
  %33 = icmp eq i64 %32, 0
  %34 = or i1 %31, %33
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %35 = freeze i1 %34
  %36 = select i1 %35, float 0x7FF8000000000000, float %20
  br label %37

37:                                               ; preds = %29, %28, %1
  %38 = phi float [ %20, %1 ], [ %20, %28 ], [ %36, %29 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #39
  ret float %38
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_cos_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_cos_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_cos_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_cos_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = alloca %struct.redret.2, align 2
  %3 = alloca %struct.scret.3, align 2
  %4 = tail call half @llvm.fabs.f16(half %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  call spir_func void @__ocmlpriv_trigred_f16(ptr dead_on_unwind nonnull writable sret(%struct.redret.2) align 2 %2, half noundef %4) #43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %5 = load half, ptr %2, align 2, !tbaa !45
  call spir_func void @__ocmlpriv_sincosred_f16(ptr dead_on_unwind nonnull writable sret(%struct.scret.3) align 2 %3, half noundef %5) #43
  %6 = load half, ptr %3, align 2, !tbaa !49
  %7 = fneg half %6
  %8 = getelementptr inbounds %struct.redret.2, ptr %2, i64 0, i32 1
  %9 = load i16, ptr %8, align 2, !tbaa !51
  %10 = and i16 %9, 1
  %11 = icmp eq i16 %10, 0
  %12 = getelementptr inbounds %struct.scret.3, ptr %3, i64 0, i32 1
  %13 = load half, ptr %12, align 2
  %14 = select i1 %11, half %13, half %7
  %15 = bitcast half %14 to i16
  %16 = icmp sgt i16 %9, 1
  %17 = select i1 %16, i16 -32768, i16 0
  %18 = xor i16 %17, %15
  %19 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %26

21:                                               ; preds = %1
  %22 = fptoui half %4 to i16
  %23 = call spir_func i32 @__builtin_generic_class_f16.30(i16 noundef zeroext %22) #39
  %24 = icmp eq i32 %23, 0
  %25 = select i1 %24, i16 32256, i16 %18
  br label %26

26:                                               ; preds = %21, %1
  %27 = phi i16 [ %18, %1 ], [ %25, %21 ]
  %28 = bitcast i16 %27 to half
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret half %28
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_trigred_f16(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.redret.2) align 2 %0, half noundef %1) local_unnamed_addr #30 {
  %3 = fpext half %1 to float
  %4 = fmul float %3, 0x3FE45F3060000000
  %5 = tail call float @llvm.rint.f32(float %4)
  %6 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef 0xBFF9200000000000, float noundef %3) #38
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef 0xBF3FA00000000000, float noundef %6) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef 0xBEB54442E0000000, float noundef %7) #38
  %9 = fptrunc float %8 to half
  store half %9, ptr %0, align 2, !tbaa !45
  %10 = fptosi float %5 to i32
  %11 = trunc i32 %10 to i16
  %12 = and i16 %11, 3
  %13 = getelementptr inbounds %struct.redret.2, ptr %0, i64 0, i32 1
  store i16 %12, ptr %13, align 2, !tbaa !51
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_sincosred_f16(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.scret.3) align 2 %0, half noundef %1) local_unnamed_addr #29 {
  %3 = fmul half %1, %1
  %4 = tail call half @llvm.fma.f16(half %3, half 0xH202C, half 0xHB155)
  %5 = fmul half %3, %4
  %6 = tail call half @llvm.fma.f16(half %1, half %5, half %1)
  %7 = tail call half @llvm.fma.f16(half %3, half 0xH292D, half 0xHB7FF)
  %8 = tail call half @llvm.fma.f16(half %3, half %7, half 0xH3C00)
  %9 = getelementptr inbounds %struct.scret.3, ptr %0, i64 0, i32 1
  store half %8, ptr %9, align 2, !tbaa !52
  store half %6, ptr %0, align 2, !tbaa !49
  ret void
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func i32 @__builtin_generic_class_f16.30(i16 noundef zeroext %0) unnamed_addr #25 {
  %2 = and i16 %0, 32767
  %3 = icmp eq i16 %2, 0
  br i1 %3, label %12, label %4

4:                                                ; preds = %1
  %5 = zext i16 %0 to i32
  %6 = and i32 %5, 31744
  %7 = icmp eq i32 %6, 0
  %8 = and i32 %5, 1023
  %9 = icmp ne i32 %8, 0
  %10 = and i1 %7, %9
  %11 = sext i1 %10 to i32
  br label %12

12:                                               ; preds = %4, %1
  %13 = phi i32 [ -1, %1 ], [ %11, %4 ]
  ret i32 %13
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_cosb_f64(double noundef %0, i32 noundef %1, double noundef %2) local_unnamed_addr #21 {
  %4 = alloca %struct.redret, align 8
  %5 = alloca %struct.scret, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4) #39
  call spir_func void @__ocmlpriv_trigred_f64(ptr dead_on_unwind nonnull writable sret(%struct.redret) align 8 %4, double noundef %0) #43
  %6 = getelementptr inbounds %struct.redret, ptr %4, i64 0, i32 1
  %7 = load double, ptr %6, align 8, !tbaa !31
  %8 = fcmp olt double %7, %2
  %9 = getelementptr inbounds %struct.redret, ptr %4, i64 0, i32 2
  %10 = load i32, ptr %9, align 8, !tbaa !34
  %11 = sext i1 %8 to i32
  %12 = sub i32 %10, %1
  %13 = add i32 %12, %11
  %14 = select i1 %8, i32 -2147483648, i32 0
  %15 = xor i32 %14, -1075240453
  %16 = insertelement <2 x i32> <i32 1413754136, i32 poison>, i32 %15, i64 1
  %17 = bitcast <2 x i32> %16 to double
  %18 = xor i32 %14, -1132354010
  %19 = insertelement <2 x i32> <i32 856972295, i32 poison>, i32 %18, i64 1
  %20 = bitcast <2 x i32> %19 to double
  %21 = fsub double %17, %2
  %22 = fsub double %17, %21
  %23 = fsub double %22, %2
  %24 = fadd double %23, %20
  %25 = fadd double %21, %24
  %26 = fsub double %25, %21
  %27 = fsub double %24, %26
  %28 = fadd double %7, %25
  %29 = fsub double %28, %25
  %30 = fsub double %7, %29
  %31 = load double, ptr %4, align 8, !tbaa !33
  %32 = fadd double %31, %27
  %33 = fadd double %30, %32
  %34 = fadd double %28, %33
  %35 = fsub double %34, %28
  %36 = fsub double %33, %35
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %5) #39
  call spir_func void @__ocmlpriv_sincosred2_f64(ptr dead_on_unwind nonnull writable sret(%struct.scret) align 8 %5, double noundef %34, double noundef %36) #43
  %37 = load double, ptr %5, align 8, !tbaa !37
  %38 = fneg double %37
  %39 = and i32 %13, 1
  %40 = icmp eq i32 %39, 0
  %41 = getelementptr inbounds %struct.scret, ptr %5, i64 0, i32 1
  %42 = load double, ptr %41, align 8
  %43 = select i1 %40, double %42, double %38
  %44 = bitcast double %43 to <2 x i32>
  %45 = shl i32 %13, 30
  %46 = and i32 %45, -2147483648
  %47 = extractelement <2 x i32> %44, i64 1
  %48 = xor i32 %47, %46
  %49 = insertelement <2 x i32> %44, i32 %48, i64 1
  %50 = bitcast <2 x i32> %49 to double
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %5) #39
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4) #39
  ret double %50
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_cosb_f32(float noundef %0, i32 noundef %1, float noundef %2) local_unnamed_addr #21 {
  %4 = alloca %struct.redret.0, align 4
  %5 = alloca %struct.scret.1, align 4
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #39
  call spir_func void @__ocmlpriv_trigred_f32(ptr dead_on_unwind nonnull writable sret(%struct.redret.0) align 4 %4, float noundef %0) #43
  %6 = load float, ptr %4, align 4, !tbaa !38
  %7 = fcmp olt float %6, %2
  %8 = getelementptr inbounds %struct.redret.0, ptr %4, i64 0, i32 1
  %9 = load i32, ptr %8, align 4, !tbaa !40
  %10 = sext i1 %7 to i32
  %11 = sub i32 %9, %1
  %12 = add i32 %11, %10
  %13 = fsub float %6, %2
  %14 = select i1 %7, float 0x3FE921FB60000000, float 0xBFE921FB60000000
  %15 = fadd float %13, %14
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5) #39
  call spir_func void @__ocmlpriv_sincosred_f32(ptr dead_on_unwind nonnull writable sret(%struct.scret.1) align 4 %5, float noundef %15) #43
  %16 = load float, ptr %5, align 4, !tbaa !43
  %17 = fneg float %16
  %18 = and i32 %12, 1
  %19 = icmp eq i32 %18, 0
  %20 = getelementptr inbounds %struct.scret.1, ptr %5, i64 0, i32 1
  %21 = load float, ptr %20, align 4
  %22 = select i1 %19, float %21, float %17
  %23 = bitcast float %22 to i32
  %24 = shl i32 %12, 30
  %25 = and i32 %24, -2147483648
  %26 = xor i32 %25, %23
  %27 = bitcast i32 %26 to float
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5) #39
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #39
  ret float %27
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_cosh_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fadd double %2, 0xBFE62E42FEFA39EF
  %4 = fsub double %3, %2
  %5 = fsub double %4, %3
  %6 = fadd double %2, %5
  %7 = fadd double %4, 0x3FE62E42FEFA39EF
  %8 = fsub double %6, %7
  %9 = fadd double %8, 0xBC7ABC9E3B39803F
  %10 = fadd double %3, %9
  %11 = fsub double %3, %10
  %12 = fadd double %9, %11
  %13 = insertelement <2 x double> poison, double %12, i64 0
  %14 = insertelement <2 x double> %13, double %10, i64 1
  %15 = tail call spir_func <2 x double> @__ocmlpriv_epexpep_f64(<2 x double> noundef %14) #38
  %16 = extractelement <2 x double> %15, i64 1
  %17 = fptrunc double %16 to float
  %18 = tail call spir_func float @_Z12native_recipf(float noundef %17) #38
  %19 = fpext float %18 to double
  %20 = fneg double %16
  %21 = tail call double @llvm.fma.f64(double %20, double %19, double 1.000000e+00)
  %22 = tail call double @llvm.fma.f64(double %21, double %19, double %19)
  %23 = tail call double @llvm.fma.f64(double %20, double %22, double 1.000000e+00)
  %24 = tail call double @llvm.fma.f64(double %23, double %22, double %22)
  %25 = fmul double %16, %24
  %26 = fneg double %25
  %27 = tail call double @llvm.fma.f64(double %24, double %16, double %26)
  %28 = extractelement <2 x double> %15, i64 0
  %29 = tail call double @llvm.fma.f64(double %24, double %28, double %27)
  %30 = fadd double %25, %29
  %31 = fsub double %30, %25
  %32 = fsub double 1.000000e+00, %30
  %33 = fsub double 1.000000e+00, %32
  %34 = fsub double %33, %30
  %35 = fsub double %31, %29
  %36 = fadd double %35, %34
  %37 = fadd double %32, %36
  %38 = fsub double %32, %37
  %39 = fadd double %36, %38
  %40 = fmul double %24, %37
  %41 = fmul double %16, %40
  %42 = fneg double %41
  %43 = tail call double @llvm.fma.f64(double %40, double %16, double %42)
  %44 = tail call double @llvm.fma.f64(double %40, double %28, double %43)
  %45 = fadd double %41, %44
  %46 = fsub double %45, %41
  %47 = fsub double %37, %45
  %48 = fsub double %37, %47
  %49 = fsub double %48, %45
  %50 = fadd double %39, %49
  %51 = fsub double %46, %44
  %52 = fadd double %51, %50
  %53 = fadd double %47, %52
  %54 = fmul double %24, %53
  %55 = fadd double %24, %40
  %56 = fsub double %55, %24
  %57 = fsub double %40, %56
  %58 = fadd double %57, %54
  %59 = fadd double %55, %58
  %60 = fsub double %59, %55
  %61 = fsub double %58, %60
  %62 = tail call spir_func double @_Z5ldexpdi(double noundef %59, i32 noundef -2) #38
  %63 = tail call spir_func double @_Z5ldexpdi(double noundef %61, i32 noundef -2) #38
  %64 = fadd double %16, %62
  %65 = fsub double %64, %16
  %66 = fsub double %62, %65
  %67 = fadd double %28, %63
  %68 = fadd double %67, %66
  %69 = fadd double %64, %68
  %70 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %71 = icmp eq i8 %70, 0
  %72 = fcmp oge double %2, 0x408633CE8FB9F87E
  %73 = and i1 %72, %71
  %74 = select i1 %73, double 0x7FF0000000000000, double %69
  ret double %74
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_cosh_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = fadd float %2, 0xBFE62E4300000000
  %4 = fsub float %3, %2
  %5 = fsub float %4, %3
  %6 = fadd float %2, %5
  %7 = fadd float %4, 0x3FE62E4300000000
  %8 = fsub float %6, %7
  %9 = fadd float %8, 0x3E205C6100000000
  %10 = fadd float %3, %9
  %11 = fsub float %3, %10
  %12 = fadd float %9, %11
  %13 = insertelement <2 x float> poison, float %12, i64 0
  %14 = insertelement <2 x float> %13, float %10, i64 1
  %15 = tail call spir_func <2 x float> @__ocmlpriv_epexpep_f32(<2 x float> noundef %14) #38
  %16 = extractelement <2 x float> %15, i64 1
  %17 = tail call spir_func float @_Z12native_recipf(float noundef %16) #38
  %18 = fmul float %16, %17
  %19 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %20 = freeze i32 %19
  %21 = icmp sgt i32 %20, 8999
  br i1 %21, label %22, label %27

22:                                               ; preds = %1
  %23 = fneg float %18
  %24 = tail call float @llvm.fma.f32(float %17, float %16, float %23)
  %25 = insertelement <2 x float> poison, float %24, i64 0
  %26 = insertelement <2 x float> %25, float %18, i64 1
  br label %49

27:                                               ; preds = %1
  switch i32 %20, label %28 [
    i32 8001, label %42
    i32 7001, label %42
  ]

28:                                               ; preds = %27
  %29 = bitcast float %17 to i32
  %30 = and i32 %29, -4096
  %31 = bitcast i32 %30 to float
  %32 = fsub float %17, %31
  %33 = bitcast float %16 to i32
  %34 = and i32 %33, -4096
  %35 = bitcast i32 %34 to float
  %36 = fsub float %16, %35
  %37 = fneg float %18
  %38 = tail call float @llvm.fmuladd.f32(float %31, float %35, float %37)
  %39 = tail call float @llvm.fmuladd.f32(float %31, float %36, float %38)
  %40 = tail call float @llvm.fmuladd.f32(float %32, float %35, float %39)
  %41 = tail call float @llvm.fmuladd.f32(float %32, float %36, float %40)
  br label %45

42:                                               ; preds = %27, %27
  %43 = fneg float %18
  %44 = tail call float @llvm.fma.f32(float %17, float %16, float %43)
  br label %45

45:                                               ; preds = %42, %28
  %46 = phi float [ %44, %42 ], [ %41, %28 ]
  %47 = insertelement <2 x float> poison, float %46, i64 0
  %48 = insertelement <2 x float> %47, float %18, i64 1
  switch i32 %20, label %55 [
    i32 8001, label %49
    i32 7001, label %49
  ]

49:                                               ; preds = %45, %45, %22
  %50 = phi <2 x float> [ %48, %45 ], [ %48, %45 ], [ %26, %22 ]
  %51 = phi float [ %46, %45 ], [ %46, %45 ], [ %24, %22 ]
  %52 = extractelement <2 x float> %15, i64 0
  %53 = tail call float @llvm.fma.f32(float %17, float %52, float %51)
  %54 = insertelement <2 x float> %50, float %53, i64 0
  br label %59

55:                                               ; preds = %45
  %56 = extractelement <2 x float> %15, i64 0
  %57 = tail call float @llvm.fmuladd.f32(float %17, float %56, float %46)
  %58 = insertelement <2 x float> %48, float %57, i64 0
  br label %59

59:                                               ; preds = %55, %49
  %60 = phi <2 x float> [ %54, %49 ], [ %58, %55 ]
  %61 = extractelement <2 x float> %60, i64 1
  %62 = extractelement <2 x float> %60, i64 0
  %63 = fadd float %61, %62
  %64 = fsub float %63, %61
  %65 = fsub float 1.000000e+00, %63
  %66 = fsub float 1.000000e+00, %65
  %67 = fsub float %66, %63
  %68 = fsub float %64, %62
  %69 = fadd float %68, %67
  %70 = fadd float %65, %69
  %71 = fmul float %17, %70
  %72 = fmul float %16, %71
  br i1 %21, label %73, label %78

73:                                               ; preds = %59
  %74 = fneg float %72
  %75 = tail call float @llvm.fma.f32(float %71, float %16, float %74)
  %76 = insertelement <2 x float> poison, float %75, i64 0
  %77 = insertelement <2 x float> %76, float %72, i64 1
  br label %100

78:                                               ; preds = %59
  switch i32 %20, label %79 [
    i32 8001, label %93
    i32 7001, label %93
  ]

79:                                               ; preds = %78
  %80 = bitcast float %71 to i32
  %81 = and i32 %80, -4096
  %82 = bitcast i32 %81 to float
  %83 = fsub float %71, %82
  %84 = bitcast float %16 to i32
  %85 = and i32 %84, -4096
  %86 = bitcast i32 %85 to float
  %87 = fsub float %16, %86
  %88 = fneg float %72
  %89 = tail call float @llvm.fmuladd.f32(float %82, float %86, float %88)
  %90 = tail call float @llvm.fmuladd.f32(float %82, float %87, float %89)
  %91 = tail call float @llvm.fmuladd.f32(float %83, float %86, float %90)
  %92 = tail call float @llvm.fmuladd.f32(float %83, float %87, float %91)
  br label %96

93:                                               ; preds = %78, %78
  %94 = fneg float %72
  %95 = tail call float @llvm.fma.f32(float %71, float %16, float %94)
  br label %96

96:                                               ; preds = %93, %79
  %97 = phi float [ %95, %93 ], [ %92, %79 ]
  %98 = insertelement <2 x float> poison, float %97, i64 0
  %99 = insertelement <2 x float> %98, float %72, i64 1
  switch i32 %20, label %106 [
    i32 8001, label %100
    i32 7001, label %100
  ]

100:                                              ; preds = %96, %96, %73
  %101 = phi <2 x float> [ %99, %96 ], [ %99, %96 ], [ %77, %73 ]
  %102 = phi float [ %97, %96 ], [ %97, %96 ], [ %75, %73 ]
  %103 = extractelement <2 x float> %15, i64 0
  %104 = tail call float @llvm.fma.f32(float %71, float %103, float %102)
  %105 = insertelement <2 x float> %101, float %104, i64 0
  br label %110

106:                                              ; preds = %96
  %107 = extractelement <2 x float> %15, i64 0
  %108 = tail call float @llvm.fmuladd.f32(float %71, float %107, float %97)
  %109 = insertelement <2 x float> %99, float %108, i64 0
  br label %110

110:                                              ; preds = %100, %106
  %111 = phi float [ %103, %100 ], [ %107, %106 ]
  %112 = phi <2 x float> [ %105, %100 ], [ %109, %106 ]
  %113 = fsub float %65, %70
  %114 = fadd float %69, %113
  %115 = extractelement <2 x float> %112, i64 1
  %116 = extractelement <2 x float> %112, i64 0
  %117 = fadd float %115, %116
  %118 = fsub float %117, %115
  %119 = fsub float %70, %117
  %120 = fsub float %70, %119
  %121 = fsub float %120, %117
  %122 = fadd float %114, %121
  %123 = fsub float %118, %116
  %124 = fadd float %123, %122
  %125 = fadd float %119, %124
  %126 = fmul float %17, %125
  %127 = fadd float %17, %71
  %128 = fsub float %127, %17
  %129 = fsub float %71, %128
  %130 = fadd float %129, %126
  %131 = fadd float %127, %130
  %132 = fsub float %131, %127
  %133 = fsub float %130, %132
  %134 = tail call spir_func float @_Z5ldexpfi(float noundef %131, i32 noundef -2) #38
  %135 = tail call spir_func float @_Z5ldexpfi(float noundef %133, i32 noundef -2) #38
  %136 = fadd float %16, %134
  %137 = fsub float %136, %16
  %138 = fsub float %134, %137
  %139 = fadd float %111, %135
  %140 = fadd float %139, %138
  %141 = fadd float %136, %140
  %142 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %143 = icmp eq i8 %142, 0
  %144 = fcmp ogt float %2, 0x40565A9F80000000
  %145 = and i1 %144, %143
  %146 = select i1 %145, float 0x7FF0000000000000, float %141
  ret float %146
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_cosh_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = fmul float %3, 0x3FF7154760000000
  %5 = tail call float @llvm.exp2.f32(float %4)
  %6 = fneg float %4
  %7 = tail call float @llvm.exp2.f32(float %6)
  %8 = fadd float %5, %7
  %9 = fmul float %8, 5.000000e-01
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> poison, half %10, i64 0
  %12 = extractelement <2 x half> %0, i64 1
  %13 = fpext half %12 to float
  %14 = fmul float %13, 0x3FF7154760000000
  %15 = tail call float @llvm.exp2.f32(float %14)
  %16 = fneg float %14
  %17 = tail call float @llvm.exp2.f32(float %16)
  %18 = fadd float %15, %17
  %19 = fmul float %18, 5.000000e-01
  %20 = fptrunc float %19 to half
  %21 = insertelement <2 x half> %11, half %20, i64 1
  ret <2 x half> %21
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_cosh_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = fpext half %0 to float
  %3 = fmul float %2, 0x3FF7154760000000
  %4 = tail call float @llvm.exp2.f32(float %3)
  %5 = fneg float %3
  %6 = tail call float @llvm.exp2.f32(float %5)
  %7 = fadd float %4, %6
  %8 = fmul float %7, 5.000000e-01
  %9 = fptrunc float %8 to half
  ret half %9
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_cospi_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca %struct.redret.8, align 8
  %4 = alloca %struct.scret, align 8
  %5 = tail call double @llvm.fabs.f64(double %0)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %3) #39
  call spir_func void @__ocmlpriv_trigpired_f64(ptr dead_on_unwind nonnull writable sret(%struct.redret.8) align 8 %3, double noundef %5) #43
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #39
  %6 = load double, ptr %3, align 8, !tbaa !53
  call spir_func void @__ocmlpriv_sincospired_f64(ptr dead_on_unwind nonnull writable sret(%struct.scret) align 8 %4, double noundef %6) #43
  %7 = getelementptr inbounds %struct.scret, ptr %4, i64 0, i32 1
  %8 = load double, ptr %7, align 8, !tbaa !35
  %9 = fneg double %8
  %10 = getelementptr inbounds %struct.redret.8, ptr %3, i64 0, i32 1
  %11 = load i32, ptr %10, align 8, !tbaa !55
  %12 = and i32 %11, 1
  %13 = icmp eq i32 %12, 0
  %14 = load double, ptr %4, align 8
  %15 = select i1 %13, double %14, double %9
  %16 = bitcast double %15 to <2 x i32>
  %17 = icmp sgt i32 %11, 1
  %18 = select i1 %17, i32 -2147483648, i32 0
  %19 = extractelement <2 x i32> %16, i64 1
  %20 = xor i32 %19, %18
  %21 = insertelement <2 x i32> %16, i32 %20, i64 1
  %22 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %38

24:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %5, ptr %2, align 8, !tbaa !19
  %25 = addrspacecast ptr %2 to ptr addrspace(4)
  %26 = load i128, ptr addrspace(4) %25, align 8, !tbaa !29
  %27 = and i128 %26, 9223372036854775807
  %28 = icmp eq i128 %27, 0
  br i1 %28, label %29, label %30

29:                                               ; preds = %24
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  br label %38

30:                                               ; preds = %24
  %31 = and i128 %26, 9218868437227405312
  %32 = icmp ne i128 %31, 0
  %33 = and i128 %26, 4503599627370495
  %34 = icmp eq i128 %33, 0
  %35 = or i1 %32, %34
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %36 = freeze i1 %35
  %37 = select i1 %36, <2 x i32> <i32 0, i32 2146959360>, <2 x i32> %21
  br label %38

38:                                               ; preds = %30, %29, %1
  %39 = phi <2 x i32> [ %21, %1 ], [ %21, %29 ], [ %37, %30 ]
  %40 = bitcast <2 x i32> %39 to double
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %3) #39
  ret double %40
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_trigpired_f64(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.redret.8) align 8 %0, double noundef %1) local_unnamed_addr #29 {
  %3 = fmul double %1, 5.000000e-01
  %4 = fptosi double %3 to i64
  %5 = sitofp i64 %4 to double
  %6 = fsub double %3, %5
  %7 = tail call double @llvm.fabs.f64(double %3)
  %8 = bitcast double %7 to i64
  %9 = icmp eq i64 %8, 9218868437227405312
  %10 = fmul double %6, 2.000000e+00
  %11 = select i1 %9, double 0.000000e+00, double %10
  %12 = fcmp ogt double %1, 1.000000e+00
  %13 = select i1 %12, double %11, double %1
  %14 = fmul double %13, 2.000000e+00
  %15 = tail call double @llvm.rint.f64(double %14)
  %16 = tail call double @llvm.fma.f64(double %15, double -5.000000e-01, double %13)
  store double %16, ptr %0, align 8, !tbaa !53
  %17 = fptosi double %15 to i32
  %18 = and i32 %17, 3
  %19 = getelementptr inbounds %struct.redret.8, ptr %0, i64 0, i32 1
  store i32 %18, ptr %19, align 8, !tbaa !55
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_sincospired_f64(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.scret) align 8 %0, double noundef %1) local_unnamed_addr #29 {
  %3 = fmul double %1, %1
  %4 = tail call double @llvm.fma.f64(double %3, double 0x3F3E357EF99EB0BB, double 0xBF7E2FE76FDFFD2B)
  %5 = tail call double @llvm.fma.f64(double %3, double %4, double 0x3FB50782D5F14825)
  %6 = tail call double @llvm.fma.f64(double %3, double %5, double 0xBFE32D2CCDFE9424)
  %7 = tail call double @llvm.fma.f64(double %3, double %6, double 0x400466BC67754FFF)
  %8 = tail call double @llvm.fma.f64(double %3, double %7, double 0xC014ABBCE625BE09)
  %9 = fmul double %3, %1
  %10 = fmul double %9, %8
  %11 = tail call double @llvm.fma.f64(double %1, double 0x400921FB54442D18, double %10)
  %12 = tail call double @llvm.fma.f64(double %3, double 0xBF1B167302E21C33, double 0x3F5F9C89CA1D4F33)
  %13 = tail call double @llvm.fma.f64(double %3, double %12, double 0xBF9A6D1E7294BFF9)
  %14 = tail call double @llvm.fma.f64(double %3, double %13, double 0x3FCE1F5067B90B37)
  %15 = tail call double @llvm.fma.f64(double %3, double %14, double 0xBFF55D3C7E3C325B)
  %16 = tail call double @llvm.fma.f64(double %3, double %15, double 0x40103C1F081B5A67)
  %17 = tail call double @llvm.fma.f64(double %3, double %16, double 0xC013BD3CC9BE45DE)
  %18 = tail call double @llvm.fma.f64(double %3, double %17, double 1.000000e+00)
  store double %18, ptr %0, align 8, !tbaa !37
  %19 = getelementptr inbounds %struct.scret, ptr %0, i64 0, i32 1
  store double %11, ptr %19, align 8, !tbaa !35
  ret void
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_cospi_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca %struct.redret.0, align 4
  %4 = alloca %struct.scret.1, align 4
  %5 = tail call float @llvm.fabs.f32(float %0)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #39
  call spir_func void @__ocmlpriv_trigpired_f32(ptr dead_on_unwind nonnull writable sret(%struct.redret.0) align 4 %3, float noundef %5) #43
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #39
  %6 = load float, ptr %3, align 4, !tbaa !38
  call spir_func void @__ocmlpriv_sincospired_f32(ptr dead_on_unwind nonnull writable sret(%struct.scret.1) align 4 %4, float noundef %6) #43
  %7 = load float, ptr %4, align 4, !tbaa !43
  %8 = fneg float %7
  %9 = getelementptr inbounds %struct.redret.0, ptr %3, i64 0, i32 1
  %10 = load i32, ptr %9, align 4, !tbaa !40
  %11 = and i32 %10, 1
  %12 = icmp eq i32 %11, 0
  %13 = getelementptr inbounds %struct.scret.1, ptr %4, i64 0, i32 1
  %14 = load float, ptr %13, align 4
  %15 = select i1 %12, float %14, float %8
  %16 = bitcast float %15 to i32
  %17 = icmp sgt i32 %10, 1
  %18 = select i1 %17, i32 -2147483648, i32 0
  %19 = xor i32 %18, %16
  %20 = bitcast i32 %19 to float
  %21 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %37

23:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %5, ptr %2, align 8, !tbaa !16
  %24 = addrspacecast ptr %2 to ptr addrspace(4)
  %25 = load i64, ptr addrspace(4) %24, align 8, !tbaa !12
  %26 = and i64 %25, 2147483647
  %27 = icmp eq i64 %26, 0
  br i1 %27, label %28, label %29

28:                                               ; preds = %23
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %37

29:                                               ; preds = %23
  %30 = and i64 %25, 2139095040
  %31 = icmp ne i64 %30, 0
  %32 = and i64 %25, 8388607
  %33 = icmp eq i64 %32, 0
  %34 = or i1 %31, %33
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %35 = freeze i1 %34
  %36 = select i1 %35, float 0x7FF8000000000000, float %20
  br label %37

37:                                               ; preds = %29, %28, %1
  %38 = phi float [ %20, %1 ], [ %20, %28 ], [ %36, %29 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #39
  ret float %38
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_trigpired_f32(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.redret.0) align 4 %0, float noundef %1) local_unnamed_addr #30 {
  %3 = fmul float %1, 5.000000e-01
  %4 = fptosi float %3 to i32
  %5 = sitofp i32 %4 to float
  %6 = fsub float %3, %5
  %7 = tail call float @llvm.fabs.f32(float %3)
  %8 = bitcast float %7 to i32
  %9 = icmp eq i32 %8, 2139095040
  %10 = fmul float %6, 2.000000e+00
  %11 = select i1 %9, float 0.000000e+00, float %10
  %12 = fcmp ogt float %1, 1.000000e+00
  %13 = select i1 %12, float %11, float %1
  %14 = fmul float %13, 2.000000e+00
  %15 = tail call float @llvm.rint.f32(float %14)
  %16 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %15, float noundef -5.000000e-01, float noundef %13) #38
  store float %16, ptr %0, align 4, !tbaa !38
  %17 = fptosi float %15 to i32
  %18 = and i32 %17, 3
  %19 = getelementptr inbounds %struct.redret.0, ptr %0, i64 0, i32 1
  store i32 %18, ptr %19, align 4, !tbaa !40
  ret void
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_sincospired_f32(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.scret.1) align 4 %0, float noundef %1) local_unnamed_addr #30 {
  %3 = fmul float %1, %1
  %4 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef 0x3FCEB54820000000, float noundef 0xBFE3E497C0000000) #38
  %5 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %4, float noundef 0x400468E6C0000000) #38
  %6 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %5, float noundef 0xC014ABC1C0000000) #38
  %7 = fmul float %3, %1
  %8 = fmul float %7, %6
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %1, float noundef 0x400921FB60000000, float noundef %8) #38
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef 0x3FA97CA880000000, float noundef 0x3FCC85D3A0000000) #38
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %10, float noundef 0xBFF55A3B40000000) #38
  %12 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %11, float noundef 0x40103C1A60000000) #38
  %13 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %12, float noundef 0xC013BD3CC0000000) #38
  %14 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %13, float noundef 1.000000e+00) #38
  %15 = getelementptr inbounds %struct.scret.1, ptr %0, i64 0, i32 1
  store float %14, ptr %15, align 4, !tbaa !41
  store float %9, ptr %0, align 4, !tbaa !43
  ret void
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_cospi_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_cospi_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_cospi_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_cospi_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = alloca %struct.redret.2, align 2
  %3 = alloca %struct.scret.3, align 2
  %4 = tail call half @llvm.fabs.f16(half %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  call spir_func void @__ocmlpriv_trigpired_f16(ptr dead_on_unwind nonnull writable sret(%struct.redret.2) align 2 %2, half noundef %4) #43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %5 = load half, ptr %2, align 2, !tbaa !45
  call spir_func void @__ocmlpriv_sincospired_f16(ptr dead_on_unwind nonnull writable sret(%struct.scret.3) align 2 %3, half noundef %5) #43
  %6 = load half, ptr %3, align 2, !tbaa !49
  %7 = fneg half %6
  %8 = getelementptr inbounds %struct.redret.2, ptr %2, i64 0, i32 1
  %9 = load i16, ptr %8, align 2, !tbaa !51
  %10 = and i16 %9, 1
  %11 = icmp eq i16 %10, 0
  %12 = getelementptr inbounds %struct.scret.3, ptr %3, i64 0, i32 1
  %13 = load half, ptr %12, align 2
  %14 = select i1 %11, half %13, half %7
  %15 = bitcast half %14 to i16
  %16 = icmp sgt i16 %9, 1
  %17 = select i1 %16, i16 -32768, i16 0
  %18 = xor i16 %17, %15
  %19 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %26

21:                                               ; preds = %1
  %22 = fptoui half %4 to i16
  %23 = call spir_func i32 @__builtin_generic_class_f16.31(i16 noundef zeroext %22) #39
  %24 = icmp eq i32 %23, 0
  %25 = select i1 %24, i16 32256, i16 %18
  br label %26

26:                                               ; preds = %21, %1
  %27 = phi i16 [ %18, %1 ], [ %25, %21 ]
  %28 = bitcast i16 %27 to half
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret half %28
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_trigpired_f16(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.redret.2) align 2 %0, half noundef %1) local_unnamed_addr #32 {
  %3 = fmul half %1, 0xH3800
  %4 = tail call spir_func float @__builtin_generic_frac_f16.156(half noundef %3) #39
  %5 = fmul float %4, 2.000000e+00
  %6 = fptrunc float %5 to half
  %7 = fcmp ogt half %1, 0xH3C00
  %8 = select i1 %7, half %6, half %1
  %9 = fmul half %8, 0xH4000
  %10 = tail call half @llvm.rint.f16(half %9)
  %11 = tail call half @llvm.fma.f16(half %10, half 0xHB800, half %8)
  store half %11, ptr %0, align 2, !tbaa !45
  %12 = fptosi half %10 to i16
  %13 = and i16 %12, 3
  %14 = getelementptr inbounds %struct.redret.2, ptr %0, i64 0, i32 1
  store i16 %13, ptr %14, align 2, !tbaa !51
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_sincospired_f16(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.scret.3) align 2 %0, half noundef %1) local_unnamed_addr #29 {
  %3 = fmul half %1, %1
  %4 = tail call half @llvm.fma.f16(half %3, half 0xH3EE1, half 0xHC51B)
  %5 = fmul half %3, %1
  %6 = fmul half %5, %4
  %7 = tail call half @llvm.fma.f16(half %1, half 0xH4248, half %6)
  %8 = tail call half @llvm.fma.f16(half %3, half 0xH43EC, half 0xHC4EF)
  %9 = tail call half @llvm.fma.f16(half %3, half %8, half 0xH3C00)
  %10 = getelementptr inbounds %struct.scret.3, ptr %0, i64 0, i32 1
  store half %9, ptr %10, align 2, !tbaa !52
  store half %7, ptr %0, align 2, !tbaa !49
  ret void
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func i32 @__builtin_generic_class_f16.31(i16 noundef zeroext %0) unnamed_addr #25 {
  %2 = and i16 %0, 32767
  %3 = icmp eq i16 %2, 0
  br i1 %3, label %12, label %4

4:                                                ; preds = %1
  %5 = zext i16 %0 to i32
  %6 = and i32 %5, 31744
  %7 = icmp eq i32 %6, 0
  %8 = and i32 %5, 1023
  %9 = icmp ne i32 %8, 0
  %10 = and i1 %7, %9
  %11 = sext i1 %10 to i32
  br label %12

12:                                               ; preds = %4, %1
  %13 = phi i32 [ -1, %1 ], [ %11, %4 ]
  ret i32 %13
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func float @__builtin_generic_frac_f16.156(half noundef %0) unnamed_addr #25 {
  %2 = fptosi half %0 to i16
  %3 = sitofp i16 %2 to half
  %4 = fsub half %0, %3
  %5 = tail call half @llvm.fabs.f16(half %0)
  %6 = bitcast half %5 to i16
  %7 = icmp eq i16 %6, 31744
  %8 = fpext half %4 to float
  %9 = select i1 %7, float 0.000000e+00, float %8
  ret float %9
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.rint.f16(half) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_csin_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x double> %0, i64 1
  %3 = fneg double %2
  %4 = insertelement <2 x double> poison, double %3, i64 0
  %5 = shufflevector <2 x double> %4, <2 x double> %0, <2 x i32> <i32 0, i32 2>
  %6 = tail call spir_func <2 x double> @__ocml_csinh_f64(<2 x double> noundef %5) #38
  %7 = extractelement <2 x double> %6, i64 1
  %8 = insertelement <2 x double> poison, double %7, i64 0
  %9 = extractelement <2 x double> %6, i64 0
  %10 = fneg double %9
  %11 = insertelement <2 x double> %8, double %10, i64 1
  ret <2 x double> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_csinh_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca double, align 8
  %4 = alloca double, align 8
  %5 = alloca double, align 8
  %6 = extractelement <2 x double> %0, i64 0
  %7 = tail call double @llvm.fabs.f64(double %6)
  %8 = fadd double %7, 0xBFF62E42FEFA39EF
  %9 = fsub double %8, %7
  %10 = fsub double %9, %8
  %11 = fadd double %7, %10
  %12 = fadd double %9, 0x3FF62E42FEFA39EF
  %13 = fsub double %11, %12
  %14 = fadd double %13, 0xBC8ABC9E3B39803F
  %15 = fadd double %8, %14
  %16 = fsub double %8, %15
  %17 = fadd double %14, %16
  %18 = insertelement <2 x double> poison, double %17, i64 0
  %19 = insertelement <2 x double> %18, double %15, i64 1
  %20 = tail call spir_func <2 x double> @__ocmlpriv_epexpep_f64(<2 x double> noundef %19) #38
  %21 = extractelement <2 x double> %20, i64 1
  %22 = fptrunc double %21 to float
  %23 = tail call spir_func float @_Z12native_recipf(float noundef %22) #38
  %24 = fpext float %23 to double
  %25 = fneg double %21
  %26 = tail call double @llvm.fma.f64(double %25, double %24, double 1.000000e+00)
  %27 = tail call double @llvm.fma.f64(double %26, double %24, double %24)
  %28 = tail call double @llvm.fma.f64(double %25, double %27, double 1.000000e+00)
  %29 = tail call double @llvm.fma.f64(double %28, double %27, double %27)
  %30 = fmul double %21, %29
  %31 = fneg double %30
  %32 = tail call double @llvm.fma.f64(double %29, double %21, double %31)
  %33 = extractelement <2 x double> %20, i64 0
  %34 = tail call double @llvm.fma.f64(double %29, double %33, double %32)
  %35 = fadd double %30, %34
  %36 = fsub double %35, %30
  %37 = fsub double 1.000000e+00, %35
  %38 = fsub double 1.000000e+00, %37
  %39 = fsub double %38, %35
  %40 = fsub double %36, %34
  %41 = fadd double %40, %39
  %42 = fadd double %37, %41
  %43 = fsub double %37, %42
  %44 = fadd double %41, %43
  %45 = fmul double %29, %42
  %46 = fmul double %21, %45
  %47 = fneg double %46
  %48 = tail call double @llvm.fma.f64(double %45, double %21, double %47)
  %49 = tail call double @llvm.fma.f64(double %45, double %33, double %48)
  %50 = fadd double %46, %49
  %51 = fsub double %50, %46
  %52 = fsub double %42, %50
  %53 = fsub double %42, %52
  %54 = fsub double %53, %50
  %55 = fadd double %44, %54
  %56 = fsub double %51, %49
  %57 = fadd double %56, %55
  %58 = fadd double %52, %57
  %59 = fmul double %29, %58
  %60 = fadd double %29, %45
  %61 = fsub double %60, %29
  %62 = fsub double %45, %61
  %63 = fadd double %62, %59
  %64 = fadd double %60, %63
  %65 = fsub double %64, %60
  %66 = fsub double %63, %65
  %67 = tail call spir_func double @_Z5ldexpdi(double noundef %64, i32 noundef -4) #38
  %68 = tail call spir_func double @_Z5ldexpdi(double noundef %66, i32 noundef -4) #38
  %69 = fadd double %21, %67
  %70 = fsub double %69, %21
  %71 = fsub double %67, %70
  %72 = fadd double %33, %68
  %73 = fadd double %72, %71
  %74 = fadd double %69, %73
  %75 = fsub double %21, %67
  %76 = fsub double %21, %75
  %77 = fsub double %76, %67
  %78 = fadd double %33, %77
  %79 = fsub double %78, %68
  %80 = fadd double %75, %79
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5) #39
  %81 = extractelement <2 x double> %0, i64 1
  %82 = call spir_func double @__ocml_sincos_f64(double noundef %81, ptr noundef nonnull %5) #40
  %83 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %84 = icmp eq i8 %83, 0
  %85 = fcmp oge double %7, 0x4086395A2079B70C
  %86 = and i1 %85, %84
  %87 = select i1 %86, double 0x7FF0000000000000, double %80
  %88 = select i1 %86, double 0x7FF0000000000000, double %74
  %89 = fcmp oge double %7, 0x3E40000000000000
  %90 = select i1 %89, double %87, double %7
  %91 = call double @llvm.copysign.f64(double %90, double %6)
  %92 = load double, ptr %5, align 8, !tbaa !19
  %93 = fmul double %92, %91
  %94 = zext i1 %89 to i32
  %95 = call spir_func double @_Z5ldexpdi(double noundef %93, i32 noundef %94) #38
  %96 = fmul double %82, %88
  %97 = call spir_func double @_Z5ldexpdi(double noundef %96, i32 noundef 1) #38
  br i1 %84, label %98, label %128

98:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  store double %7, ptr %4, align 8, !tbaa !19
  %99 = addrspacecast ptr %4 to ptr addrspace(4)
  %100 = load i128, ptr addrspace(4) %99, align 8, !tbaa !29
  switch i128 %100, label %101 [
    i128 9218868437227405312, label %105
    i128 18442240474082181120, label %105
  ]

101:                                              ; preds = %98
  %102 = and i128 %100, 9223372036854775807
  %103 = icmp eq i128 %102, 0
  %104 = sext i1 %103 to i32
  br label %105

105:                                              ; preds = %101, %98, %98
  %106 = phi i32 [ -1, %98 ], [ -1, %98 ], [ %104, %101 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %81, ptr %3, align 8, !tbaa !19
  %107 = addrspacecast ptr %3 to ptr addrspace(4)
  %108 = load i128, ptr addrspace(4) %107, align 8, !tbaa !29
  switch i128 %108, label %109 [
    i128 9218868437227405312, label %113
    i128 18442240474082181120, label %113
  ]

109:                                              ; preds = %105
  %110 = and i128 %108, 9221120237041090560
  %111 = icmp ne i128 %110, 0
  %112 = sext i1 %111 to i32
  br label %113

113:                                              ; preds = %109, %105, %105
  %114 = phi i32 [ -1, %105 ], [ -1, %105 ], [ %112, %109 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  %115 = and i32 %114, %106
  %116 = icmp eq i32 %115, 0
  %117 = select i1 %116, double %95, double %6
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %7, ptr %2, align 8, !tbaa !19
  %118 = addrspacecast ptr %2 to ptr addrspace(4)
  %119 = load i128, ptr addrspace(4) %118, align 8, !tbaa !29
  switch i128 %119, label %120 [
    i128 9218868437227405312, label %123
    i128 18442240474082181120, label %123
  ]

120:                                              ; preds = %113
  %121 = and i128 %119, 9221120237041090560
  %122 = icmp eq i128 %121, 0
  br label %123

123:                                              ; preds = %120, %113, %113
  %124 = phi i1 [ false, %113 ], [ false, %113 ], [ %122, %120 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %125 = fcmp une double %81, 0.000000e+00
  %126 = or i1 %125, %124
  %127 = select i1 %126, double %97, double %81
  br label %128

128:                                              ; preds = %123, %1
  %129 = phi double [ %95, %1 ], [ %117, %123 ]
  %130 = phi double [ %97, %1 ], [ %127, %123 ]
  %131 = insertelement <2 x double> poison, double %129, i64 0
  %132 = insertelement <2 x double> %131, double %130, i64 1
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5) #39
  ret <2 x double> %132
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_csin_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x float> %0, i64 1
  %3 = fneg float %2
  %4 = insertelement <2 x float> poison, float %3, i64 0
  %5 = shufflevector <2 x float> %4, <2 x float> %0, <2 x i32> <i32 0, i32 2>
  %6 = tail call spir_func <2 x float> @__ocml_csinh_f32(<2 x float> noundef %5) #38
  %7 = extractelement <2 x float> %6, i64 1
  %8 = insertelement <2 x float> poison, float %7, i64 0
  %9 = extractelement <2 x float> %6, i64 0
  %10 = fneg float %9
  %11 = insertelement <2 x float> %8, float %10, i64 1
  ret <2 x float> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_csinh_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca float, align 8
  %4 = alloca float, align 8
  %5 = alloca float, align 4
  %6 = extractelement <2 x float> %0, i64 0
  %7 = tail call float @llvm.fabs.f32(float %6)
  %8 = fadd float %7, 0xBFF62E4300000000
  %9 = fsub float %8, %7
  %10 = fsub float %9, %8
  %11 = fadd float %7, %10
  %12 = fadd float %9, 0x3FF62E4300000000
  %13 = fsub float %11, %12
  %14 = fadd float %13, 0x3E305C6100000000
  %15 = fadd float %8, %14
  %16 = fsub float %8, %15
  %17 = fadd float %14, %16
  %18 = insertelement <2 x float> poison, float %17, i64 0
  %19 = insertelement <2 x float> %18, float %15, i64 1
  %20 = tail call spir_func <2 x float> @__ocmlpriv_epexpep_f32(<2 x float> noundef %19) #38
  %21 = extractelement <2 x float> %20, i64 1
  %22 = tail call spir_func float @_Z12native_recipf(float noundef %21) #38
  %23 = fmul float %21, %22
  %24 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %25 = freeze i32 %24
  %26 = icmp sgt i32 %25, 8999
  br i1 %26, label %27, label %32

27:                                               ; preds = %1
  %28 = fneg float %23
  %29 = tail call float @llvm.fma.f32(float %22, float %21, float %28)
  %30 = insertelement <2 x float> poison, float %29, i64 0
  %31 = insertelement <2 x float> %30, float %23, i64 1
  br label %54

32:                                               ; preds = %1
  switch i32 %25, label %33 [
    i32 8001, label %47
    i32 7001, label %47
  ]

33:                                               ; preds = %32
  %34 = bitcast float %22 to i32
  %35 = and i32 %34, -4096
  %36 = bitcast i32 %35 to float
  %37 = fsub float %22, %36
  %38 = bitcast float %21 to i32
  %39 = and i32 %38, -4096
  %40 = bitcast i32 %39 to float
  %41 = fsub float %21, %40
  %42 = fneg float %23
  %43 = tail call float @llvm.fmuladd.f32(float %36, float %40, float %42)
  %44 = tail call float @llvm.fmuladd.f32(float %36, float %41, float %43)
  %45 = tail call float @llvm.fmuladd.f32(float %37, float %40, float %44)
  %46 = tail call float @llvm.fmuladd.f32(float %37, float %41, float %45)
  br label %50

47:                                               ; preds = %32, %32
  %48 = fneg float %23
  %49 = tail call float @llvm.fma.f32(float %22, float %21, float %48)
  br label %50

50:                                               ; preds = %47, %33
  %51 = phi float [ %49, %47 ], [ %46, %33 ]
  %52 = insertelement <2 x float> poison, float %51, i64 0
  %53 = insertelement <2 x float> %52, float %23, i64 1
  switch i32 %25, label %60 [
    i32 8001, label %54
    i32 7001, label %54
  ]

54:                                               ; preds = %50, %50, %27
  %55 = phi <2 x float> [ %53, %50 ], [ %53, %50 ], [ %31, %27 ]
  %56 = phi float [ %51, %50 ], [ %51, %50 ], [ %29, %27 ]
  %57 = extractelement <2 x float> %20, i64 0
  %58 = tail call float @llvm.fma.f32(float %22, float %57, float %56)
  %59 = insertelement <2 x float> %55, float %58, i64 0
  br label %64

60:                                               ; preds = %50
  %61 = extractelement <2 x float> %20, i64 0
  %62 = tail call float @llvm.fmuladd.f32(float %22, float %61, float %51)
  %63 = insertelement <2 x float> %53, float %62, i64 0
  br label %64

64:                                               ; preds = %60, %54
  %65 = phi <2 x float> [ %59, %54 ], [ %63, %60 ]
  %66 = extractelement <2 x float> %65, i64 1
  %67 = extractelement <2 x float> %65, i64 0
  %68 = fadd float %66, %67
  %69 = fsub float %68, %66
  %70 = fsub float 1.000000e+00, %68
  %71 = fsub float 1.000000e+00, %70
  %72 = fsub float %71, %68
  %73 = fsub float %69, %67
  %74 = fadd float %73, %72
  %75 = fadd float %70, %74
  %76 = fmul float %22, %75
  %77 = fmul float %21, %76
  br i1 %26, label %78, label %83

78:                                               ; preds = %64
  %79 = fneg float %77
  %80 = tail call float @llvm.fma.f32(float %76, float %21, float %79)
  %81 = insertelement <2 x float> poison, float %80, i64 0
  %82 = insertelement <2 x float> %81, float %77, i64 1
  br label %105

83:                                               ; preds = %64
  switch i32 %25, label %84 [
    i32 8001, label %98
    i32 7001, label %98
  ]

84:                                               ; preds = %83
  %85 = bitcast float %76 to i32
  %86 = and i32 %85, -4096
  %87 = bitcast i32 %86 to float
  %88 = fsub float %76, %87
  %89 = bitcast float %21 to i32
  %90 = and i32 %89, -4096
  %91 = bitcast i32 %90 to float
  %92 = fsub float %21, %91
  %93 = fneg float %77
  %94 = tail call float @llvm.fmuladd.f32(float %87, float %91, float %93)
  %95 = tail call float @llvm.fmuladd.f32(float %87, float %92, float %94)
  %96 = tail call float @llvm.fmuladd.f32(float %88, float %91, float %95)
  %97 = tail call float @llvm.fmuladd.f32(float %88, float %92, float %96)
  br label %101

98:                                               ; preds = %83, %83
  %99 = fneg float %77
  %100 = tail call float @llvm.fma.f32(float %76, float %21, float %99)
  br label %101

101:                                              ; preds = %98, %84
  %102 = phi float [ %100, %98 ], [ %97, %84 ]
  %103 = insertelement <2 x float> poison, float %102, i64 0
  %104 = insertelement <2 x float> %103, float %77, i64 1
  switch i32 %25, label %111 [
    i32 8001, label %105
    i32 7001, label %105
  ]

105:                                              ; preds = %101, %101, %78
  %106 = phi <2 x float> [ %104, %101 ], [ %104, %101 ], [ %82, %78 ]
  %107 = phi float [ %102, %101 ], [ %102, %101 ], [ %80, %78 ]
  %108 = extractelement <2 x float> %20, i64 0
  %109 = tail call float @llvm.fma.f32(float %76, float %108, float %107)
  %110 = insertelement <2 x float> %106, float %109, i64 0
  br label %115

111:                                              ; preds = %101
  %112 = extractelement <2 x float> %20, i64 0
  %113 = tail call float @llvm.fmuladd.f32(float %76, float %112, float %102)
  %114 = insertelement <2 x float> %104, float %113, i64 0
  br label %115

115:                                              ; preds = %105, %111
  %116 = phi float [ %108, %105 ], [ %112, %111 ]
  %117 = phi <2 x float> [ %110, %105 ], [ %114, %111 ]
  %118 = fsub float %70, %75
  %119 = fadd float %74, %118
  %120 = extractelement <2 x float> %117, i64 1
  %121 = extractelement <2 x float> %117, i64 0
  %122 = fadd float %120, %121
  %123 = fsub float %122, %120
  %124 = fsub float %75, %122
  %125 = fsub float %75, %124
  %126 = fsub float %125, %122
  %127 = fadd float %119, %126
  %128 = fsub float %123, %121
  %129 = fadd float %128, %127
  %130 = fadd float %124, %129
  %131 = fmul float %22, %130
  %132 = fadd float %22, %76
  %133 = fsub float %132, %22
  %134 = fsub float %76, %133
  %135 = fadd float %134, %131
  %136 = fadd float %132, %135
  %137 = fsub float %136, %132
  %138 = fsub float %135, %137
  %139 = tail call spir_func float @_Z5ldexpfi(float noundef %136, i32 noundef -4) #38
  %140 = tail call spir_func float @_Z5ldexpfi(float noundef %138, i32 noundef -4) #38
  %141 = fadd float %21, %139
  %142 = fsub float %141, %21
  %143 = fsub float %139, %142
  %144 = fadd float %116, %140
  %145 = fadd float %144, %143
  %146 = fadd float %141, %145
  %147 = fsub float %21, %139
  %148 = fsub float %21, %147
  %149 = fsub float %148, %139
  %150 = fadd float %116, %149
  %151 = fsub float %150, %140
  %152 = fadd float %147, %151
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %153 = extractelement <2 x float> %0, i64 1
  %154 = call spir_func float @__ocml_sincos_f32(float noundef %153, ptr noundef nonnull %5) #40
  %155 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %156 = icmp eq i8 %155, 0
  %157 = fcmp oge float %7, 0x405686FC00000000
  %158 = and i1 %157, %156
  %159 = select i1 %158, float 0x7FF0000000000000, float %152
  %160 = select i1 %158, float 0x7FF0000000000000, float %146
  %161 = fcmp oge float %7, 0x3F30000000000000
  %162 = select i1 %161, float %159, float %7
  %163 = call float @llvm.copysign.f32(float %162, float %6)
  %164 = load float, ptr %5, align 4, !tbaa !16
  %165 = fmul float %164, %163
  %166 = zext i1 %161 to i32
  %167 = call spir_func float @_Z5ldexpfi(float noundef %165, i32 noundef %166) #38
  %168 = fmul float %154, %160
  %169 = call spir_func float @_Z5ldexpfi(float noundef %168, i32 noundef 1) #38
  br i1 %156, label %170, label %200

170:                                              ; preds = %115
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  store float %7, ptr %4, align 8, !tbaa !16
  %171 = addrspacecast ptr %4 to ptr addrspace(4)
  %172 = load i64, ptr addrspace(4) %171, align 8, !tbaa !12
  switch i64 %172, label %173 [
    i64 2139095040, label %177
    i64 -8388608, label %177
  ]

173:                                              ; preds = %170
  %174 = and i64 %172, 2147483647
  %175 = icmp eq i64 %174, 0
  %176 = sext i1 %175 to i32
  br label %177

177:                                              ; preds = %173, %170, %170
  %178 = phi i32 [ -1, %170 ], [ -1, %170 ], [ %176, %173 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %153, ptr %3, align 8, !tbaa !16
  %179 = addrspacecast ptr %3 to ptr addrspace(4)
  %180 = load i64, ptr addrspace(4) %179, align 8, !tbaa !12
  switch i64 %180, label %181 [
    i64 2139095040, label %185
    i64 -8388608, label %185
  ]

181:                                              ; preds = %177
  %182 = and i64 %180, 2143289344
  %183 = icmp ne i64 %182, 0
  %184 = sext i1 %183 to i32
  br label %185

185:                                              ; preds = %181, %177, %177
  %186 = phi i32 [ -1, %177 ], [ -1, %177 ], [ %184, %181 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %187 = and i32 %186, %178
  %188 = icmp eq i32 %187, 0
  %189 = select i1 %188, float %167, float %6
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %7, ptr %2, align 8, !tbaa !16
  %190 = addrspacecast ptr %2 to ptr addrspace(4)
  %191 = load i64, ptr addrspace(4) %190, align 8, !tbaa !12
  switch i64 %191, label %192 [
    i64 2139095040, label %195
    i64 -8388608, label %195
  ]

192:                                              ; preds = %185
  %193 = and i64 %191, 2143289344
  %194 = icmp eq i64 %193, 0
  br label %195

195:                                              ; preds = %192, %185, %185
  %196 = phi i1 [ false, %185 ], [ false, %185 ], [ %194, %192 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %197 = fcmp une float %153, 0.000000e+00
  %198 = or i1 %197, %196
  %199 = select i1 %198, float %169, float %153
  br label %200

200:                                              ; preds = %195, %115
  %201 = phi float [ %167, %115 ], [ %189, %195 ]
  %202 = phi float [ %169, %115 ], [ %199, %195 ]
  %203 = insertelement <2 x float> poison, float %201, i64 0
  %204 = insertelement <2 x float> %203, float %202, i64 1
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  ret <2 x float> %204
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_csqrt_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca double, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  %6 = extractelement <2 x double> %0, i64 0
  %7 = tail call double @llvm.fabs.f64(double %6)
  %8 = extractelement <2 x double> %0, i64 1
  %9 = tail call double @llvm.fabs.f64(double %8)
  %10 = tail call double @llvm.maxnum.f64(double %7, double %9)
  %11 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %12 = icmp eq i8 %11, 0
  %13 = fcmp uno double %6, %8
  %14 = and i1 %13, %12
  %15 = select i1 %14, double 0x7FF8000000000000, double %10
  %16 = fptrunc double %15 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %17 = addrspacecast ptr %5 to ptr addrspace(4)
  %18 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %16, ptr addrspace(4) noundef %17) #40
  %19 = load i32, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %20 = sub nsw i32 0, %19
  %21 = call spir_func double @_Z5ldexpdi(double noundef %7, i32 noundef %20) #38
  %22 = call spir_func double @_Z5ldexpdi(double noundef %9, i32 noundef %20) #38
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  store double %15, ptr %4, align 8, !tbaa !19
  %23 = addrspacecast ptr %4 to ptr addrspace(4)
  %24 = load i128, ptr addrspace(4) %23, align 8, !tbaa !29
  switch i128 %24, label %25 [
    i128 9218868437227405312, label %31
    i128 18442240474082181120, label %31
  ]

25:                                               ; preds = %1
  %26 = and i128 %24, 9221120237041090560
  %27 = icmp eq i128 %26, 0
  %28 = and i128 %24, 9223372036854775807
  %29 = icmp ne i128 %28, 0
  %30 = and i1 %27, %29
  br label %31

31:                                               ; preds = %25, %1, %1
  %32 = phi i1 [ false, %1 ], [ false, %1 ], [ %30, %25 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %33 = fmul double %22, %22
  %34 = call double @llvm.fma.f64(double %21, double %21, double %33)
  %35 = fptrunc double %34 to float
  %36 = call spir_func float @_Z12native_rsqrtf(float noundef %35) #38
  %37 = fpext float %36 to double
  %38 = fmul double %34, %37
  %39 = fmul double %37, 5.000000e-01
  %40 = fneg double %39
  %41 = call double @llvm.fma.f64(double %40, double %38, double 5.000000e-01)
  %42 = call double @llvm.fma.f64(double %39, double %41, double %39)
  %43 = call double @llvm.fma.f64(double %38, double %41, double %38)
  %44 = fneg double %43
  %45 = call double @llvm.fma.f64(double %44, double %43, double %34)
  %46 = call double @llvm.fma.f64(double %45, double %42, double %43)
  %47 = fcmp oeq double %34, 0.000000e+00
  %48 = select i1 %47, double %34, double %46
  %49 = select i1 %32, double %48, double %15
  %50 = and i32 %19, 1
  %51 = xor i32 %50, 1
  %52 = fadd double %21, %49
  %53 = call spir_func double @_Z5ldexpdi(double noundef %52, i32 noundef %51) #38
  %54 = fptrunc double %53 to float
  %55 = call spir_func float @_Z12native_rsqrtf(float noundef %54) #38
  %56 = fpext float %55 to double
  %57 = fmul double %53, %56
  %58 = fmul double %56, 5.000000e-01
  %59 = fneg double %58
  %60 = call double @llvm.fma.f64(double %59, double %57, double 5.000000e-01)
  %61 = call double @llvm.fma.f64(double %58, double %60, double %58)
  %62 = call double @llvm.fma.f64(double %57, double %60, double %57)
  %63 = fneg double %62
  %64 = call double @llvm.fma.f64(double %63, double %62, double %53)
  %65 = call double @llvm.fma.f64(double %64, double %61, double %62)
  %66 = fcmp oeq double %53, 0.000000e+00
  %67 = select i1 %66, double %53, double %65
  %68 = ashr i32 %19, 1
  %69 = sub nsw i32 %68, %51
  %70 = call spir_func double @_Z5ldexpdi(double noundef %67, i32 noundef %69) #38
  %71 = select i1 %32, double %70, double %15
  %72 = fdiv double %9, %71
  %73 = call spir_func double @_Z5ldexpdi(double noundef %72, i32 noundef -1) #38
  %74 = fcmp oeq double %15, 0.000000e+00
  %75 = select i1 %74, double %15, double %73
  %76 = fcmp olt double %6, 0.000000e+00
  %77 = select i1 %76, double %75, double %71
  %78 = select i1 %76, double %71, double %75
  br i1 %12, label %79, label %94

79:                                               ; preds = %31
  %80 = fcmp oeq double %9, 0x7FF0000000000000
  %81 = select i1 %80, double %9, double %77
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %6, ptr %3, align 8, !tbaa !19
  %82 = addrspacecast ptr %3 to ptr addrspace(4)
  %83 = load i128, ptr addrspace(4) %82, align 8, !tbaa !29
  %84 = icmp eq i128 %83, 18442240474082181120
  br i1 %84, label %85, label %86

85:                                               ; preds = %79
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  br label %88

86:                                               ; preds = %79
  %87 = select i1 %80, double %9, double %78
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  br label %88

88:                                               ; preds = %85, %86
  %89 = phi double [ %87, %86 ], [ %7, %85 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %6, ptr %2, align 8, !tbaa !19
  %90 = addrspacecast ptr %2 to ptr addrspace(4)
  %91 = load i128, ptr addrspace(4) %90, align 8, !tbaa !29
  %92 = icmp eq i128 %91, 9218868437227405312
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %93 = select i1 %92, double %7, double %81
  br label %94

94:                                               ; preds = %88, %31
  %95 = phi double [ %78, %31 ], [ %89, %88 ]
  %96 = phi double [ %77, %31 ], [ %93, %88 ]
  %97 = insertelement <2 x double> poison, double %96, i64 0
  %98 = call double @llvm.copysign.f64(double %95, double %8)
  %99 = insertelement <2 x double> %97, double %98, i64 1
  ret <2 x double> %99
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_csqrt_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca float, align 8
  %4 = alloca i32, align 4
  %5 = extractelement <2 x float> %0, i64 0
  %6 = tail call float @llvm.fabs.f32(float %5)
  %7 = extractelement <2 x float> %0, i64 1
  %8 = tail call float @llvm.fabs.f32(float %7)
  %9 = tail call float @llvm.maxnum.f32(float %6, float %8)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %10 = addrspacecast ptr %4 to ptr addrspace(4)
  %11 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %9, ptr addrspace(4) noundef %10) #40
  %12 = load i32, ptr %4, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  %13 = sub nsw i32 0, %12
  %14 = call spir_func float @_Z5ldexpfi(float noundef %6, i32 noundef %13) #38
  %15 = call spir_func float @_Z5ldexpfi(float noundef %8, i32 noundef %13) #38
  %16 = fmul float %15, %15
  %17 = call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %14, float noundef %16) #38
  %18 = call float @llvm.sqrt.f32(float %17), !fpmath !18
  %19 = and i32 %12, 1
  %20 = xor i32 %19, 1
  %21 = fadd float %14, %18
  %22 = call spir_func float @_Z5ldexpfi(float noundef %21, i32 noundef %20) #38
  %23 = call float @llvm.sqrt.f32(float %22), !fpmath !18
  %24 = ashr i32 %12, 1
  %25 = sub nsw i32 %24, %20
  %26 = call spir_func float @_Z5ldexpfi(float noundef %23, i32 noundef %25) #38
  %27 = fdiv float %8, %26, !fpmath !15
  %28 = call spir_func float @_Z5ldexpfi(float noundef %27, i32 noundef -1) #38
  %29 = fcmp oeq float %26, 0.000000e+00
  %30 = select i1 %29, float %26, float %28
  %31 = fcmp olt float %5, 0.000000e+00
  %32 = select i1 %31, float %30, float %26
  %33 = select i1 %31, float %26, float %30
  %34 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %36, label %51

36:                                               ; preds = %1
  %37 = fcmp oeq float %8, 0x7FF0000000000000
  %38 = select i1 %37, float %8, float %32
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %5, ptr %3, align 8, !tbaa !16
  %39 = addrspacecast ptr %3 to ptr addrspace(4)
  %40 = load i64, ptr addrspace(4) %39, align 8, !tbaa !12
  %41 = icmp eq i64 %40, -8388608
  br i1 %41, label %42, label %43

42:                                               ; preds = %36
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br label %45

43:                                               ; preds = %36
  %44 = select i1 %37, float %8, float %33
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br label %45

45:                                               ; preds = %42, %43
  %46 = phi float [ %44, %43 ], [ %6, %42 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %5, ptr %2, align 8, !tbaa !16
  %47 = addrspacecast ptr %2 to ptr addrspace(4)
  %48 = load i64, ptr addrspace(4) %47, align 8, !tbaa !12
  %49 = icmp eq i64 %48, 2139095040
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %50 = select i1 %49, float %6, float %38
  br label %51

51:                                               ; preds = %45, %1
  %52 = phi float [ %33, %1 ], [ %46, %45 ]
  %53 = phi float [ %32, %1 ], [ %50, %45 ]
  %54 = insertelement <2 x float> poison, float %53, i64 0
  %55 = call float @llvm.copysign.f32(float %52, float %7)
  %56 = insertelement <2 x float> %54, float %55, i64 1
  ret <2 x float> %56
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_ctan_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x double> %0, i64 1
  %3 = fneg double %2
  %4 = insertelement <2 x double> poison, double %3, i64 0
  %5 = shufflevector <2 x double> %4, <2 x double> %0, <2 x i32> <i32 0, i32 2>
  %6 = tail call spir_func <2 x double> @__ocml_ctanh_f64(<2 x double> noundef %5) #38
  %7 = extractelement <2 x double> %6, i64 1
  %8 = insertelement <2 x double> poison, double %7, i64 0
  %9 = extractelement <2 x double> %6, i64 0
  %10 = fneg double %9
  %11 = insertelement <2 x double> %8, double %10, i64 1
  ret <2 x double> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocml_ctanh_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca double, align 8
  %4 = alloca double, align 8
  %5 = alloca double, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5) #39
  %6 = extractelement <2 x double> %0, i64 1
  %7 = call spir_func double @__ocml_sincos_f64(double noundef %6, ptr noundef nonnull %5) #40
  %8 = load double, ptr %5, align 8, !tbaa !19
  %9 = fmul double %7, %8
  %10 = extractelement <2 x double> %0, i64 0
  %11 = call double @llvm.fabs.f64(double %10)
  %12 = fcmp olt double %11, 0x403419ECB712C481
  br i1 %12, label %13, label %95

13:                                               ; preds = %1
  %14 = fadd double %11, 0xBFE62E42FEFA39EF
  %15 = fsub double %14, %11
  %16 = fsub double %15, %14
  %17 = fadd double %11, %16
  %18 = fadd double %15, 0x3FE62E42FEFA39EF
  %19 = fsub double %17, %18
  %20 = fadd double %19, 0xBC7ABC9E3B39803F
  %21 = fadd double %14, %20
  %22 = fsub double %14, %21
  %23 = fadd double %20, %22
  %24 = insertelement <2 x double> poison, double %23, i64 0
  %25 = insertelement <2 x double> %24, double %21, i64 1
  %26 = call spir_func <2 x double> @__ocmlpriv_epexpep_f64(<2 x double> noundef %25) #38
  %27 = extractelement <2 x double> %26, i64 1
  %28 = fptrunc double %27 to float
  %29 = call spir_func float @_Z12native_recipf(float noundef %28) #38
  %30 = fpext float %29 to double
  %31 = fneg double %27
  %32 = call double @llvm.fma.f64(double %31, double %30, double 1.000000e+00)
  %33 = call double @llvm.fma.f64(double %32, double %30, double %30)
  %34 = call double @llvm.fma.f64(double %31, double %33, double 1.000000e+00)
  %35 = call double @llvm.fma.f64(double %34, double %33, double %33)
  %36 = fmul double %27, %35
  %37 = fneg double %36
  %38 = call double @llvm.fma.f64(double %35, double %27, double %37)
  %39 = extractelement <2 x double> %26, i64 0
  %40 = call double @llvm.fma.f64(double %35, double %39, double %38)
  %41 = fadd double %36, %40
  %42 = fsub double %41, %36
  %43 = fsub double 1.000000e+00, %41
  %44 = fsub double 1.000000e+00, %43
  %45 = fsub double %44, %41
  %46 = fsub double %42, %40
  %47 = fadd double %46, %45
  %48 = fadd double %43, %47
  %49 = fsub double %43, %48
  %50 = fadd double %47, %49
  %51 = fmul double %35, %48
  %52 = fmul double %27, %51
  %53 = fneg double %52
  %54 = call double @llvm.fma.f64(double %51, double %27, double %53)
  %55 = call double @llvm.fma.f64(double %51, double %39, double %54)
  %56 = fadd double %52, %55
  %57 = fsub double %56, %52
  %58 = fsub double %48, %56
  %59 = fsub double %48, %58
  %60 = fsub double %59, %56
  %61 = fadd double %50, %60
  %62 = fsub double %57, %55
  %63 = fadd double %62, %61
  %64 = fadd double %58, %63
  %65 = fmul double %35, %64
  %66 = fadd double %35, %51
  %67 = fsub double %66, %35
  %68 = fsub double %51, %67
  %69 = fadd double %68, %65
  %70 = fadd double %66, %69
  %71 = fsub double %70, %66
  %72 = fsub double %69, %71
  %73 = call spir_func double @_Z5ldexpdi(double noundef %70, i32 noundef -2) #38
  %74 = call spir_func double @_Z5ldexpdi(double noundef %72, i32 noundef -2) #38
  %75 = fadd double %27, %73
  %76 = fsub double %75, %27
  %77 = fsub double %73, %76
  %78 = fadd double %39, %74
  %79 = fadd double %78, %77
  %80 = fadd double %75, %79
  %81 = fsub double %27, %73
  %82 = fsub double %27, %81
  %83 = fsub double %82, %73
  %84 = fadd double %39, %83
  %85 = fsub double %84, %74
  %86 = fadd double %81, %85
  %87 = fcmp olt double %11, 0x3E40000000000000
  %88 = select i1 %87, double %11, double %86
  %89 = fmul double %88, %88
  %90 = call double @llvm.fma.f64(double %8, double %8, double %89)
  %91 = fmul double %80, %88
  %92 = fdiv double %91, %90
  %93 = call double @llvm.copysign.f64(double %92, double %10)
  %94 = fdiv double %9, %90
  br label %101

95:                                               ; preds = %1
  %96 = call double @llvm.copysign.f64(double 1.000000e+00, double %10)
  %97 = fmul double %9, 4.000000e+00
  %98 = fmul double %11, -2.000000e+00
  %99 = call spir_func double @__ocml_exp_f64(double noundef %98) #38
  %100 = fmul double %97, %99
  br label %101

101:                                              ; preds = %95, %13
  %102 = phi double [ %94, %13 ], [ %100, %95 ]
  %103 = phi double [ %93, %13 ], [ %96, %95 ]
  %104 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %105 = icmp eq i8 %104, 0
  br i1 %105, label %106, label %145

106:                                              ; preds = %101
  %107 = fcmp uno double %10, 0.000000e+00
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  store double %6, ptr %4, align 8, !tbaa !19
  %108 = addrspacecast ptr %4 to ptr addrspace(4)
  %109 = load i128, ptr addrspace(4) %108, align 8, !tbaa !29
  switch i128 %109, label %110 [
    i128 9218868437227405312, label %113
    i128 18442240474082181120, label %113
  ]

110:                                              ; preds = %106
  %111 = and i128 %109, 9221120237041090560
  %112 = icmp ne i128 %111, 0
  br label %113

113:                                              ; preds = %110, %106, %106
  %114 = phi i1 [ true, %106 ], [ true, %106 ], [ %112, %110 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %11, ptr %3, align 8, !tbaa !19
  %115 = addrspacecast ptr %3 to ptr addrspace(4)
  %116 = load i128, ptr addrspace(4) %115, align 8, !tbaa !29
  %117 = and i128 %116, 9223372036854775807
  %118 = icmp eq i128 %117, 0
  br i1 %118, label %126, label %119

119:                                              ; preds = %113
  %120 = and i128 %116, 9218868437227405312
  %121 = icmp eq i128 %120, 0
  %122 = and i128 %116, 4503599627370495
  %123 = icmp ne i128 %122, 0
  %124 = and i1 %121, %123
  %125 = zext i1 %124 to i32
  br label %126

126:                                              ; preds = %113, %119
  %127 = phi i32 [ 1, %113 ], [ %125, %119 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  %128 = select i1 %114, i32 %127, i32 0
  %129 = icmp eq i32 %128, 0
  %130 = zext i1 %107 to i32
  %131 = or i32 %128, %130
  %132 = icmp eq i32 %131, 0
  %133 = select i1 %132, double %103, double 0x7FF8000000000000
  %134 = select i1 %129, double %102, double 0x7FF8000000000000
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %11, ptr %2, align 8, !tbaa !19
  %135 = addrspacecast ptr %2 to ptr addrspace(4)
  %136 = load i128, ptr addrspace(4) %135, align 8, !tbaa !29
  %137 = add i128 %136, -9218868437227405312
  %138 = and i128 %137, -9223372036854775809
  %139 = icmp eq i128 %138, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %140 = and i1 %139, %114
  %141 = select i1 %140, double 0.000000e+00, double %134
  %142 = fcmp oeq double %6, 0.000000e+00
  %143 = and i1 %107, %142
  %144 = select i1 %143, double %6, double %141
  br label %145

145:                                              ; preds = %126, %101
  %146 = phi double [ %102, %101 ], [ %144, %126 ]
  %147 = phi double [ %103, %101 ], [ %133, %126 ]
  %148 = insertelement <2 x double> poison, double %147, i64 0
  %149 = insertelement <2 x double> %148, double %146, i64 1
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5) #39
  ret <2 x double> %149
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_ctan_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x float> %0, i64 1
  %3 = fneg float %2
  %4 = insertelement <2 x float> poison, float %3, i64 0
  %5 = shufflevector <2 x float> %4, <2 x float> %0, <2 x i32> <i32 0, i32 2>
  %6 = tail call spir_func <2 x float> @__ocml_ctanh_f32(<2 x float> noundef %5) #38
  %7 = extractelement <2 x float> %6, i64 1
  %8 = insertelement <2 x float> poison, float %7, i64 0
  %9 = extractelement <2 x float> %6, i64 0
  %10 = fneg float %9
  %11 = insertelement <2 x float> %8, float %10, i64 1
  ret <2 x float> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_ctanh_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca float, align 8
  %4 = alloca float, align 8
  %5 = alloca float, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %6 = extractelement <2 x float> %0, i64 1
  %7 = call spir_func float @__ocml_sincos_f32(float noundef %6, ptr noundef nonnull %5) #40
  %8 = load float, ptr %5, align 4, !tbaa !16
  %9 = fmul float %7, %8
  %10 = extractelement <2 x float> %0, i64 0
  %11 = call float @llvm.fabs.f32(float %10)
  %12 = fcmp olt float %11, 0x4023687AA0000000
  br i1 %12, label %13, label %167

13:                                               ; preds = %1
  %14 = fadd float %11, 0xBFE62E4300000000
  %15 = fsub float %14, %11
  %16 = fsub float %15, %14
  %17 = fadd float %11, %16
  %18 = fadd float %15, 0x3FE62E4300000000
  %19 = fsub float %17, %18
  %20 = fadd float %19, 0x3E205C6100000000
  %21 = fadd float %14, %20
  %22 = fsub float %14, %21
  %23 = fadd float %20, %22
  %24 = insertelement <2 x float> poison, float %23, i64 0
  %25 = insertelement <2 x float> %24, float %21, i64 1
  %26 = call spir_func <2 x float> @__ocmlpriv_epexpep_f32(<2 x float> noundef %25) #38
  %27 = extractelement <2 x float> %26, i64 1
  %28 = call spir_func float @_Z12native_recipf(float noundef %27) #38
  %29 = fmul float %27, %28
  %30 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %31 = freeze i32 %30
  %32 = icmp sgt i32 %31, 8999
  br i1 %32, label %33, label %38

33:                                               ; preds = %13
  %34 = fneg float %29
  %35 = call float @llvm.fma.f32(float %28, float %27, float %34)
  %36 = insertelement <2 x float> poison, float %35, i64 0
  %37 = insertelement <2 x float> %36, float %29, i64 1
  br label %60

38:                                               ; preds = %13
  switch i32 %31, label %39 [
    i32 8001, label %53
    i32 7001, label %53
  ]

39:                                               ; preds = %38
  %40 = bitcast float %28 to i32
  %41 = and i32 %40, -4096
  %42 = bitcast i32 %41 to float
  %43 = fsub float %28, %42
  %44 = bitcast float %27 to i32
  %45 = and i32 %44, -4096
  %46 = bitcast i32 %45 to float
  %47 = fsub float %27, %46
  %48 = fneg float %29
  %49 = call float @llvm.fmuladd.f32(float %42, float %46, float %48)
  %50 = call float @llvm.fmuladd.f32(float %42, float %47, float %49)
  %51 = call float @llvm.fmuladd.f32(float %43, float %46, float %50)
  %52 = call float @llvm.fmuladd.f32(float %43, float %47, float %51)
  br label %56

53:                                               ; preds = %38, %38
  %54 = fneg float %29
  %55 = call float @llvm.fma.f32(float %28, float %27, float %54)
  br label %56

56:                                               ; preds = %53, %39
  %57 = phi float [ %55, %53 ], [ %52, %39 ]
  %58 = insertelement <2 x float> poison, float %57, i64 0
  %59 = insertelement <2 x float> %58, float %29, i64 1
  switch i32 %31, label %66 [
    i32 8001, label %60
    i32 7001, label %60
  ]

60:                                               ; preds = %56, %56, %33
  %61 = phi <2 x float> [ %59, %56 ], [ %59, %56 ], [ %37, %33 ]
  %62 = phi float [ %57, %56 ], [ %57, %56 ], [ %35, %33 ]
  %63 = extractelement <2 x float> %26, i64 0
  %64 = call float @llvm.fma.f32(float %28, float %63, float %62)
  %65 = insertelement <2 x float> %61, float %64, i64 0
  br label %70

66:                                               ; preds = %56
  %67 = extractelement <2 x float> %26, i64 0
  %68 = call float @llvm.fmuladd.f32(float %28, float %67, float %57)
  %69 = insertelement <2 x float> %59, float %68, i64 0
  br label %70

70:                                               ; preds = %66, %60
  %71 = phi <2 x float> [ %65, %60 ], [ %69, %66 ]
  %72 = extractelement <2 x float> %71, i64 1
  %73 = extractelement <2 x float> %71, i64 0
  %74 = fadd float %72, %73
  %75 = fsub float %74, %72
  %76 = fsub float 1.000000e+00, %74
  %77 = fsub float 1.000000e+00, %76
  %78 = fsub float %77, %74
  %79 = fsub float %75, %73
  %80 = fadd float %79, %78
  %81 = fadd float %76, %80
  %82 = fmul float %28, %81
  %83 = fmul float %27, %82
  br i1 %32, label %84, label %89

84:                                               ; preds = %70
  %85 = fneg float %83
  %86 = call float @llvm.fma.f32(float %82, float %27, float %85)
  %87 = insertelement <2 x float> poison, float %86, i64 0
  %88 = insertelement <2 x float> %87, float %83, i64 1
  br label %111

89:                                               ; preds = %70
  switch i32 %31, label %90 [
    i32 8001, label %104
    i32 7001, label %104
  ]

90:                                               ; preds = %89
  %91 = bitcast float %82 to i32
  %92 = and i32 %91, -4096
  %93 = bitcast i32 %92 to float
  %94 = fsub float %82, %93
  %95 = bitcast float %27 to i32
  %96 = and i32 %95, -4096
  %97 = bitcast i32 %96 to float
  %98 = fsub float %27, %97
  %99 = fneg float %83
  %100 = call float @llvm.fmuladd.f32(float %93, float %97, float %99)
  %101 = call float @llvm.fmuladd.f32(float %93, float %98, float %100)
  %102 = call float @llvm.fmuladd.f32(float %94, float %97, float %101)
  %103 = call float @llvm.fmuladd.f32(float %94, float %98, float %102)
  br label %107

104:                                              ; preds = %89, %89
  %105 = fneg float %83
  %106 = call float @llvm.fma.f32(float %82, float %27, float %105)
  br label %107

107:                                              ; preds = %104, %90
  %108 = phi float [ %106, %104 ], [ %103, %90 ]
  %109 = insertelement <2 x float> poison, float %108, i64 0
  %110 = insertelement <2 x float> %109, float %83, i64 1
  switch i32 %31, label %117 [
    i32 8001, label %111
    i32 7001, label %111
  ]

111:                                              ; preds = %107, %107, %84
  %112 = phi <2 x float> [ %110, %107 ], [ %110, %107 ], [ %88, %84 ]
  %113 = phi float [ %108, %107 ], [ %108, %107 ], [ %86, %84 ]
  %114 = extractelement <2 x float> %26, i64 0
  %115 = call float @llvm.fma.f32(float %82, float %114, float %113)
  %116 = insertelement <2 x float> %112, float %115, i64 0
  br label %121

117:                                              ; preds = %107
  %118 = extractelement <2 x float> %26, i64 0
  %119 = call float @llvm.fmuladd.f32(float %82, float %118, float %108)
  %120 = insertelement <2 x float> %110, float %119, i64 0
  br label %121

121:                                              ; preds = %111, %117
  %122 = phi float [ %114, %111 ], [ %118, %117 ]
  %123 = phi <2 x float> [ %116, %111 ], [ %120, %117 ]
  %124 = fsub float %76, %81
  %125 = fadd float %80, %124
  %126 = extractelement <2 x float> %123, i64 1
  %127 = extractelement <2 x float> %123, i64 0
  %128 = fadd float %126, %127
  %129 = fsub float %128, %126
  %130 = fsub float %81, %128
  %131 = fsub float %81, %130
  %132 = fsub float %131, %128
  %133 = fadd float %125, %132
  %134 = fsub float %129, %127
  %135 = fadd float %134, %133
  %136 = fadd float %130, %135
  %137 = fmul float %28, %136
  %138 = fadd float %28, %82
  %139 = fsub float %138, %28
  %140 = fsub float %82, %139
  %141 = fadd float %140, %137
  %142 = fadd float %138, %141
  %143 = fsub float %142, %138
  %144 = fsub float %141, %143
  %145 = call spir_func float @_Z5ldexpfi(float noundef %142, i32 noundef -2) #38
  %146 = call spir_func float @_Z5ldexpfi(float noundef %144, i32 noundef -2) #38
  %147 = fadd float %27, %145
  %148 = fsub float %147, %27
  %149 = fsub float %145, %148
  %150 = fadd float %122, %146
  %151 = fadd float %150, %149
  %152 = fadd float %147, %151
  %153 = fsub float %27, %145
  %154 = fsub float %27, %153
  %155 = fsub float %154, %145
  %156 = fadd float %122, %155
  %157 = fsub float %156, %146
  %158 = fadd float %153, %157
  %159 = fcmp olt float %11, 0x3F30000000000000
  %160 = select i1 %159, float %11, float %158
  %161 = fmul float %160, %160
  %162 = call spir_func float @__ocml_fmuladd_f32(float noundef %8, float noundef %8, float noundef %161) #38
  %163 = fmul float %152, %160
  %164 = fdiv float %163, %162, !fpmath !15
  %165 = call float @llvm.copysign.f32(float %164, float %10)
  %166 = fdiv float %9, %162, !fpmath !15
  br label %173

167:                                              ; preds = %1
  %168 = call float @llvm.copysign.f32(float 1.000000e+00, float %10)
  %169 = fmul float %9, 4.000000e+00
  %170 = fmul float %11, -2.000000e+00
  %171 = call spir_func float @__ocml_exp_f32(float noundef %170) #38
  %172 = fmul float %169, %171
  br label %173

173:                                              ; preds = %167, %121
  %174 = phi float [ %166, %121 ], [ %172, %167 ]
  %175 = phi float [ %165, %121 ], [ %168, %167 ]
  %176 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %177 = icmp eq i8 %176, 0
  br i1 %177, label %178, label %217

178:                                              ; preds = %173
  %179 = fcmp uno float %10, 0.000000e+00
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  store float %6, ptr %4, align 8, !tbaa !16
  %180 = addrspacecast ptr %4 to ptr addrspace(4)
  %181 = load i64, ptr addrspace(4) %180, align 8, !tbaa !12
  switch i64 %181, label %182 [
    i64 2139095040, label %185
    i64 -8388608, label %185
  ]

182:                                              ; preds = %178
  %183 = and i64 %181, 2143289344
  %184 = icmp ne i64 %183, 0
  br label %185

185:                                              ; preds = %182, %178, %178
  %186 = phi i1 [ true, %178 ], [ true, %178 ], [ %184, %182 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %11, ptr %3, align 8, !tbaa !16
  %187 = addrspacecast ptr %3 to ptr addrspace(4)
  %188 = load i64, ptr addrspace(4) %187, align 8, !tbaa !12
  %189 = and i64 %188, 2147483647
  %190 = icmp eq i64 %189, 0
  br i1 %190, label %198, label %191

191:                                              ; preds = %185
  %192 = and i64 %188, 2139095040
  %193 = icmp eq i64 %192, 0
  %194 = and i64 %188, 8388607
  %195 = icmp ne i64 %194, 0
  %196 = and i1 %193, %195
  %197 = zext i1 %196 to i32
  br label %198

198:                                              ; preds = %185, %191
  %199 = phi i32 [ 1, %185 ], [ %197, %191 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %200 = select i1 %186, i32 %199, i32 0
  %201 = icmp eq i32 %200, 0
  %202 = zext i1 %179 to i32
  %203 = or i32 %200, %202
  %204 = icmp eq i32 %203, 0
  %205 = select i1 %204, float %175, float 0x7FF8000000000000
  %206 = select i1 %201, float %174, float 0x7FF8000000000000
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %11, ptr %2, align 8, !tbaa !16
  %207 = addrspacecast ptr %2 to ptr addrspace(4)
  %208 = load i64, ptr addrspace(4) %207, align 8, !tbaa !12
  %209 = add i64 %208, 8388608
  %210 = and i64 %209, -2147483649
  %211 = icmp eq i64 %210, 0
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %212 = and i1 %211, %186
  %213 = select i1 %212, float 0.000000e+00, float %206
  %214 = fcmp oeq float %6, 0.000000e+00
  %215 = and i1 %179, %214
  %216 = select i1 %215, float %6, float %213
  br label %217

217:                                              ; preds = %198, %173
  %218 = phi float [ %174, %173 ], [ %216, %198 ]
  %219 = phi float [ %175, %173 ], [ %205, %198 ]
  %220 = insertelement <2 x float> poison, float %219, i64 0
  %221 = insertelement <2 x float> %220, float %218, i64 1
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  ret <2 x float> %221
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x double> @__ocmlpriv_epln_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = fcmp olt double %0, 0x3FE5555555555555
  %4 = zext i1 %3 to i32
  %5 = tail call spir_func double @_Z5ldexpdi(double noundef %0, i32 noundef %4) #38
  %6 = fptrunc double %0 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %7 = addrspacecast ptr %2 to ptr addrspace(4)
  %8 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %6, ptr addrspace(4) noundef %7) #40
  %9 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %10 = sub nsw i32 %9, %4
  %11 = fadd double %5, -1.000000e+00
  %12 = fadd double %5, 1.000000e+00
  %13 = fadd double %12, -1.000000e+00
  %14 = fsub double %5, %13
  %15 = fptrunc double %12 to float
  %16 = call spir_func float @_Z12native_recipf(float noundef %15) #38
  %17 = fpext float %16 to double
  %18 = fneg double %12
  %19 = call double @llvm.fma.f64(double %18, double %17, double 1.000000e+00)
  %20 = call double @llvm.fma.f64(double %19, double %17, double %17)
  %21 = call double @llvm.fma.f64(double %18, double %20, double 1.000000e+00)
  %22 = call double @llvm.fma.f64(double %21, double %20, double %20)
  %23 = fmul double %11, %22
  %24 = fmul double %12, %23
  %25 = fneg double %24
  %26 = call double @llvm.fma.f64(double %23, double %12, double %25)
  %27 = call double @llvm.fma.f64(double %23, double %14, double %26)
  %28 = fadd double %24, %27
  %29 = fsub double %28, %24
  %30 = fsub double %11, %28
  %31 = fsub double %11, %30
  %32 = fsub double %31, %28
  %33 = fsub double %29, %27
  %34 = fadd double %33, %32
  %35 = fadd double %30, %34
  %36 = fmul double %22, %35
  %37 = fadd double %23, %36
  %38 = fsub double %37, %23
  %39 = fsub double %36, %38
  %40 = fmul double %37, %37
  %41 = fneg double %40
  %42 = call double @llvm.fma.f64(double %37, double %37, double %41)
  %43 = fmul double %39, 2.000000e+00
  %44 = call double @llvm.fma.f64(double %37, double %43, double %42)
  %45 = fadd double %40, %44
  %46 = fsub double %45, %40
  %47 = fsub double %44, %46
  %48 = call double @llvm.fma.f64(double %45, double 0x3FBDEE674222DE17, double 0x3FBA6564968915A9)
  %49 = call double @llvm.fma.f64(double %45, double %48, double 0x3FBE25E43ABE935A)
  %50 = call double @llvm.fma.f64(double %45, double %49, double 0x3FC110EF47E6C9C2)
  %51 = call double @llvm.fma.f64(double %45, double %50, double 0x3FC3B13BCFA74449)
  %52 = call double @llvm.fma.f64(double %45, double %51, double 0x3FC745D171BF3C30)
  %53 = call double @llvm.fma.f64(double %45, double %52, double 0x3FCC71C71C7792CE)
  %54 = call double @llvm.fma.f64(double %45, double %53, double 0x3FD24924924920DA)
  %55 = call double @llvm.fma.f64(double %45, double %54, double 0x3FD999999999999C)
  %56 = sitofp i32 %10 to double
  %57 = fmul double %56, 0x3FE62E42FEFA39EF
  %58 = fneg double %57
  %59 = call double @llvm.fma.f64(double %56, double 0x3FE62E42FEFA39EF, double %58)
  %60 = call double @llvm.fma.f64(double %56, double 0x3C7ABC9E3B39803F, double %59)
  %61 = fadd double %57, %60
  %62 = fsub double %61, %57
  %63 = fsub double %60, %62
  %64 = call spir_func double @_Z5ldexpdi(double noundef %37, i32 noundef 1) #38
  %65 = call spir_func double @_Z5ldexpdi(double noundef %39, i32 noundef 1) #38
  %66 = fmul double %37, %45
  %67 = fneg double %66
  %68 = call double @llvm.fma.f64(double %45, double %37, double %67)
  %69 = call double @llvm.fma.f64(double %45, double %39, double %68)
  %70 = call double @llvm.fma.f64(double %47, double %37, double %69)
  %71 = fadd double %66, %70
  %72 = fsub double %71, %66
  %73 = fsub double %70, %72
  %74 = fmul double %45, %55
  %75 = fneg double %74
  %76 = call double @llvm.fma.f64(double %45, double %55, double %75)
  %77 = call double @llvm.fma.f64(double %47, double %55, double %76)
  %78 = fadd double %74, %77
  %79 = fsub double %78, %74
  %80 = fsub double %77, %79
  %81 = fadd double %78, 0x3FE5555555555555
  %82 = fadd double %81, 0xBFE5555555555555
  %83 = fsub double %78, %82
  %84 = fadd double %80, 0x3C8543B0D5DF274D
  %85 = fadd double %84, %83
  %86 = fadd double %81, %85
  %87 = fsub double %81, %86
  %88 = fadd double %85, %87
  %89 = fmul double %71, %86
  %90 = fneg double %89
  %91 = call double @llvm.fma.f64(double %71, double %86, double %90)
  %92 = call double @llvm.fma.f64(double %71, double %88, double %91)
  %93 = call double @llvm.fma.f64(double %73, double %86, double %92)
  %94 = fadd double %89, %93
  %95 = fsub double %94, %89
  %96 = fsub double %93, %95
  %97 = fadd double %64, %94
  %98 = fsub double %97, %64
  %99 = fsub double %94, %98
  %100 = fadd double %65, %96
  %101 = fadd double %100, %99
  %102 = fadd double %97, %101
  %103 = fsub double %102, %97
  %104 = fsub double %101, %103
  %105 = fadd double %61, %102
  %106 = fsub double %105, %61
  %107 = fsub double %105, %106
  %108 = fsub double %61, %107
  %109 = fsub double %102, %106
  %110 = fadd double %109, %108
  %111 = fadd double %63, %104
  %112 = fsub double %111, %63
  %113 = fsub double %111, %112
  %114 = fsub double %63, %113
  %115 = fsub double %104, %112
  %116 = fadd double %115, %114
  %117 = fadd double %111, %110
  %118 = fadd double %105, %117
  %119 = fsub double %118, %105
  %120 = fsub double %117, %119
  %121 = fadd double %116, %120
  %122 = fadd double %118, %121
  %123 = fsub double %122, %118
  %124 = fsub double %121, %123
  %125 = insertelement <2 x double> poison, double %124, i64 0
  %126 = insertelement <2 x double> %125, double %122, i64 1
  ret <2 x double> %126
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocmlpriv_epln_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = fcmp olt float %0, 0x3FE5555560000000
  %4 = zext i1 %3 to i32
  %5 = tail call spir_func float @_Z5ldexpfi(float noundef %0, i32 noundef %4) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %6 = addrspacecast ptr %2 to ptr addrspace(4)
  %7 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %0, ptr addrspace(4) noundef %6) #40
  %8 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %9 = sub nsw i32 %8, %4
  %10 = fadd float %5, -1.000000e+00
  %11 = fadd float %5, 1.000000e+00
  %12 = fadd float %11, -1.000000e+00
  %13 = fsub float %5, %12
  %14 = call spir_func float @_Z12native_recipf(float noundef %11) #38
  %15 = fmul float %10, %14
  %16 = fmul float %11, %15
  %17 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %18 = freeze i32 %17
  %19 = icmp sgt i32 %18, 8999
  br i1 %19, label %20, label %25

20:                                               ; preds = %1
  %21 = fneg float %16
  %22 = call float @llvm.fma.f32(float %15, float %11, float %21)
  %23 = insertelement <2 x float> poison, float %22, i64 0
  %24 = insertelement <2 x float> %23, float %16, i64 1
  br label %47

25:                                               ; preds = %1
  switch i32 %18, label %26 [
    i32 8001, label %40
    i32 7001, label %40
  ]

26:                                               ; preds = %25
  %27 = bitcast float %15 to i32
  %28 = and i32 %27, -4096
  %29 = bitcast i32 %28 to float
  %30 = fsub float %15, %29
  %31 = bitcast float %11 to i32
  %32 = and i32 %31, -4096
  %33 = bitcast i32 %32 to float
  %34 = fsub float %11, %33
  %35 = fneg float %16
  %36 = call float @llvm.fmuladd.f32(float %29, float %33, float %35)
  %37 = call float @llvm.fmuladd.f32(float %29, float %34, float %36)
  %38 = call float @llvm.fmuladd.f32(float %30, float %33, float %37)
  %39 = call float @llvm.fmuladd.f32(float %30, float %34, float %38)
  br label %43

40:                                               ; preds = %25, %25
  %41 = fneg float %16
  %42 = call float @llvm.fma.f32(float %15, float %11, float %41)
  br label %43

43:                                               ; preds = %40, %26
  %44 = phi float [ %42, %40 ], [ %39, %26 ]
  %45 = insertelement <2 x float> poison, float %44, i64 0
  %46 = insertelement <2 x float> %45, float %16, i64 1
  switch i32 %18, label %52 [
    i32 8001, label %47
    i32 7001, label %47
  ]

47:                                               ; preds = %43, %43, %20
  %48 = phi <2 x float> [ %46, %43 ], [ %46, %43 ], [ %24, %20 ]
  %49 = phi float [ %44, %43 ], [ %44, %43 ], [ %22, %20 ]
  %50 = call float @llvm.fma.f32(float %15, float %13, float %49)
  %51 = insertelement <2 x float> %48, float %50, i64 0
  br label %55

52:                                               ; preds = %43
  %53 = call float @llvm.fmuladd.f32(float %15, float %13, float %44)
  %54 = insertelement <2 x float> %46, float %53, i64 0
  br label %55

55:                                               ; preds = %47, %52
  %56 = phi <2 x float> [ %51, %47 ], [ %54, %52 ]
  %57 = extractelement <2 x float> %56, i64 1
  %58 = extractelement <2 x float> %56, i64 0
  %59 = fadd float %57, %58
  %60 = fsub float %59, %57
  %61 = fsub float %10, %59
  %62 = fsub float %10, %61
  %63 = fsub float %62, %59
  %64 = fsub float %60, %58
  %65 = fadd float %64, %63
  %66 = fadd float %61, %65
  %67 = fmul float %14, %66
  %68 = fadd float %15, %67
  %69 = fsub float %68, %15
  %70 = fsub float %67, %69
  %71 = fmul float %68, %68
  br i1 %19, label %72, label %77

72:                                               ; preds = %55
  %73 = fneg float %71
  %74 = call float @llvm.fma.f32(float %68, float %68, float %73)
  %75 = insertelement <2 x float> poison, float %74, i64 0
  %76 = insertelement <2 x float> %75, float %71, i64 1
  br label %95

77:                                               ; preds = %55
  switch i32 %18, label %78 [
    i32 8001, label %88
    i32 7001, label %88
  ]

78:                                               ; preds = %77
  %79 = bitcast float %68 to i32
  %80 = and i32 %79, -4096
  %81 = bitcast i32 %80 to float
  %82 = fsub float %68, %81
  %83 = fneg float %71
  %84 = call float @llvm.fmuladd.f32(float %81, float %81, float %83)
  %85 = fmul float %81, 2.000000e+00
  %86 = call float @llvm.fmuladd.f32(float %85, float %82, float %84)
  %87 = call float @llvm.fmuladd.f32(float %82, float %82, float %86)
  br label %91

88:                                               ; preds = %77, %77
  %89 = fneg float %71
  %90 = call float @llvm.fma.f32(float %68, float %68, float %89)
  br label %91

91:                                               ; preds = %88, %78
  %92 = phi float [ %90, %88 ], [ %87, %78 ]
  %93 = insertelement <2 x float> poison, float %92, i64 0
  %94 = insertelement <2 x float> %93, float %71, i64 1
  switch i32 %18, label %101 [
    i32 8001, label %95
    i32 7001, label %95
  ]

95:                                               ; preds = %91, %91, %72
  %96 = phi <2 x float> [ %94, %91 ], [ %94, %91 ], [ %76, %72 ]
  %97 = phi float [ %92, %91 ], [ %92, %91 ], [ %74, %72 ]
  %98 = fmul float %70, 2.000000e+00
  %99 = call float @llvm.fma.f32(float %68, float %98, float %97)
  %100 = insertelement <2 x float> %96, float %99, i64 0
  br label %105

101:                                              ; preds = %91
  %102 = fmul float %70, 2.000000e+00
  %103 = call float @llvm.fmuladd.f32(float %102, float %68, float %92)
  %104 = insertelement <2 x float> %94, float %103, i64 0
  br label %105

105:                                              ; preds = %95, %101
  %106 = phi <2 x float> [ %100, %95 ], [ %104, %101 ]
  %107 = extractelement <2 x float> %106, i64 1
  %108 = extractelement <2 x float> %106, i64 0
  %109 = fadd float %107, %108
  %110 = fsub float %109, %107
  %111 = fsub float %108, %110
  %112 = call spir_func float @__ocml_fmuladd_f32(float noundef %109, float noundef 0x3FCED89C20000000, float noundef 0x3FD23E9880000000) #38
  %113 = call spir_func float @__ocml_fmuladd_f32(float noundef %109, float noundef %112, float noundef 0x3FD999BDE0000000) #38
  %114 = sitofp i32 %9 to float
  %115 = fmul float %114, 0x3FE62E4300000000
  br i1 %19, label %116, label %121

116:                                              ; preds = %105
  %117 = fneg float %115
  %118 = call float @llvm.fma.f32(float %114, float 0x3FE62E4300000000, float %117)
  %119 = insertelement <2 x float> poison, float %118, i64 0
  %120 = insertelement <2 x float> %119, float %115, i64 1
  br label %139

121:                                              ; preds = %105
  switch i32 %18, label %122 [
    i32 8001, label %132
    i32 7001, label %132
  ]

122:                                              ; preds = %121
  %123 = bitcast float %114 to i32
  %124 = and i32 %123, -4096
  %125 = bitcast i32 %124 to float
  %126 = fsub float %114, %125
  %127 = fneg float %115
  %128 = call float @llvm.fmuladd.f32(float %125, float 0x3FE62E0000000000, float %127)
  %129 = call float @llvm.fmuladd.f32(float %126, float 0x3FE62E0000000000, float %128)
  %130 = call float @llvm.fmuladd.f32(float %125, float 0x3F00C00000000000, float %129)
  %131 = call float @llvm.fmuladd.f32(float %126, float 0x3F00C00000000000, float %130)
  br label %135

132:                                              ; preds = %121, %121
  %133 = fneg float %115
  %134 = call float @llvm.fma.f32(float %114, float 0x3FE62E4300000000, float %133)
  br label %135

135:                                              ; preds = %132, %122
  %136 = phi float [ %134, %132 ], [ %131, %122 ]
  %137 = insertelement <2 x float> poison, float %136, i64 0
  %138 = insertelement <2 x float> %137, float %115, i64 1
  switch i32 %18, label %144 [
    i32 8001, label %139
    i32 7001, label %139
  ]

139:                                              ; preds = %135, %135, %116
  %140 = phi <2 x float> [ %138, %135 ], [ %138, %135 ], [ %120, %116 ]
  %141 = phi float [ %136, %135 ], [ %136, %135 ], [ %118, %116 ]
  %142 = call float @llvm.fma.f32(float %114, float 0xBE205C6100000000, float %141)
  %143 = insertelement <2 x float> %140, float %142, i64 0
  br label %147

144:                                              ; preds = %135
  %145 = call float @llvm.fmuladd.f32(float %114, float 0xBE205C6100000000, float %136)
  %146 = insertelement <2 x float> %138, float %145, i64 0
  br label %147

147:                                              ; preds = %139, %144
  %148 = phi <2 x float> [ %143, %139 ], [ %146, %144 ]
  %149 = call spir_func float @_Z5ldexpfi(float noundef %68, i32 noundef 1) #38
  %150 = call spir_func float @_Z5ldexpfi(float noundef %70, i32 noundef 1) #38
  %151 = fmul float %68, %109
  br i1 %19, label %152, label %157

152:                                              ; preds = %147
  %153 = fneg float %151
  %154 = call float @llvm.fma.f32(float %109, float %68, float %153)
  %155 = insertelement <2 x float> poison, float %154, i64 0
  %156 = insertelement <2 x float> %155, float %151, i64 1
  br label %187

157:                                              ; preds = %147
  switch i32 %18, label %158 [
    i32 8001, label %172
    i32 7001, label %172
  ]

158:                                              ; preds = %157
  %159 = bitcast float %109 to i32
  %160 = and i32 %159, -4096
  %161 = bitcast i32 %160 to float
  %162 = fsub float %109, %161
  %163 = bitcast float %68 to i32
  %164 = and i32 %163, -4096
  %165 = bitcast i32 %164 to float
  %166 = fsub float %68, %165
  %167 = fneg float %151
  %168 = call float @llvm.fmuladd.f32(float %161, float %165, float %167)
  %169 = call float @llvm.fmuladd.f32(float %161, float %166, float %168)
  %170 = call float @llvm.fmuladd.f32(float %162, float %165, float %169)
  %171 = call float @llvm.fmuladd.f32(float %162, float %166, float %170)
  br label %175

172:                                              ; preds = %157, %157
  %173 = fneg float %151
  %174 = call float @llvm.fma.f32(float %109, float %68, float %173)
  br label %175

175:                                              ; preds = %172, %158
  %176 = phi float [ %174, %172 ], [ %171, %158 ]
  %177 = insertelement <2 x float> poison, float %176, i64 0
  %178 = insertelement <2 x float> %177, float %151, i64 1
  switch i32 %18, label %179 [
    i32 8001, label %187
    i32 7001, label %187
  ]

179:                                              ; preds = %175
  %180 = fmul float %68, %111
  %181 = call float @llvm.fmuladd.f32(float %109, float %70, float %180)
  %182 = fadd float %181, %176
  %183 = fadd float %151, %182
  %184 = fsub float %183, %151
  %185 = fsub float %182, %184
  %186 = fmul float %109, %113
  br label %202

187:                                              ; preds = %152, %175, %175
  %188 = phi <2 x float> [ %178, %175 ], [ %178, %175 ], [ %156, %152 ]
  %189 = phi float [ %176, %175 ], [ %176, %175 ], [ %154, %152 ]
  %190 = call float @llvm.fma.f32(float %109, float %70, float %189)
  %191 = call float @llvm.fma.f32(float %111, float %68, float %190)
  %192 = extractelement <2 x float> %188, i64 1
  %193 = fadd float %192, %191
  %194 = fsub float %193, %192
  %195 = fsub float %191, %194
  %196 = fmul float %109, %113
  br i1 %19, label %197, label %202

197:                                              ; preds = %187
  %198 = fneg float %196
  %199 = call float @llvm.fma.f32(float %109, float %113, float %198)
  %200 = insertelement <2 x float> poison, float %199, i64 0
  %201 = insertelement <2 x float> %200, float %196, i64 1
  br label %227

202:                                              ; preds = %179, %187
  %203 = phi float [ %186, %179 ], [ %196, %187 ]
  %204 = phi float [ %185, %179 ], [ %195, %187 ]
  %205 = phi float [ %183, %179 ], [ %193, %187 ]
  switch i32 %18, label %206 [
    i32 8001, label %220
    i32 7001, label %220
  ]

206:                                              ; preds = %202
  %207 = bitcast float %109 to i32
  %208 = and i32 %207, -4096
  %209 = bitcast i32 %208 to float
  %210 = fsub float %109, %209
  %211 = bitcast float %113 to i32
  %212 = and i32 %211, -4096
  %213 = bitcast i32 %212 to float
  %214 = fsub float %113, %213
  %215 = fneg float %203
  %216 = call float @llvm.fmuladd.f32(float %209, float %213, float %215)
  %217 = call float @llvm.fmuladd.f32(float %209, float %214, float %216)
  %218 = call float @llvm.fmuladd.f32(float %210, float %213, float %217)
  %219 = call float @llvm.fmuladd.f32(float %210, float %214, float %218)
  br label %223

220:                                              ; preds = %202, %202
  %221 = fneg float %203
  %222 = call float @llvm.fma.f32(float %109, float %113, float %221)
  br label %223

223:                                              ; preds = %220, %206
  %224 = phi float [ %222, %220 ], [ %219, %206 ]
  %225 = insertelement <2 x float> poison, float %224, i64 0
  %226 = insertelement <2 x float> %225, float %203, i64 1
  switch i32 %18, label %234 [
    i32 8001, label %227
    i32 7001, label %227
  ]

227:                                              ; preds = %223, %223, %197
  %228 = phi float [ %204, %223 ], [ %204, %223 ], [ %195, %197 ]
  %229 = phi float [ %205, %223 ], [ %205, %223 ], [ %193, %197 ]
  %230 = phi <2 x float> [ %226, %223 ], [ %226, %223 ], [ %201, %197 ]
  %231 = phi float [ %224, %223 ], [ %224, %223 ], [ %199, %197 ]
  %232 = call float @llvm.fma.f32(float %111, float %113, float %231)
  %233 = insertelement <2 x float> %230, float %232, i64 0
  br label %237

234:                                              ; preds = %223
  %235 = call float @llvm.fmuladd.f32(float %111, float %113, float %224)
  %236 = insertelement <2 x float> %226, float %235, i64 0
  br label %237

237:                                              ; preds = %227, %234
  %238 = phi float [ %228, %227 ], [ %204, %234 ]
  %239 = phi float [ %229, %227 ], [ %205, %234 ]
  %240 = phi <2 x float> [ %233, %227 ], [ %236, %234 ]
  %241 = extractelement <2 x float> %240, i64 1
  %242 = extractelement <2 x float> %240, i64 0
  %243 = fadd float %241, %242
  %244 = fsub float %243, %241
  %245 = fsub float %242, %244
  %246 = fadd float %243, 0x3FE5555540000000
  %247 = fadd float %246, 0xBFE5555540000000
  %248 = fsub float %243, %247
  %249 = fadd float %245, 0x3E2E720200000000
  %250 = fadd float %249, %248
  %251 = fadd float %246, %250
  %252 = fsub float %246, %251
  %253 = fadd float %250, %252
  %254 = fmul float %239, %251
  br i1 %19, label %255, label %260

255:                                              ; preds = %237
  %256 = fneg float %254
  %257 = call float @llvm.fma.f32(float %239, float %251, float %256)
  %258 = insertelement <2 x float> poison, float %257, i64 0
  %259 = insertelement <2 x float> %258, float %254, i64 1
  br label %282

260:                                              ; preds = %237
  switch i32 %18, label %261 [
    i32 8001, label %275
    i32 7001, label %275
  ]

261:                                              ; preds = %260
  %262 = bitcast float %239 to i32
  %263 = and i32 %262, -4096
  %264 = bitcast i32 %263 to float
  %265 = fsub float %239, %264
  %266 = bitcast float %251 to i32
  %267 = and i32 %266, -4096
  %268 = bitcast i32 %267 to float
  %269 = fsub float %251, %268
  %270 = fneg float %254
  %271 = call float @llvm.fmuladd.f32(float %264, float %268, float %270)
  %272 = call float @llvm.fmuladd.f32(float %264, float %269, float %271)
  %273 = call float @llvm.fmuladd.f32(float %265, float %268, float %272)
  %274 = call float @llvm.fmuladd.f32(float %265, float %269, float %273)
  br label %278

275:                                              ; preds = %260, %260
  %276 = fneg float %254
  %277 = call float @llvm.fma.f32(float %239, float %251, float %276)
  br label %278

278:                                              ; preds = %275, %261
  %279 = phi float [ %277, %275 ], [ %274, %261 ]
  %280 = insertelement <2 x float> poison, float %279, i64 0
  %281 = insertelement <2 x float> %280, float %254, i64 1
  switch i32 %18, label %288 [
    i32 8001, label %282
    i32 7001, label %282
  ]

282:                                              ; preds = %278, %278, %255
  %283 = phi <2 x float> [ %281, %278 ], [ %281, %278 ], [ %259, %255 ]
  %284 = phi float [ %279, %278 ], [ %279, %278 ], [ %257, %255 ]
  %285 = call float @llvm.fma.f32(float %239, float %253, float %284)
  %286 = call float @llvm.fma.f32(float %238, float %251, float %285)
  %287 = insertelement <2 x float> %283, float %286, i64 0
  br label %293

288:                                              ; preds = %278
  %289 = fmul float %238, %251
  %290 = call float @llvm.fmuladd.f32(float %239, float %253, float %289)
  %291 = fadd float %290, %279
  %292 = insertelement <2 x float> %281, float %291, i64 0
  br label %293

293:                                              ; preds = %282, %288
  %294 = phi <2 x float> [ %287, %282 ], [ %292, %288 ]
  %295 = extractelement <2 x float> %148, i64 0
  %296 = extractelement <2 x float> %148, i64 1
  %297 = fadd float %296, %295
  %298 = fsub float %297, %296
  %299 = fsub float %295, %298
  %300 = extractelement <2 x float> %294, i64 1
  %301 = extractelement <2 x float> %294, i64 0
  %302 = fadd float %300, %301
  %303 = fsub float %302, %300
  %304 = fsub float %301, %303
  %305 = fadd float %149, %302
  %306 = fsub float %305, %149
  %307 = fsub float %302, %306
  %308 = fadd float %150, %304
  %309 = fadd float %308, %307
  %310 = fadd float %305, %309
  %311 = fsub float %310, %305
  %312 = fsub float %309, %311
  %313 = fadd float %297, %310
  %314 = fsub float %313, %297
  %315 = fsub float %313, %314
  %316 = fsub float %297, %315
  %317 = fsub float %310, %314
  %318 = fadd float %317, %316
  %319 = fadd float %299, %312
  %320 = fsub float %319, %299
  %321 = fsub float %319, %320
  %322 = fsub float %299, %321
  %323 = fsub float %312, %320
  %324 = fadd float %323, %322
  %325 = fadd float %319, %318
  %326 = fadd float %313, %325
  %327 = fsub float %326, %313
  %328 = fsub float %325, %327
  %329 = fadd float %324, %328
  %330 = fadd float %326, %329
  %331 = fsub float %330, %326
  %332 = fsub float %329, %331
  %333 = insertelement <2 x float> poison, float %332, i64 0
  %334 = insertelement <2 x float> %333, float %330, i64 1
  ret <2 x float> %334
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_erf_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fcmp olt double %2, 1.000000e+00
  br i1 %3, label %4, label %18

4:                                                ; preds = %1
  %5 = fmul double %0, %0
  %6 = tail call double @llvm.fma.f64(double %5, double 0xBE0AB15C51D2EBEB, double 0x3E4D6E3DDFEB1F49)
  %7 = tail call double @llvm.fma.f64(double %5, double %6, double 0xBE85BFE763844720)
  %8 = tail call double @llvm.fma.f64(double %5, double %7, double 0x3EBB97E44280CFB9)
  %9 = tail call double @llvm.fma.f64(double %5, double %8, double 0xBEEF4CA204C771C5)
  %10 = tail call double @llvm.fma.f64(double %5, double %9, double 0x3F1F9A2B75531772)
  %11 = tail call double @llvm.fma.f64(double %5, double %10, double 0xBF4C02DB0149D904)
  %12 = tail call double @llvm.fma.f64(double %5, double %11, double 0x3F7565BCCF7E2856)
  %13 = tail call double @llvm.fma.f64(double %5, double %12, double 0xBF9B82CE311EE09B)
  %14 = tail call double @llvm.fma.f64(double %5, double %13, double 0x3FBCE2F21A0408D1)
  %15 = tail call double @llvm.fma.f64(double %5, double %14, double 0xBFD812746B0379B2)
  %16 = tail call double @llvm.fma.f64(double %5, double %15, double 0x3FC06EBA8214DB68)
  %17 = tail call double @llvm.fma.f64(double %2, double %16, double %2)
  br label %45

18:                                               ; preds = %1
  %19 = tail call double @llvm.fma.f64(double %2, double 0x3C598D37C14B24BE, double 0xBCC145A3502A41CD)
  %20 = tail call double @llvm.fma.f64(double %2, double %19, double 0x3D162DEED735F9EC)
  %21 = tail call double @llvm.fma.f64(double %2, double %20, double 0xBD61FFE55552CA22)
  %22 = tail call double @llvm.fma.f64(double %2, double %21, double 0x3DA4B9BA7074B644)
  %23 = tail call double @llvm.fma.f64(double %2, double %22, double 0xBDE20345A78CE240)
  %24 = tail call double @llvm.fma.f64(double %2, double %23, double 0x3E188B7A0CEFDDD8)
  %25 = tail call double @llvm.fma.f64(double %2, double %24, double 0xBE4ADED48C94B617)
  %26 = tail call double @llvm.fma.f64(double %2, double %25, double 0x3E7803AA312306D0)
  %27 = tail call double @llvm.fma.f64(double %2, double %26, double 0xBEA1B0106F4C5A9B)
  %28 = tail call double @llvm.fma.f64(double %2, double %27, double 0x3EC58C0E7CFD79AE)
  %29 = tail call double @llvm.fma.f64(double %2, double %28, double 0xBEE59E386410FDF7)
  %30 = tail call double @llvm.fma.f64(double %2, double %29, double 0x3F0192FC1F9B1786)
  %31 = tail call double @llvm.fma.f64(double %2, double %30, double 0xBF162CF3F4634B2E)
  %32 = tail call double @llvm.fma.f64(double %2, double %31, double 0x3F2314DFB42F7E4B)
  %33 = tail call double @llvm.fma.f64(double %2, double %32, double 0xBF12CB68C047288A)
  %34 = tail call double @llvm.fma.f64(double %2, double %33, double 0xBF4038FF7BBCCE25)
  %35 = tail call double @llvm.fma.f64(double %2, double %34, double 0x3F5A9466AE1BABAE)
  %36 = tail call double @llvm.fma.f64(double %2, double %35, double 0xBF258BE1E65A6063)
  %37 = tail call double @llvm.fma.f64(double %2, double %36, double 0xBF939BC16738EE3A)
  %38 = tail call double @llvm.fma.f64(double %2, double %37, double 0x3FBA4FBC28146B69)
  %39 = tail call double @llvm.fma.f64(double %2, double %38, double 0x3FE45F2DA69750C4)
  %40 = tail call double @llvm.fma.f64(double %2, double %39, double 0x3FC06EBB919FCCA8)
  %41 = tail call double @llvm.fma.f64(double %2, double %40, double %2)
  %42 = fneg double %41
  %43 = tail call spir_func double @__ocml_exp_f64(double noundef %42) #38
  %44 = fsub double 1.000000e+00, %43
  br label %45

45:                                               ; preds = %18, %4
  %46 = phi double [ %17, %4 ], [ %44, %18 ]
  %47 = tail call double @llvm.copysign.f64(double %46, double %0)
  ret double %47
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_erf_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = fcmp olt float %2, 1.000000e+00
  br i1 %3, label %4, label %12

4:                                                ; preds = %1
  %5 = fmul float %0, %0
  %6 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef 0xBF4268BC20000000, float noundef 0x3F74208280000000) #38
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef %6, float noundef 0xBF9B593700000000) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef %7, float noundef 0x3FBCE077C0000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef %8, float noundef 0xBFD8126600000000) #38
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef %9, float noundef 0x3FC06EBA00000000) #38
  %11 = tail call float @llvm.fma.f32(float %2, float %10, float %2)
  br label %23

12:                                               ; preds = %1
  %13 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef 0x3EF1D31560000000, float noundef 0xBF38D12900000000) #38
  %14 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %13, float noundef 0x3F6F9A6D20000000) #38
  %15 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %14, float noundef 0xBF98C31640000000) #38
  %16 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %15, float noundef 0x3FBB4E9C80000000) #38
  %17 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %16, float noundef 0x3FE4515FA0000000) #38
  %18 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %17, float noundef 0x3FC078E500000000) #38
  %19 = tail call float @llvm.fma.f32(float %2, float %18, float %2)
  %20 = fneg float %19
  %21 = tail call spir_func float @__ocml_exp_f32(float noundef %20) #38
  %22 = fsub float 1.000000e+00, %21
  br label %23

23:                                               ; preds = %12, %4
  %24 = phi float [ %11, %4 ], [ %22, %12 ]
  %25 = tail call float @llvm.copysign.f32(float %24, float %0)
  ret float %25
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_erf_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_erf_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_erf_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_erf_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_erf_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_erfc_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fneg double %0
  %4 = fmul double %3, %0
  %5 = fneg double %4
  %6 = tail call double @llvm.fma.f64(double %3, double %0, double %5)
  %7 = tail call spir_func double @__ocml_exp_f64(double noundef %4) #38
  %8 = tail call double @llvm.fma.f64(double %7, double %6, double %7)
  %9 = tail call spir_func double @__ocmlpriv_erfcx_f64(double noundef %2) #38
  %10 = fmul double %8, %9
  %11 = fcmp ogt double %2, 0x403B39DC41E48BFC
  %12 = select i1 %11, double 0.000000e+00, double %10
  %13 = fsub double 2.000000e+00, %12
  %14 = fcmp olt double %0, 0.000000e+00
  %15 = select i1 %14, double %13, double %12
  ret double %15
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_erfcx_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = fadd double %0, -4.000000e+00
  %3 = fadd double %0, 4.000000e+00
  %4 = fptrunc double %3 to float
  %5 = tail call spir_func float @_Z12native_recipf(float noundef %4) #38
  %6 = fpext float %5 to double
  %7 = fneg double %3
  %8 = tail call double @llvm.fma.f64(double %7, double %6, double 1.000000e+00)
  %9 = tail call double @llvm.fma.f64(double %8, double %6, double %6)
  %10 = tail call double @llvm.fma.f64(double %7, double %9, double 1.000000e+00)
  %11 = tail call double @llvm.fma.f64(double %10, double %9, double %9)
  %12 = fmul double %2, %11
  %13 = fneg double %12
  %14 = fadd double %12, 1.000000e+00
  %15 = tail call double @llvm.fma.f64(double %14, double -4.000000e+00, double %0)
  %16 = tail call double @llvm.fma.f64(double %13, double %0, double %15)
  %17 = tail call double @llvm.fma.f64(double %11, double %16, double %12)
  %18 = tail call double @llvm.fma.f64(double %17, double 0xBE41F39D54DF3C0E, double 0xBE41166337CFA789)
  %19 = tail call double @llvm.fma.f64(double %17, double %18, double 0x3E7B45F1D9802B82)
  %20 = tail call double @llvm.fma.f64(double %17, double %19, double 0x3E6D90488A03DCDB)
  %21 = tail call double @llvm.fma.f64(double %17, double %20, double 0xBEAB87B02EBA62D8)
  %22 = tail call double @llvm.fma.f64(double %17, double %21, double 0x3E95104BA56E15F1)
  %23 = tail call double @llvm.fma.f64(double %17, double %22, double 0x3ED7F29F71C907DE)
  %24 = tail call double @llvm.fma.f64(double %17, double %23, double 0xBEE78F5C2CD770FB)
  %25 = tail call double @llvm.fma.f64(double %17, double %24, double 0xBEF995FB76D0A51A)
  %26 = tail call double @llvm.fma.f64(double %17, double %25, double 0x3F23BE2EC022D0ED)
  %27 = tail call double @llvm.fma.f64(double %17, double %26, double 0xBF2A1DEB2FDBF62E)
  %28 = tail call double @llvm.fma.f64(double %17, double %27, double 0xBF48D4AC3689FC43)
  %29 = tail call double @llvm.fma.f64(double %17, double %28, double 0x3F749C67192D909B)
  %30 = tail call double @llvm.fma.f64(double %17, double %29, double 0xBF909623852FF070)
  %31 = tail call double @llvm.fma.f64(double %17, double %30, double 0x3FA3079EDFADEA8F)
  %32 = tail call double @llvm.fma.f64(double %17, double %31, double 0xBFB0FB06DFF65910)
  %33 = tail call double @llvm.fma.f64(double %17, double %32, double 0x3FB7FEE004DE8F32)
  %34 = tail call double @llvm.fma.f64(double %17, double %33, double 0xBFB9DDB23C3DBEB3)
  %35 = tail call double @llvm.fma.f64(double %17, double %34, double 0x3FB16ECEFCFA6930)
  %36 = tail call double @llvm.fma.f64(double %17, double %35, double 0x3F8F7F5DF66FB8A3)
  %37 = tail call double @llvm.fma.f64(double %17, double %36, double 0xBFC1DF1AD154A2A8)
  %38 = tail call double @llvm.fma.f64(double %17, double %37, double 0x3FCDD2C8B74FEBF8)
  %39 = fadd double %0, %0
  %40 = fadd double %39, 1.000000e+00
  %41 = fptrunc double %40 to float
  %42 = tail call spir_func float @_Z12native_recipf(float noundef %41) #38
  %43 = fpext float %42 to double
  %44 = fneg double %40
  %45 = tail call double @llvm.fma.f64(double %44, double %43, double 1.000000e+00)
  %46 = tail call double @llvm.fma.f64(double %45, double %43, double %43)
  %47 = tail call double @llvm.fma.f64(double %44, double %46, double 1.000000e+00)
  %48 = tail call double @llvm.fma.f64(double %47, double %46, double %46)
  %49 = tail call double @llvm.fma.f64(double %38, double %48, double %48)
  %50 = fneg double %49
  %51 = tail call double @llvm.fma.f64(double %50, double %39, double 1.000000e+00)
  %52 = fsub double %38, %49
  %53 = fadd double %51, %52
  %54 = tail call double @llvm.fma.f64(double %48, double %53, double %49)
  ret double %54
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_erfc_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = fneg float %0
  %4 = fmul float %3, %0
  %5 = fneg float %4
  %6 = tail call float @llvm.fma.f32(float %3, float %0, float %5)
  %7 = tail call spir_func float @__ocml_exp_f32(float noundef %4) #38
  %8 = tail call float @llvm.fma.f32(float %7, float %6, float %7)
  %9 = tail call spir_func float @__ocmlpriv_erfcx_f32(float noundef %2) #38
  %10 = fmul float %8, %9
  %11 = fcmp ogt float %2, 0x40241BBF80000000
  %12 = select i1 %11, float 0.000000e+00, float %10
  %13 = fsub float 2.000000e+00, %12
  %14 = fcmp olt float %0, 0.000000e+00
  %15 = select i1 %14, float %13, float %12
  ret float %15
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_erfcx_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = fadd float %0, -2.000000e+00
  %3 = fadd float %0, 2.000000e+00
  %4 = tail call spir_func float @_Z12native_recipf(float noundef %3) #38
  %5 = fmul float %2, %4
  %6 = fneg float %5
  %7 = fadd float %5, 1.000000e+00
  %8 = tail call float @llvm.fma.f32(float %7, float -2.000000e+00, float %0)
  %9 = tail call float @llvm.fma.f32(float %6, float %0, float %8)
  %10 = tail call float @llvm.fma.f32(float %4, float %9, float %5)
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef 0xBF3ADF1880000000, float noundef 0xBF545AEA60000000) #38
  %12 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef %11, float noundef 0x3F55A5F680000000) #38
  %13 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef %12, float noundef 0x3F81B44CE0000000) #38
  %14 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef %13, float noundef 0xBF8082B620000000) #38
  %15 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef %14, float noundef 0xBFABC14300000000) #38
  %16 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef %15, float noundef 0x3FC4FFC540000000) #38
  %17 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef %16, float noundef 0xBFC5407FA0000000) #38
  %18 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef %17, float noundef 0xBFB7BF6160000000) #38
  %19 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef %18, float noundef 0x3FD1BA0380000000) #38
  %20 = fadd float %0, %0
  %21 = fadd float %20, 1.000000e+00
  %22 = tail call spir_func float @_Z12native_recipf(float noundef %21) #38
  %23 = tail call float @llvm.fma.f32(float %19, float %22, float %22)
  %24 = fneg float %23
  %25 = tail call float @llvm.fma.f32(float %24, float %20, float 1.000000e+00)
  %26 = fsub float %19, %23
  %27 = fadd float %25, %26
  %28 = tail call float @llvm.fma.f32(float %22, float %27, float %23)
  ret float %28
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_erfc_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_erfc_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_erfc_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_erfc_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_erfc_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_erfcinv_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = fcmp ogt double %0, 6.250000e-01
  br i1 %2, label %3, label %6

3:                                                ; preds = %1
  %4 = fsub double 1.000000e+00, %0
  %5 = tail call spir_func double @__ocml_erfinv_f64(double noundef %4) #38
  br label %154

6:                                                ; preds = %1
  %7 = fcmp ogt double %0, 0x3F50000000000000
  br i1 %7, label %8, label %37

8:                                                ; preds = %6
  %9 = fsub double 2.000000e+00, %0
  %10 = fmul double %9, %0
  %11 = tail call double @llvm.log.f64(double %10)
  %12 = fsub double -3.125000e+00, %11
  %13 = tail call double @llvm.fma.f64(double %12, double 0x3BA1267A785A1166, double 0xBC0A6581051DD484)
  %14 = tail call double @llvm.fma.f64(double %12, double %13, double 0x3C32B2956FC047A4)
  %15 = tail call double @llvm.fma.f64(double %12, double %14, double 0x3C6AD835AED5CC07)
  %16 = tail call double @llvm.fma.f64(double %12, double %15, double 0xBCA25E0612EAE68F)
  %17 = tail call double @llvm.fma.f64(double %12, double %16, double 0x3C6A0CAB63F02A91)
  %18 = tail call double @llvm.fma.f64(double %12, double %17, double 0x3CFD9227AF501ADB)
  %19 = tail call double @llvm.fma.f64(double %12, double %18, double 0xBD26C3AD559A9B4E)
  %20 = tail call double @llvm.fma.f64(double %12, double %19, double 0xBD36CAFA36036318)
  %21 = tail call double @llvm.fma.f64(double %12, double %20, double 0x3D872879641E158F)
  %22 = tail call double @llvm.fma.f64(double %12, double %21, double 0xBDAC89D755F7FFF8)
  %23 = tail call double @llvm.fma.f64(double %12, double %22, double 0xBDCDC51171DDAE3A)
  %24 = tail call double @llvm.fma.f64(double %12, double %23, double 0x3E120F512744AE65)
  %25 = tail call double @llvm.fma.f64(double %12, double %24, double 0xBE31A9E5F4BCFCD8)
  %26 = tail call double @llvm.fma.f64(double %12, double %25, double 0xBE5F36CE926B83E8)
  %27 = tail call double @llvm.fma.f64(double %12, double %26, double 0x3E9C6B4F6C7CFA1E)
  %28 = tail call double @llvm.fma.f64(double %12, double %27, double 0xBEB6E8A53E0C2026)
  %29 = tail call double @llvm.fma.f64(double %12, double %28, double 0xBEED1D1F7BF4570B)
  %30 = tail call double @llvm.fma.f64(double %12, double %29, double 0x3F2879C2A20CC3E2)
  %31 = tail call double @llvm.fma.f64(double %12, double %30, double 0xBF48457694844D14)
  %32 = tail call double @llvm.fma.f64(double %12, double %31, double 0xBF78B6C33114EDAD)
  %33 = tail call double @llvm.fma.f64(double %12, double %32, double 0x3FCEBD80D9B13E14)
  %34 = tail call double @llvm.fma.f64(double %12, double %33, double 0x3FFA755E7C99AE86)
  %35 = fneg double %0
  %36 = tail call double @llvm.fma.f64(double %35, double %34, double %34)
  br label %154

37:                                               ; preds = %6
  %38 = tail call double @llvm.log.f64(double %0)
  %39 = fneg double %38
  %40 = fcmp ogt double %38, 0x9000000000000000
  %41 = select i1 %40, double 0x4FF0000000000000, double 1.000000e+00
  %42 = fmul double %41, %39
  %43 = fptrunc double %42 to float
  %44 = tail call spir_func float @_Z12native_rsqrtf(float noundef %43) #38
  %45 = fpext float %44 to double
  %46 = fmul double %42, %45
  %47 = fmul double %45, 5.000000e-01
  %48 = fneg double %47
  %49 = tail call double @llvm.fma.f64(double %48, double %46, double 5.000000e-01)
  %50 = tail call double @llvm.fma.f64(double %47, double %49, double %47)
  %51 = tail call double @llvm.fma.f64(double %46, double %49, double %46)
  %52 = fneg double %51
  %53 = tail call double @llvm.fma.f64(double %52, double %51, double %42)
  %54 = tail call double @llvm.fma.f64(double %53, double %50, double %51)
  %55 = fneg double %54
  %56 = tail call double @llvm.fma.f64(double %55, double %54, double %42)
  %57 = tail call double @llvm.fma.f64(double %56, double %50, double %54)
  %58 = select i1 %40, double 0x37F0000000000000, double 1.000000e+00
  %59 = fmul double %58, %57
  %60 = tail call i1 @llvm.is.fpclass.f64(double %42, i32 608)
  %61 = select i1 %60, double %42, double %59
  %62 = fdiv double 1.000000e+00, %61
  %63 = fcmp ogt double %0, 0x3EC0000000000000
  br i1 %63, label %64, label %76

64:                                               ; preds = %37
  %65 = tail call double @llvm.fma.f64(double %62, double 0x4038B3CFC98A5212, double 0xC05907BCDAB54A4E)
  %66 = tail call double @llvm.fma.f64(double %62, double %65, double 0x4067659CF8216D7D)
  %67 = tail call double @llvm.fma.f64(double %62, double %66, double 0xC06AC222777F664D)
  %68 = tail call double @llvm.fma.f64(double %62, double %67, double 0x4064F2F8E33151AC)
  %69 = tail call double @llvm.fma.f64(double %62, double %68, double 0xC057D7D1EB301C4C)
  %70 = tail call double @llvm.fma.f64(double %62, double %69, double 0x40448E630C1C77E7)
  %71 = tail call double @llvm.fma.f64(double %62, double %70, double 0xC02C63E7D0E327F6)
  %72 = tail call double @llvm.fma.f64(double %62, double %71, double 0x401225B286AEB0DF)
  %73 = tail call double @llvm.fma.f64(double %62, double %72, double 0xBFF82A4ACC22B05D)
  %74 = tail call double @llvm.fma.f64(double %62, double %73, double 0xBFA0A88271680E57)
  %75 = tail call double @llvm.fma.f64(double %62, double %74, double 0x3FF001F6ACEBB122)
  br label %151

76:                                               ; preds = %37
  %77 = fcmp ogt double %0, 0x3D70000000000000
  br i1 %77, label %78, label %90

78:                                               ; preds = %76
  %79 = tail call double @llvm.fma.f64(double %62, double 0x4080FDCB40BF066D, double 0xC09870DDEAA832DB)
  %80 = tail call double @llvm.fma.f64(double %62, double %79, double 0x40A035C39E0428C4)
  %81 = tail call double @llvm.fma.f64(double %62, double %80, double 0xC09A4D3C54A3EC14)
  %82 = tail call double @llvm.fma.f64(double %62, double %81, double 0x408D382AEE6EFAE8)
  %83 = tail call double @llvm.fma.f64(double %62, double %82, double 0xC0779F9E26565BC1)
  %84 = tail call double @llvm.fma.f64(double %62, double %83, double 0x405D00E058CE9ABA)
  %85 = tail call double @llvm.fma.f64(double %62, double %84, double 0xC03C7D1E01821EB3)
  %86 = tail call double @llvm.fma.f64(double %62, double %85, double 0x4019D930BA7A3111)
  %87 = tail call double @llvm.fma.f64(double %62, double %86, double 0xBFFAF47941DD2BAA)
  %88 = tail call double @llvm.fma.f64(double %62, double %87, double 0xBF9787ECC823998B)
  %89 = tail call double @llvm.fma.f64(double %62, double %88, double 0x3FF000FAE5FB73E3)
  br label %151

90:                                               ; preds = %76
  %91 = fcmp ogt double %0, 0x3AD0000000000000
  br i1 %91, label %92, label %104

92:                                               ; preds = %90
  %93 = tail call double @llvm.fma.f64(double %62, double 0x40CC9E5B8E31C18E, double 0xC0DC866153B1BCE6)
  %94 = tail call double @llvm.fma.f64(double %62, double %93, double 0x40DA386B3B4FB25C)
  %95 = tail call double @llvm.fma.f64(double %62, double %94, double 0xC0CD7BF378E7B5FB)
  %96 = tail call double @llvm.fma.f64(double %62, double %95, double 0x40B6B416DE0A7A75)
  %97 = tail call double @llvm.fma.f64(double %62, double %96, double 0xC099757C1CF44E90)
  %98 = tail call double @llvm.fma.f64(double %62, double %97, double 0x4075B56EDEDBAA8C)
  %99 = tail call double @llvm.fma.f64(double %62, double %98, double 0xC04DA79924B4D155)
  %100 = tail call double @llvm.fma.f64(double %62, double %99, double 0x4022BA25315D612B)
  %101 = tail call double @llvm.fma.f64(double %62, double %100, double 0xBFFDE5808FBD786D)
  %102 = tail call double @llvm.fma.f64(double %62, double %101, double 0xBF904E014B9FC507)
  %103 = tail call double @llvm.fma.f64(double %62, double %102, double 0x3FF000788DF1C89F)
  br label %151

104:                                              ; preds = %90
  %105 = fcmp ogt double %0, 0x3370000000000000
  br i1 %105, label %106, label %118

106:                                              ; preds = %104
  %107 = tail call double @llvm.fma.f64(double %62, double 0x411FF518AAE00301, double 0xC125781EF98C6AA9)
  %108 = tail call double @llvm.fma.f64(double %62, double %107, double 0x411A9511B21C7715)
  %109 = tail call double @llvm.fma.f64(double %62, double %108, double 0xC1041D8F1455B21E)
  %110 = tail call double @llvm.fma.f64(double %62, double %109, double 0x40E4D4A3D4025A4C)
  %111 = tail call double @llvm.fma.f64(double %62, double %110, double 0xC0BF640FE7077996)
  %112 = tail call double @llvm.fma.f64(double %62, double %111, double 0x4091FAF674F42181)
  %113 = tail call double @llvm.fma.f64(double %62, double %112, double 0xC06080C5CD81D791)
  %114 = tail call double @llvm.fma.f64(double %62, double %113, double 0x402C0AE370098EF4)
  %115 = tail call double @llvm.fma.f64(double %62, double %114, double 0xC0008EBD67DC005A)
  %116 = tail call double @llvm.fma.f64(double %62, double %115, double 0xBF85CF3329E72289)
  %117 = tail call double @llvm.fma.f64(double %62, double %116, double 0x3FF00035E75F27E2)
  br label %151

118:                                              ; preds = %104
  %119 = fcmp ogt double %0, 0x26F0000000000000
  br i1 %119, label %120, label %131

120:                                              ; preds = %118
  %121 = tail call double @llvm.fma.f64(double %62, double 0xC13D554F00BF9D81, double 0x4138456711FF3627)
  %122 = tail call double @llvm.fma.f64(double %62, double %121, double 0xC1226C90ACC5DAAF)
  %123 = tail call double @llvm.fma.f64(double %62, double %122, double 0x410106501CDEF815)
  %124 = tail call double @llvm.fma.f64(double %62, double %123, double 0xC0D57A4C95601C04)
  %125 = tail call double @llvm.fma.f64(double %62, double %124, double 0x40A3CA627CBAEDE6)
  %126 = tail call double @llvm.fma.f64(double %62, double %125, double 0xC06C716E091922FB)
  %127 = tail call double @llvm.fma.f64(double %62, double %126, double 0x403292F8F6E8BC75)
  %128 = tail call double @llvm.fma.f64(double %62, double %127, double 0xC001B469C212BD5F)
  %129 = tail call double @llvm.fma.f64(double %62, double %128, double 0xBF804977FB6D0462)
  %130 = tail call double @llvm.fma.f64(double %62, double %129, double 0x3FF0001DC9F52F8A)
  br label %151

131:                                              ; preds = %118
  %132 = fcmp ogt double %0, 0x7B0000000000000
  br i1 %132, label %133, label %144

133:                                              ; preds = %131
  %134 = tail call double @llvm.fma.f64(double %62, double 0xC1821913925F3A73, double 0x4174AA2FBA282B9B)
  %135 = tail call double @llvm.fma.f64(double %62, double %134, double 0xC155A2A3F9742896)
  %136 = tail call double @llvm.fma.f64(double %62, double %135, double 0x412B8EE3895772E8)
  %137 = tail call double @llvm.fma.f64(double %62, double %136, double 0xC0F7F2CE0B036BE4)
  %138 = tail call double @llvm.fma.f64(double %62, double %137, double 0x40BE62AB1BCBB738)
  %139 = tail call double @llvm.fma.f64(double %62, double %138, double 0xC07E0ED2965D2A06)
  %140 = tail call double @llvm.fma.f64(double %62, double %139, double 0x403B0C16705263E5)
  %141 = tail call double @llvm.fma.f64(double %62, double %140, double 0xC00334F9A732ECC7)
  %142 = tail call double @llvm.fma.f64(double %62, double %141, double 0xBF765F60412F9578)
  %143 = tail call double @llvm.fma.f64(double %62, double %142, double 0x3FF0000E0BDA43B5)
  br label %151

144:                                              ; preds = %131
  %145 = tail call double @llvm.fma.f64(double %62, double 0xC0AE3D70F1FDC7BE, double 0x40928D9ACD5B9596)
  %146 = tail call double @llvm.fma.f64(double %62, double %145, double 0xC06554C1CE591414)
  %147 = tail call double @llvm.fma.f64(double %62, double %146, double 0x40315B1E5A1FE7F5)
  %148 = tail call double @llvm.fma.f64(double %62, double %147, double 0xC001AA8E6F616C69)
  %149 = tail call double @llvm.fma.f64(double %62, double %148, double 0xBF7F6803B3B4D6CC)
  %150 = tail call double @llvm.fma.f64(double %62, double %149, double 0x3FF00019AC5BED2A)
  br label %151

151:                                              ; preds = %78, %106, %133, %144, %120, %92, %64
  %152 = phi double [ %75, %64 ], [ %89, %78 ], [ %103, %92 ], [ %117, %106 ], [ %130, %120 ], [ %143, %133 ], [ %150, %144 ]
  %153 = fmul double %61, %152
  br label %154

154:                                              ; preds = %8, %151, %3
  %155 = phi double [ %5, %3 ], [ %36, %8 ], [ %153, %151 ]
  %156 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %157 = icmp eq i8 %156, 0
  br i1 %157, label %158, label %167

158:                                              ; preds = %154
  %159 = fcmp olt double %0, 0.000000e+00
  %160 = fcmp ogt double %0, 2.000000e+00
  %161 = or i1 %159, %160
  %162 = select i1 %161, double 0x7FF8000000000000, double %155
  %163 = fcmp oeq double %0, 0.000000e+00
  %164 = select i1 %163, double 0x7FF0000000000000, double %162
  %165 = fcmp oeq double %0, 2.000000e+00
  %166 = select i1 %165, double 0xFFF0000000000000, double %164
  br label %167

167:                                              ; preds = %158, %154
  %168 = phi double [ %155, %154 ], [ %166, %158 ]
  ret double %168
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_erfinv_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fcmp olt double %2, 3.750000e-01
  br i1 %3, label %4, label %22

4:                                                ; preds = %1
  %5 = fmul double %0, %0
  %6 = tail call double @llvm.fma.f64(double %5, double 0x3FDC5EC06CD8002B, double 0xBFEBB7DD47AEF0D6)
  %7 = tail call double @llvm.fma.f64(double %5, double %6, double 0x3FED189992ECCDB6)
  %8 = tail call double @llvm.fma.f64(double %5, double %7, double 0xBFE10EC180CDE957)
  %9 = tail call double @llvm.fma.f64(double %5, double %8, double 0x3FD05CCE379DD66F)
  %10 = tail call double @llvm.fma.f64(double %5, double %9, double 0xBFA6B9067E3DAE74)
  %11 = tail call double @llvm.fma.f64(double %5, double %10, double 0x3FA5F7F0487C11A3)
  %12 = tail call double @llvm.fma.f64(double %5, double %11, double 0x3F9E0FBF22B2350C)
  %13 = tail call double @llvm.fma.f64(double %5, double %12, double 0x3FA2CE26322B7F90)
  %14 = tail call double @llvm.fma.f64(double %5, double %13, double 0x3FA5EBEEEE81DD31)
  %15 = tail call double @llvm.fma.f64(double %5, double %14, double 0x3FAA7CACB897F0D4)
  %16 = tail call double @llvm.fma.f64(double %5, double %15, double 0x3FB0A130D62CBA32)
  %17 = tail call double @llvm.fma.f64(double %5, double %16, double 0x3FB62847C8653359)
  %18 = tail call double @llvm.fma.f64(double %5, double %17, double 0x3FC053C2C0A5E083)
  %19 = tail call double @llvm.fma.f64(double %5, double %18, double 0x3FCDB29FB2FEEC72)
  %20 = tail call double @llvm.fma.f64(double %5, double %19, double 0x3FEC5BF891B4EF6A)
  %21 = fmul double %2, %20
  br label %188

22:                                               ; preds = %1
  %23 = fcmp olt double %2, 0x3FEFFFE000000000
  br i1 %23, label %24, label %135

24:                                               ; preds = %22
  %25 = fneg double %2
  %26 = tail call double @llvm.fma.f64(double %25, double %2, double 1.000000e+00)
  %27 = tail call double @llvm.log.f64(double %26)
  %28 = fcmp ogt double %27, -6.250000e+00
  br i1 %28, label %29, label %53

29:                                               ; preds = %24
  %30 = fsub double -3.125000e+00, %27
  %31 = tail call double @llvm.fma.f64(double %30, double 0xBBB135D2E746E627, double 0xBC08DDF93324D327)
  %32 = tail call double @llvm.fma.f64(double %30, double %31, double 0x3C37B83EEF0B7C9F)
  %33 = tail call double @llvm.fma.f64(double %30, double %32, double 0x3C69BA72CD589B91)
  %34 = tail call double @llvm.fma.f64(double %30, double %33, double 0xBCA33689090A6B96)
  %35 = tail call double @llvm.fma.f64(double %30, double %34, double 0x3C782E11898132E0)
  %36 = tail call double @llvm.fma.f64(double %30, double %35, double 0x3CFDE4ACFD9E26BA)
  %37 = tail call double @llvm.fma.f64(double %30, double %36, double 0xBD26D33EED66C487)
  %38 = tail call double @llvm.fma.f64(double %30, double %37, double 0xBD36F2167040D8E2)
  %39 = tail call double @llvm.fma.f64(double %30, double %38, double 0x3D872A22C2D77E20)
  %40 = tail call double @llvm.fma.f64(double %30, double %39, double 0xBDAC8859C4E5C0AF)
  %41 = tail call double @llvm.fma.f64(double %30, double %40, double 0xBDCDC583D118A561)
  %42 = tail call double @llvm.fma.f64(double %30, double %41, double 0x3E120F47CCF46B3C)
  %43 = tail call double @llvm.fma.f64(double %30, double %42, double 0xBE31A9E38DC84D60)
  %44 = tail call double @llvm.fma.f64(double %30, double %43, double 0xBE5F36CD6D3D46A9)
  %45 = tail call double @llvm.fma.f64(double %30, double %44, double 0x3E9C6B4F5D03B787)
  %46 = tail call double @llvm.fma.f64(double %30, double %45, double 0xBEB6E8A5434AE8A2)
  %47 = tail call double @llvm.fma.f64(double %30, double %46, double 0xBEED1D1F7B8736F6)
  %48 = tail call double @llvm.fma.f64(double %30, double %47, double 0x3F2879C2A212F024)
  %49 = tail call double @llvm.fma.f64(double %30, double %48, double 0xBF4845769484FCA8)
  %50 = tail call double @llvm.fma.f64(double %30, double %49, double 0xBF78B6C33114F909)
  %51 = tail call double @llvm.fma.f64(double %30, double %50, double 0x3FCEBD80D9B13E28)
  %52 = tail call double @llvm.fma.f64(double %30, double %51, double 0x3FFA755E7C99AE86)
  br label %132

53:                                               ; preds = %24
  %54 = fneg double %27
  %55 = fcmp ogt double %27, -1.600000e+01
  %56 = fcmp ogt double %27, 0x9000000000000000
  %57 = select i1 %56, double 0x4FF0000000000000, double 1.000000e+00
  %58 = fmul double %57, %54
  %59 = fptrunc double %58 to float
  %60 = select i1 %56, double 0x37F0000000000000, double 1.000000e+00
  %61 = tail call i1 @llvm.is.fpclass.f64(double %58, i32 608)
  br i1 %55, label %62, label %98

62:                                               ; preds = %53
  %63 = tail call spir_func float @_Z12native_rsqrtf(float noundef %59) #38
  %64 = fpext float %63 to double
  %65 = fmul double %58, %64
  %66 = fmul double %64, 5.000000e-01
  %67 = fneg double %66
  %68 = tail call double @llvm.fma.f64(double %67, double %65, double 5.000000e-01)
  %69 = tail call double @llvm.fma.f64(double %66, double %68, double %66)
  %70 = tail call double @llvm.fma.f64(double %65, double %68, double %65)
  %71 = fneg double %70
  %72 = tail call double @llvm.fma.f64(double %71, double %70, double %58)
  %73 = tail call double @llvm.fma.f64(double %72, double %69, double %70)
  %74 = fneg double %73
  %75 = tail call double @llvm.fma.f64(double %74, double %73, double %58)
  %76 = tail call double @llvm.fma.f64(double %75, double %69, double %73)
  %77 = fmul double %60, %76
  %78 = select i1 %61, double %58, double %77
  %79 = fadd double %78, -3.250000e+00
  %80 = tail call double @llvm.fma.f64(double %79, double 0x3E23040F87DBD932, double 0x3E785CBE52878635)
  %81 = tail call double @llvm.fma.f64(double %79, double %80, double 0xBE92777453DD3955)
  %82 = tail call double @llvm.fma.f64(double %79, double %81, double 0x3E5395ABCD554C6C)
  %83 = tail call double @llvm.fma.f64(double %79, double %82, double 0x3EB936388A3790AD)
  %84 = tail call double @llvm.fma.f64(double %79, double %83, double 0xBED0D5DB812B5083)
  %85 = tail call double @llvm.fma.f64(double %79, double %84, double 0x3EC8860CD5D652F6)
  %86 = tail call double @llvm.fma.f64(double %79, double %85, double 0x3EEA29A0CACDFB23)
  %87 = tail call double @llvm.fma.f64(double %79, double %86, double 0xBF08CEF1F80281F2)
  %88 = tail call double @llvm.fma.f64(double %79, double %87, double 0x3F11E684D0B9188A)
  %89 = tail call double @llvm.fma.f64(double %79, double %88, double 0x3EF932CD54C8A222)
  %90 = tail call double @llvm.fma.f64(double %79, double %89, double 0xBF37448A89EF8AA3)
  %91 = tail call double @llvm.fma.f64(double %79, double %90, double 0x3F4F3CC55AD40C25)
  %92 = tail call double @llvm.fma.f64(double %79, double %91, double 0xBF5BA924132F38B1)
  %93 = tail call double @llvm.fma.f64(double %79, double %92, double 0x3F6468EECA533CF8)
  %94 = tail call double @llvm.fma.f64(double %79, double %93, double 0xBF6EBADABB891BBD)
  %95 = tail call double @llvm.fma.f64(double %79, double %94, double 0x3F75FFCFE5B76AFC)
  %96 = tail call double @llvm.fma.f64(double %79, double %95, double 0x3FF0158A6D641D39)
  %97 = tail call double @llvm.fma.f64(double %79, double %96, double 0x4008ABCC380D5A48)
  br label %132

98:                                               ; preds = %53
  %99 = tail call spir_func float @_Z12native_rsqrtf(float noundef %59) #38
  %100 = fpext float %99 to double
  %101 = fmul double %58, %100
  %102 = fmul double %100, 5.000000e-01
  %103 = fneg double %102
  %104 = tail call double @llvm.fma.f64(double %103, double %101, double 5.000000e-01)
  %105 = tail call double @llvm.fma.f64(double %102, double %104, double %102)
  %106 = tail call double @llvm.fma.f64(double %101, double %104, double %101)
  %107 = fneg double %106
  %108 = tail call double @llvm.fma.f64(double %107, double %106, double %58)
  %109 = tail call double @llvm.fma.f64(double %108, double %105, double %106)
  %110 = fneg double %109
  %111 = tail call double @llvm.fma.f64(double %110, double %109, double %58)
  %112 = tail call double @llvm.fma.f64(double %111, double %105, double %109)
  %113 = fmul double %60, %112
  %114 = select i1 %61, double %58, double %113
  %115 = fadd double %114, -5.000000e+00
  %116 = tail call double @llvm.fma.f64(double %115, double 0xBDBDCEC3A7785389, double 0xBDF18FEEC0E38727)
  %117 = tail call double @llvm.fma.f64(double %115, double %116, double 0x3E19E6BF2DDA45E3)
  %118 = tail call double @llvm.fma.f64(double %115, double %117, double 0xBE30468FB24E2F5F)
  %119 = tail call double @llvm.fma.f64(double %115, double %118, double 0x3E405AC6A8FBA182)
  %120 = tail call double @llvm.fma.f64(double %115, double %119, double 0xBE50102E495FB9C0)
  %121 = tail call double @llvm.fma.f64(double %115, double %120, double 0x3E5F4C20E1334AF8)
  %122 = tail call double @llvm.fma.f64(double %115, double %121, double 0xBE722D220FDF9C3E)
  %123 = tail call double @llvm.fma.f64(double %115, double %122, double 0x3E8EBC8BB824CB54)
  %124 = tail call double @llvm.fma.f64(double %115, double %123, double 0xBEB0A8D40EA372CC)
  %125 = tail call double @llvm.fma.f64(double %115, double %124, double 0x3ED2FBD29D093D2B)
  %126 = tail call double @llvm.fma.f64(double %115, double %125, double 0xBEF4A3497E1E0FAC)
  %127 = tail call double @llvm.fma.f64(double %115, double %126, double 0x3F13EBF4EB00938F)
  %128 = tail call double @llvm.fma.f64(double %115, double %127, double 0xBF2C2F36A8FC5D53)
  %129 = tail call double @llvm.fma.f64(double %115, double %128, double 0xBF222EA5DF04047C)
  %130 = tail call double @llvm.fma.f64(double %115, double %129, double 0x3FF02A30D1FBA0DC)
  %131 = tail call double @llvm.fma.f64(double %115, double %130, double 0x4013664DDD1AD7FB)
  br label %132

132:                                              ; preds = %62, %98, %29
  %133 = phi double [ %52, %29 ], [ %97, %62 ], [ %131, %98 ]
  %134 = fmul double %2, %133
  br label %188

135:                                              ; preds = %22
  %136 = fsub double 1.000000e+00, %2
  %137 = tail call double @llvm.log.f64(double %136)
  %138 = fneg double %137
  %139 = fcmp ogt double %137, 0x9000000000000000
  %140 = select i1 %139, double 0x4FF0000000000000, double 1.000000e+00
  %141 = fmul double %140, %138
  %142 = fptrunc double %141 to float
  %143 = tail call spir_func float @_Z12native_rsqrtf(float noundef %142) #38
  %144 = fpext float %143 to double
  %145 = fmul double %141, %144
  %146 = fmul double %144, 5.000000e-01
  %147 = fneg double %146
  %148 = tail call double @llvm.fma.f64(double %147, double %145, double 5.000000e-01)
  %149 = tail call double @llvm.fma.f64(double %146, double %148, double %146)
  %150 = tail call double @llvm.fma.f64(double %145, double %148, double %145)
  %151 = fneg double %150
  %152 = tail call double @llvm.fma.f64(double %151, double %150, double %141)
  %153 = tail call double @llvm.fma.f64(double %152, double %149, double %150)
  %154 = fneg double %153
  %155 = tail call double @llvm.fma.f64(double %154, double %153, double %141)
  %156 = tail call double @llvm.fma.f64(double %155, double %149, double %153)
  %157 = select i1 %139, double 0x37F0000000000000, double 1.000000e+00
  %158 = fmul double %157, %156
  %159 = tail call i1 @llvm.is.fpclass.f64(double %141, i32 608)
  %160 = select i1 %159, double %141, double %158
  %161 = fdiv double 1.000000e+00, %160
  %162 = fcmp olt double %2, 0x3FEFFFFFFFE00000
  br i1 %162, label %163, label %175

163:                                              ; preds = %135
  %164 = tail call double @llvm.fma.f64(double %161, double 0x406C4BD831A51669, double 0xC0866AF45B757C26)
  %165 = tail call double @llvm.fma.f64(double %161, double %164, double 0x409061B293EE1671)
  %166 = tail call double @llvm.fma.f64(double %161, double %165, double 0xC08D4AA0FD7248E9)
  %167 = tail call double @llvm.fma.f64(double %161, double %166, double 0x4081EEBB0088748D)
  %168 = tail call double @llvm.fma.f64(double %161, double %167, double 0xC06FF4CB6C165EFE)
  %169 = tail call double @llvm.fma.f64(double %161, double %168, double 0x40559C379A609255)
  %170 = tail call double @llvm.fma.f64(double %161, double %169, double 0xC03762B2677680C6)
  %171 = tail call double @llvm.fma.f64(double %161, double %170, double 0x4017626132CF7C5A)
  %172 = tail call double @llvm.fma.f64(double %161, double %171, double 0xBFFA298CC231A949)
  %173 = tail call double @llvm.fma.f64(double %161, double %172, double 0xBF99FA2D429B22CA)
  %174 = tail call double @llvm.fma.f64(double %161, double %173, double 0x3FF00131C4B15D15)
  br label %185

175:                                              ; preds = %135
  %176 = tail call double @llvm.fma.f64(double %161, double 0x406E1F462CC8E58A, double 0xC07DD260D25BEE8D)
  %177 = tail call double @llvm.fma.f64(double %161, double %176, double 0x407AF7DAB6C206E6)
  %178 = tail call double @llvm.fma.f64(double %161, double %177, double 0xC06D97C75A0F5809)
  %179 = tail call double @llvm.fma.f64(double %161, double %178, double 0x405632C20BF45D30)
  %180 = tail call double @llvm.fma.f64(double %161, double %179, double 0xC038E4908179A727)
  %181 = tail call double @llvm.fma.f64(double %161, double %180, double 0x40189538A73A2C3C)
  %182 = tail call double @llvm.fma.f64(double %161, double %181, double 0xBFFAAD8569B3607D)
  %183 = tail call double @llvm.fma.f64(double %161, double %182, double 0xBF980D1BEC4B54CB)
  %184 = tail call double @llvm.fma.f64(double %161, double %183, double 0x3FF001006F90EA2C)
  br label %185

185:                                              ; preds = %175, %163
  %186 = phi double [ %174, %163 ], [ %184, %175 ]
  %187 = fmul double %160, %186
  br label %188

188:                                              ; preds = %132, %185, %4
  %189 = phi double [ %21, %4 ], [ %134, %132 ], [ %187, %185 ]
  %190 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %191 = icmp eq i8 %190, 0
  %192 = fcmp ogt double %2, 1.000000e+00
  %193 = select i1 %192, double 0x7FF8000000000000, double %189
  %194 = fcmp oeq double %2, 1.000000e+00
  %195 = select i1 %194, double 0x7FF0000000000000, double %193
  %196 = select i1 %191, double %195, double %189
  %197 = tail call double @llvm.copysign.f64(double %196, double %0)
  ret double %197
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.log.f64(double) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_erfcinv_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = fcmp ogt float %0, 6.250000e-01
  br i1 %2, label %3, label %6

3:                                                ; preds = %1
  %4 = fsub float 1.000000e+00, %0
  %5 = tail call spir_func float @__ocml_erfinv_f32(float noundef %4) #38
  br label %52

6:                                                ; preds = %1
  %7 = fcmp ogt float %0, 0x3F50000000000000
  br i1 %7, label %8, label %27

8:                                                ; preds = %6
  %9 = fsub float 2.000000e+00, %0
  %10 = fmul float %9, %0
  %11 = fpext float %10 to double
  %12 = tail call double @llvm.log.f64(double %11)
  %13 = fsub double -3.125000e+00, %12
  %14 = fptrunc double %13 to float
  %15 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef 0x3E07EE6620000000, float noundef 0xBE33F5A800000000) #38
  %16 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %15, float noundef 0xBE5B638F00000000) #38
  %17 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %16, float noundef 0x3E9C9CCC60000000) #38
  %18 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %17, float noundef 0xBEB72F8AE0000000) #38
  %19 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %18, float noundef 0xBEED21AA60000000) #38
  %20 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %19, float noundef 0x3F287AEBC0000000) #38
  %21 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %20, float noundef 0xBF48455D40000000) #38
  %22 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %21, float noundef 0xBF78B6CA40000000) #38
  %23 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %22, float noundef 0x3FCEBD80C0000000) #38
  %24 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %23, float noundef 0x3FFA755E80000000) #38
  %25 = fneg float %0
  %26 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %25, float noundef %24, float noundef %24) #38
  br label %52

27:                                               ; preds = %6
  %28 = fpext float %0 to double
  %29 = tail call double @llvm.log.f64(double %28)
  %30 = fptrunc double %29 to float
  %31 = fneg float %30
  %32 = tail call float @llvm.sqrt.f32(float %31), !fpmath !18
  %33 = tail call spir_func float @_Z12native_recipf(float noundef %32) #38
  %34 = fcmp ogt float %0, 0x3D50000000000000
  br i1 %34, label %35, label %42

35:                                               ; preds = %27
  %36 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef 0xBFF57221E0000000, float noundef 0x4007F61440000000) #38
  %37 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef %36, float noundef 0xC0098DD400000000) #38
  %38 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef %37, float noundef 0x4002C90660000000) #38
  %39 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef %38, float noundef 0xBFF3A07EA0000000) #38
  %40 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef %39, float noundef 0xBFABA546C0000000) #38
  %41 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef %40, float noundef 0x3FF004E660000000) #38
  br label %49

42:                                               ; preds = %27
  %43 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef 0xC03649C6A0000000, float noundef 0x4038FA8FA0000000) #38
  %44 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef %43, float noundef 0xC02A112D80000000) #38
  %45 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef %44, float noundef 0x401309D980000000) #38
  %46 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef %45, float noundef 0xBFF9194880000000) #38
  %47 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef %46, float noundef 0xBF9C084EC0000000) #38
  %48 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef %47, float noundef 0x3FF00143E0000000) #38
  br label %49

49:                                               ; preds = %42, %35
  %50 = phi float [ %41, %35 ], [ %48, %42 ]
  %51 = fmul float %32, %50
  br label %52

52:                                               ; preds = %8, %49, %3
  %53 = phi float [ %5, %3 ], [ %26, %8 ], [ %51, %49 ]
  %54 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %55 = icmp eq i8 %54, 0
  br i1 %55, label %56, label %65

56:                                               ; preds = %52
  %57 = fcmp olt float %0, 0.000000e+00
  %58 = fcmp ogt float %0, 2.000000e+00
  %59 = or i1 %57, %58
  %60 = select i1 %59, float 0x7FF8000000000000, float %53
  %61 = fcmp oeq float %0, 0.000000e+00
  %62 = select i1 %61, float 0x7FF0000000000000, float %60
  %63 = fcmp oeq float %0, 2.000000e+00
  %64 = select i1 %63, float 0xFFF0000000000000, float %62
  br label %65

65:                                               ; preds = %56, %52
  %66 = phi float [ %53, %52 ], [ %64, %56 ]
  ret float %66
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_erfinv_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = tail call float @llvm.fabs.f32(float %0)
  %4 = fcmp olt float %3, 3.750000e-01
  br i1 %4, label %5, label %13

5:                                                ; preds = %1
  %6 = fmul float %0, %0
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef 0x3FC48B6CA0000000, float noundef 0xBF9A2930A0000000) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %7, float noundef 0x3FB65B0B40000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %8, float noundef 0x3FB5581AE0000000) #38
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %9, float noundef 0x3FC05AA560000000) #38
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %10, float noundef 0x3FCDB27480000000) #38
  %12 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %11, float noundef 0x3FEC5BF8A0000000) #38
  br label %94

13:                                               ; preds = %1
  %14 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %15 = freeze i32 %14
  %16 = icmp sgt i32 %15, 8999
  br i1 %16, label %18, label %17

17:                                               ; preds = %13
  switch i32 %15, label %21 [
    i32 8001, label %18
    i32 7001, label %18
  ]

18:                                               ; preds = %17, %17, %13
  %19 = fneg float %3
  %20 = tail call float @llvm.fma.f32(float %19, float %3, float 1.000000e+00)
  br label %25

21:                                               ; preds = %17
  %22 = fsub float 1.000000e+00, %3
  %23 = fadd float %3, 1.000000e+00
  %24 = fmul float %22, %23
  br label %25

25:                                               ; preds = %21, %18
  %26 = phi float [ %20, %18 ], [ %24, %21 ]
  %27 = fpext float %26 to double
  %28 = tail call double @llvm.log.f64(double %27)
  %29 = fptrunc double %28 to float
  %30 = fcmp ogt float %29, -5.000000e+00
  br i1 %30, label %31, label %41

31:                                               ; preds = %25
  %32 = fsub float -2.500000e+00, %29
  %33 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %32, float noundef 0x3E5E2CB100000000, float noundef 0x3E970966C0000000) #38
  %34 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %32, float noundef %33, float noundef 0xBECD8E6AE0000000) #38
  %35 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %32, float noundef %34, float noundef 0xBED26B5820000000) #38
  %36 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %32, float noundef %35, float noundef 0x3F2CA65B60000000) #38
  %37 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %32, float noundef %36, float noundef 0xBF548A8100000000) #38
  %38 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %32, float noundef %37, float noundef 0xBF711C9DE0000000) #38
  %39 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %32, float noundef %38, float noundef 0x3FCF91EC60000000) #38
  %40 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %32, float noundef %39, float noundef 0x3FF805C5E0000000) #38
  br label %94

41:                                               ; preds = %25
  %42 = fneg float %29
  %43 = fcmp ogt float %29, 0xB9F0000000000000
  %44 = select i1 %43, float 0x41F0000000000000, float 1.000000e+00
  %45 = fmul float %44, %42
  %46 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %47 = icmp eq i8 %46, 0
  br i1 %47, label %48, label %63

48:                                               ; preds = %41
  %49 = tail call float @llvm.sqrt.f32(float %45), !fpmath !18
  %50 = bitcast float %49 to i32
  %51 = add nsw i32 %50, -1
  %52 = bitcast i32 %51 to float
  %53 = add nsw i32 %50, 1
  %54 = bitcast i32 %53 to float
  %55 = fneg float %52
  %56 = tail call float @llvm.fma.f32(float %55, float %49, float %45)
  %57 = fneg float %54
  %58 = tail call float @llvm.fma.f32(float %57, float %49, float %45)
  %59 = fcmp ole float %56, 0.000000e+00
  %60 = select i1 %59, float %52, float %49
  %61 = fcmp ogt float %58, 0.000000e+00
  %62 = select i1 %61, float %54, float %60
  br label %74

63:                                               ; preds = %41
  %64 = tail call spir_func float @_Z12native_rsqrtf(float noundef %45) #38
  %65 = fmul float %45, %64
  %66 = fmul float %64, 5.000000e-01
  %67 = fneg float %66
  %68 = tail call float @llvm.fma.f32(float %67, float %65, float 5.000000e-01)
  %69 = tail call float @llvm.fma.f32(float %66, float %68, float %66)
  %70 = tail call float @llvm.fma.f32(float %65, float %68, float %65)
  %71 = fneg float %70
  %72 = tail call float @llvm.fma.f32(float %71, float %70, float %45)
  %73 = tail call float @llvm.fma.f32(float %72, float %69, float %70)
  br label %74

74:                                               ; preds = %63, %48
  %75 = phi float [ %73, %63 ], [ %62, %48 ]
  %76 = select i1 %43, float 0x3EF0000000000000, float 1.000000e+00
  %77 = fmul float %76, %75
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %45, ptr %2, align 8, !tbaa !16
  %78 = addrspacecast ptr %2 to ptr addrspace(4)
  %79 = load i64, ptr addrspace(4) %78, align 8, !tbaa !12
  %80 = icmp ne i64 %79, 2139095040
  %81 = and i64 %79, 2147483647
  %82 = icmp ne i64 %81, 0
  %83 = and i1 %80, %82
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %84 = select i1 %83, float %77, float %45
  %85 = fadd float %84, -3.000000e+00
  %86 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %85, float noundef 0xBF2A3E1360000000, float noundef 0x3F1A76AD60000000) #38
  %87 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %85, float noundef %86, float noundef 0x3F561B8E40000000) #38
  %88 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %85, float noundef %87, float noundef 0xBF6E17BCE0000000) #38
  %89 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %85, float noundef %88, float noundef 0x3F77824F60000000) #38
  %90 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %85, float noundef %89, float noundef 0xBF7F38BAE0000000) #38
  %91 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %85, float noundef %90, float noundef 0x3F8354AFC0000000) #38
  %92 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %85, float noundef %91, float noundef 0x3FF006DB60000000) #38
  %93 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %85, float noundef %92, float noundef 0x4006A9EFC0000000) #38
  br label %94

94:                                               ; preds = %31, %74, %5
  %95 = phi float [ %12, %5 ], [ %40, %31 ], [ %93, %74 ]
  %96 = fmul float %3, %95
  %97 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %98 = icmp eq i8 %97, 0
  %99 = fcmp ogt float %3, 1.000000e+00
  %100 = select i1 %99, float 0x7FF8000000000000, float %96
  %101 = fcmp oeq float %3, 1.000000e+00
  %102 = select i1 %101, float 0x7FF0000000000000, float %100
  %103 = select i1 %98, float %102, float %96
  %104 = tail call float @llvm.copysign.f32(float %103, float %0)
  ret float %104
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_erfcinv_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_erfcinv_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_erfcinv_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_erfcinv_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_erfcinv_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_erfcx_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fcmp olt double %2, 0x403B39DC41E48BFC
  br i1 %3, label %4, label %58

4:                                                ; preds = %1
  %5 = fadd double %2, -4.000000e+00
  %6 = fadd double %2, 4.000000e+00
  %7 = fptrunc double %6 to float
  %8 = tail call spir_func float @_Z12native_recipf(float noundef %7) #38
  %9 = fpext float %8 to double
  %10 = fneg double %6
  %11 = tail call double @llvm.fma.f64(double %10, double %9, double 1.000000e+00)
  %12 = tail call double @llvm.fma.f64(double %11, double %9, double %9)
  %13 = tail call double @llvm.fma.f64(double %10, double %12, double 1.000000e+00)
  %14 = tail call double @llvm.fma.f64(double %13, double %12, double %12)
  %15 = fmul double %5, %14
  %16 = fneg double %15
  %17 = fadd double %15, 1.000000e+00
  %18 = tail call double @llvm.fma.f64(double %17, double -4.000000e+00, double %2)
  %19 = tail call double @llvm.fma.f64(double %16, double %2, double %18)
  %20 = tail call double @llvm.fma.f64(double %14, double %19, double %15)
  %21 = tail call double @llvm.fma.f64(double %20, double 0xBE41F39D54DF3C0E, double 0xBE41166337CFA789)
  %22 = tail call double @llvm.fma.f64(double %20, double %21, double 0x3E7B45F1D9802B82)
  %23 = tail call double @llvm.fma.f64(double %20, double %22, double 0x3E6D90488A03DCDB)
  %24 = tail call double @llvm.fma.f64(double %20, double %23, double 0xBEAB87B02EBA62D8)
  %25 = tail call double @llvm.fma.f64(double %20, double %24, double 0x3E95104BA56E15F1)
  %26 = tail call double @llvm.fma.f64(double %20, double %25, double 0x3ED7F29F71C907DE)
  %27 = tail call double @llvm.fma.f64(double %20, double %26, double 0xBEE78F5C2CD770FB)
  %28 = tail call double @llvm.fma.f64(double %20, double %27, double 0xBEF995FB76D0A51A)
  %29 = tail call double @llvm.fma.f64(double %20, double %28, double 0x3F23BE2EC022D0ED)
  %30 = tail call double @llvm.fma.f64(double %20, double %29, double 0xBF2A1DEB2FDBF62E)
  %31 = tail call double @llvm.fma.f64(double %20, double %30, double 0xBF48D4AC3689FC43)
  %32 = tail call double @llvm.fma.f64(double %20, double %31, double 0x3F749C67192D909B)
  %33 = tail call double @llvm.fma.f64(double %20, double %32, double 0xBF909623852FF070)
  %34 = tail call double @llvm.fma.f64(double %20, double %33, double 0x3FA3079EDFADEA8F)
  %35 = tail call double @llvm.fma.f64(double %20, double %34, double 0xBFB0FB06DFF65910)
  %36 = tail call double @llvm.fma.f64(double %20, double %35, double 0x3FB7FEE004DE8F32)
  %37 = tail call double @llvm.fma.f64(double %20, double %36, double 0xBFB9DDB23C3DBEB3)
  %38 = tail call double @llvm.fma.f64(double %20, double %37, double 0x3FB16ECEFCFA6930)
  %39 = tail call double @llvm.fma.f64(double %20, double %38, double 0x3F8F7F5DF66FB8A3)
  %40 = tail call double @llvm.fma.f64(double %20, double %39, double 0xBFC1DF1AD154A2A8)
  %41 = tail call double @llvm.fma.f64(double %20, double %40, double 0x3FCDD2C8B74FEBF8)
  %42 = fadd double %2, %2
  %43 = fadd double %42, 1.000000e+00
  %44 = fptrunc double %43 to float
  %45 = tail call spir_func float @_Z12native_recipf(float noundef %44) #38
  %46 = fpext float %45 to double
  %47 = fneg double %43
  %48 = tail call double @llvm.fma.f64(double %47, double %46, double 1.000000e+00)
  %49 = tail call double @llvm.fma.f64(double %48, double %46, double %46)
  %50 = tail call double @llvm.fma.f64(double %47, double %49, double 1.000000e+00)
  %51 = tail call double @llvm.fma.f64(double %50, double %49, double %49)
  %52 = tail call double @llvm.fma.f64(double %41, double %51, double %51)
  %53 = fneg double %52
  %54 = tail call double @llvm.fma.f64(double %53, double %42, double 1.000000e+00)
  %55 = fsub double %41, %52
  %56 = fadd double %54, %55
  %57 = tail call double @llvm.fma.f64(double %51, double %56, double %52)
  br label %68

58:                                               ; preds = %1
  %59 = fdiv double 1.000000e+00, %2
  %60 = fmul double %59, %59
  %61 = tail call double @llvm.fma.f64(double %60, double 0xC03D880000000000, double 6.562500e+00)
  %62 = tail call double @llvm.fma.f64(double %60, double %61, double -1.875000e+00)
  %63 = tail call double @llvm.fma.f64(double %60, double %62, double 7.500000e-01)
  %64 = tail call double @llvm.fma.f64(double %60, double %63, double -5.000000e-01)
  %65 = tail call double @llvm.fma.f64(double %60, double %64, double 1.000000e+00)
  %66 = fmul double %59, 0x3FE20DD750429B6D
  %67 = fmul double %66, %65
  br label %68

68:                                               ; preds = %58, %4
  %69 = phi double [ %57, %4 ], [ %67, %58 ]
  %70 = fcmp olt double %0, 0.000000e+00
  br i1 %70, label %71, label %81

71:                                               ; preds = %68
  %72 = fmul double %0, %0
  %73 = fneg double %72
  %74 = tail call double @llvm.fma.f64(double %0, double %0, double %73)
  %75 = tail call spir_func double @__ocml_exp_f64(double noundef %72) #38
  %76 = tail call double @llvm.fma.f64(double %75, double %74, double %75)
  %77 = fneg double %69
  %78 = tail call double @llvm.fma.f64(double %76, double 2.000000e+00, double %77)
  %79 = fcmp olt double %0, 0xC03AA0F4D2E063CE
  %80 = select i1 %79, double 0x7FF0000000000000, double %78
  br label %81

81:                                               ; preds = %71, %68
  %82 = phi double [ %80, %71 ], [ %69, %68 ]
  ret double %82
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_erfcx_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = fcmp olt float %2, 0x40241BBF80000000
  br i1 %3, label %4, label %6

4:                                                ; preds = %1
  %5 = tail call spir_func float @__ocmlpriv_erfcx_f32(float noundef %2) #38
  br label %17

6:                                                ; preds = %1
  %7 = fmul float %2, 2.500000e-01
  %8 = tail call spir_func float @_Z12native_recipf(float noundef %7) #38
  %9 = fmul float %8, %8
  %10 = fmul float %9, 6.250000e-02
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef 6.562500e+00, float noundef -1.875000e+00) #38
  %12 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef %11, float noundef 7.500000e-01) #38
  %13 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef %12, float noundef -5.000000e-01) #38
  %14 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %10, float noundef %13, float noundef 1.000000e+00) #38
  %15 = fmul float %8, 0x3FC20DD760000000
  %16 = fmul float %15, %14
  br label %17

17:                                               ; preds = %6, %4
  %18 = phi float [ %5, %4 ], [ %16, %6 ]
  %19 = fcmp olt float %0, 0.000000e+00
  br i1 %19, label %20, label %30

20:                                               ; preds = %17
  %21 = fmul float %0, %0
  %22 = fneg float %21
  %23 = tail call float @llvm.fma.f32(float %0, float %0, float %22)
  %24 = tail call spir_func float @__ocml_exp_f32(float noundef %21) #38
  %25 = tail call float @llvm.fma.f32(float %24, float %23, float %24)
  %26 = fneg float %18
  %27 = tail call float @llvm.fma.f32(float %25, float 2.000000e+00, float %26)
  %28 = fcmp olt float %0, 0xC022D6ABC0000000
  %29 = select i1 %28, float 0x7FF0000000000000, float %27
  br label %30

30:                                               ; preds = %20, %17
  %31 = phi float [ %29, %20 ], [ %18, %17 ]
  ret float %31
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_erfcx_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_erfcx_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_erfcx_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_erfcx_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_erfcx_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_erfinv_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_erfinv_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_erfinv_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_erfinv_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_erfinv_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_exp10_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = fmul double %0, 0x400A934F0979A371
  %3 = tail call double @llvm.rint.f64(double %2)
  %4 = fneg double %3
  %5 = tail call double @llvm.fma.f64(double %4, double 0x3FD34413509F79FF, double %0)
  %6 = tail call double @llvm.fma.f64(double %4, double 0xBC49DC1DA994FD21, double %5)
  %7 = fmul double %6, 0xBCAF48AD494EA3E9
  %8 = tail call double @llvm.fma.f64(double %6, double 0x40026BB1BBB55516, double %7)
  %9 = tail call double @llvm.fma.f64(double %8, double 0x3E5ADE156A5DCB37, double 0x3E928AF3FCA7AB0C)
  %10 = tail call double @llvm.fma.f64(double %8, double %9, double 0x3EC71DEE623FDE64)
  %11 = tail call double @llvm.fma.f64(double %8, double %10, double 0x3EFA01997C89E6B0)
  %12 = tail call double @llvm.fma.f64(double %8, double %11, double 0x3F2A01A014761F6E)
  %13 = tail call double @llvm.fma.f64(double %8, double %12, double 0x3F56C16C1852B7B0)
  %14 = tail call double @llvm.fma.f64(double %8, double %13, double 0x3F81111111122322)
  %15 = tail call double @llvm.fma.f64(double %8, double %14, double 0x3FA55555555502A1)
  %16 = tail call double @llvm.fma.f64(double %8, double %15, double 0x3FC5555555555511)
  %17 = tail call double @llvm.fma.f64(double %8, double %16, double 0x3FE000000000000B)
  %18 = tail call double @llvm.fma.f64(double %8, double %17, double 1.000000e+00)
  %19 = tail call double @llvm.fma.f64(double %8, double %18, double 1.000000e+00)
  %20 = fptosi double %3 to i32
  %21 = tail call spir_func double @_Z5ldexpdi(double noundef %19, i32 noundef %20) #38
  %22 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %23 = icmp eq i8 %22, 0
  %24 = fcmp ogt double %0, 1.024000e+03
  %25 = and i1 %24, %23
  %26 = select i1 %25, double 0x7FF0000000000000, double %21
  %27 = fcmp olt double %0, -1.075000e+03
  %28 = select i1 %27, double 0.000000e+00, double %26
  ret double %28
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_exp10_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %3 = icmp eq i8 %2, 0
  %4 = load i8, ptr addrspace(2) @__oclc_unsafe_math_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %5 = icmp eq i8 %4, 0
  br i1 %3, label %45, label %6

6:                                                ; preds = %1
  br i1 %5, label %13, label %7

7:                                                ; preds = %6
  %8 = fmul float %0, 0x400A920000000000
  %9 = tail call float @llvm.exp2.f32(float %8)
  %10 = fmul float %0, 0x3F44F09780000000
  %11 = tail call float @llvm.exp2.f32(float %10)
  %12 = fmul float %9, %11
  br label %89

13:                                               ; preds = %6
  %14 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %15 = freeze i32 %14
  %16 = icmp sgt i32 %15, 8999
  br i1 %16, label %18, label %17

17:                                               ; preds = %13
  switch i32 %15, label %23 [
    i32 8001, label %18
    i32 7001, label %18
  ]

18:                                               ; preds = %17, %17, %13
  %19 = fmul float %0, 0x400A934F00000000
  %20 = fneg float %19
  %21 = tail call float @llvm.fma.f32(float %0, float 0x400A934F00000000, float %20)
  %22 = tail call float @llvm.fma.f32(float %0, float 0x3E72F346E0000000, float %21)
  br label %32

23:                                               ; preds = %17
  %24 = bitcast float %0 to i32
  %25 = and i32 %24, -4096
  %26 = bitcast i32 %25 to float
  %27 = fsub float %0, %26
  %28 = fmul float %26, 0x400A920000000000
  %29 = fmul float %27, 0x3F44F09780000000
  %30 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %27, float noundef 0x400A920000000000, float noundef %29) #38
  %31 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %26, float noundef 0x3F44F09780000000, float noundef %30) #38
  br label %32

32:                                               ; preds = %23, %18
  %33 = phi float [ %22, %18 ], [ %31, %23 ]
  %34 = phi float [ %19, %18 ], [ %28, %23 ]
  %35 = tail call float @llvm.rint.f32(float %34)
  %36 = fsub float %34, %35
  %37 = fadd float %33, %36
  %38 = tail call float @llvm.exp2.f32(float %37)
  %39 = fptosi float %35 to i32
  %40 = tail call spir_func float @_Z5ldexpfi(float noundef %38, i32 noundef %39) #38
  %41 = fcmp olt float %0, 0xC042F70300000000
  %42 = select i1 %41, float 0.000000e+00, float %40
  %43 = fcmp ogt float %0, 0x4043441360000000
  %44 = select i1 %43, float 0x7FF0000000000000, float %42
  br label %89

45:                                               ; preds = %1
  br i1 %5, label %57, label %46

46:                                               ; preds = %45
  %47 = fcmp olt float %0, 0xC042F70300000000
  %48 = select i1 %47, float 3.200000e+01, float 0.000000e+00
  %49 = fadd float %48, %0
  %50 = fmul float %49, 0x400A920000000000
  %51 = tail call float @llvm.exp2.f32(float %50)
  %52 = fmul float %49, 0x3F44F09780000000
  %53 = tail call float @llvm.exp2.f32(float %52)
  %54 = fmul float %51, %53
  %55 = select i1 %47, float 0x3949F623E0000000, float 1.000000e+00
  %56 = fmul float %55, %54
  br label %89

57:                                               ; preds = %45
  %58 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %59 = freeze i32 %58
  %60 = icmp sgt i32 %59, 8999
  br i1 %60, label %62, label %61

61:                                               ; preds = %57
  switch i32 %59, label %67 [
    i32 8001, label %62
    i32 7001, label %62
  ]

62:                                               ; preds = %61, %61, %57
  %63 = fmul float %0, 0x400A934F00000000
  %64 = fneg float %63
  %65 = tail call float @llvm.fma.f32(float %0, float 0x400A934F00000000, float %64)
  %66 = tail call float @llvm.fma.f32(float %0, float 0x3E72F346E0000000, float %65)
  br label %76

67:                                               ; preds = %61
  %68 = bitcast float %0 to i32
  %69 = and i32 %68, -4096
  %70 = bitcast i32 %69 to float
  %71 = fsub float %0, %70
  %72 = fmul float %70, 0x400A920000000000
  %73 = fmul float %71, 0x3F44F09780000000
  %74 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %71, float noundef 0x400A920000000000, float noundef %73) #38
  %75 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %70, float noundef 0x3F44F09780000000, float noundef %74) #38
  br label %76

76:                                               ; preds = %67, %62
  %77 = phi float [ %66, %62 ], [ %75, %67 ]
  %78 = phi float [ %63, %62 ], [ %72, %67 ]
  %79 = tail call float @llvm.rint.f32(float %78)
  %80 = fsub float %78, %79
  %81 = fadd float %77, %80
  %82 = tail call float @llvm.exp2.f32(float %81)
  %83 = fptosi float %79 to i32
  %84 = tail call spir_func float @_Z5ldexpfi(float noundef %82, i32 noundef %83) #38
  %85 = fcmp olt float %0, 0xC0466D3E80000000
  %86 = select i1 %85, float 0.000000e+00, float %84
  %87 = fcmp ogt float %0, 0x4043441360000000
  %88 = select i1 %87, float 0x7FF0000000000000, float %86
  br label %89

89:                                               ; preds = %76, %46, %32, %7
  %90 = phi float [ %12, %7 ], [ %44, %32 ], [ %56, %46 ], [ %88, %76 ]
  ret float %90
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_exp10_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = fmul float %3, 0x400A934F00000000
  %5 = tail call float @llvm.exp2.f32(float %4)
  %6 = fptrunc float %5 to half
  %7 = insertelement <2 x half> poison, half %6, i64 0
  %8 = extractelement <2 x half> %0, i64 1
  %9 = fpext half %8 to float
  %10 = fmul float %9, 0x400A934F00000000
  %11 = tail call float @llvm.exp2.f32(float %10)
  %12 = fptrunc float %11 to half
  %13 = insertelement <2 x half> %7, half %12, i64 1
  ret <2 x half> %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_exp10_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = fpext half %0 to float
  %3 = fmul float %2, 0x400A934F00000000
  %4 = tail call float @llvm.exp2.f32(float %3)
  %5 = fptrunc float %4 to half
  ret half %5
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_exp2_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.rint.f64(double %0)
  %3 = fsub double %0, %2
  %4 = fmul double %3, 0x3C7ABC9E3B39803F
  %5 = tail call double @llvm.fma.f64(double %3, double 0x3FE62E42FEFA39EF, double %4)
  %6 = tail call double @llvm.fma.f64(double %5, double 0x3E5ADE156A5DCB37, double 0x3E928AF3FCA7AB0C)
  %7 = tail call double @llvm.fma.f64(double %5, double %6, double 0x3EC71DEE623FDE64)
  %8 = tail call double @llvm.fma.f64(double %5, double %7, double 0x3EFA01997C89E6B0)
  %9 = tail call double @llvm.fma.f64(double %5, double %8, double 0x3F2A01A014761F6E)
  %10 = tail call double @llvm.fma.f64(double %5, double %9, double 0x3F56C16C1852B7B0)
  %11 = tail call double @llvm.fma.f64(double %5, double %10, double 0x3F81111111122322)
  %12 = tail call double @llvm.fma.f64(double %5, double %11, double 0x3FA55555555502A1)
  %13 = tail call double @llvm.fma.f64(double %5, double %12, double 0x3FC5555555555511)
  %14 = tail call double @llvm.fma.f64(double %5, double %13, double 0x3FE000000000000B)
  %15 = tail call double @llvm.fma.f64(double %5, double %14, double 1.000000e+00)
  %16 = tail call double @llvm.fma.f64(double %5, double %15, double 1.000000e+00)
  %17 = fptosi double %2 to i32
  %18 = tail call spir_func double @_Z5ldexpdi(double noundef %16, i32 noundef %17) #38
  %19 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %20 = icmp eq i8 %19, 0
  %21 = fcmp ogt double %0, 1.024000e+03
  %22 = and i1 %21, %20
  %23 = select i1 %22, double 0x7FF0000000000000, double %18
  %24 = fcmp olt double %0, -1.075000e+03
  %25 = select i1 %24, double 0.000000e+00, double %23
  ret double %25
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func float @__ocml_exp2_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %3 = icmp eq i8 %2, 0
  br i1 %3, label %6, label %4

4:                                                ; preds = %1
  %5 = tail call float @llvm.exp2.f32(float %0)
  br label %13

6:                                                ; preds = %1
  %7 = fcmp olt float %0, -1.260000e+02
  %8 = select i1 %7, float 6.400000e+01, float 0.000000e+00
  %9 = fadd float %8, %0
  %10 = tail call float @llvm.exp2.f32(float %9)
  %11 = select i1 %7, float 0x3BF0000000000000, float 1.000000e+00
  %12 = fmul float %11, %10
  br label %13

13:                                               ; preds = %6, %4
  %14 = phi float [ %5, %4 ], [ %12, %6 ]
  ret float %14
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_exp2_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call noundef half @llvm.exp2.f16(half %2)
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call noundef half @llvm.exp2.f16(half %5)
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.exp2.f16(half) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_exp2_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.exp2.f16(half %0)
  ret half %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_exp_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = fmul float %3, 0x3FF7154760000000
  %5 = tail call float @llvm.exp2.f32(float %4)
  %6 = fptrunc float %5 to half
  %7 = insertelement <2 x half> poison, half %6, i64 0
  %8 = extractelement <2 x half> %0, i64 1
  %9 = fpext half %8 to float
  %10 = fmul float %9, 0x3FF7154760000000
  %11 = tail call float @llvm.exp2.f32(float %10)
  %12 = fptrunc float %11 to half
  %13 = insertelement <2 x half> %7, half %12, i64 1
  ret <2 x half> %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_exp_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = fpext half %0 to float
  %3 = fmul float %2, 0x3FF7154760000000
  %4 = tail call float @llvm.exp2.f32(float %3)
  %5 = fptrunc float %4 to half
  ret half %5
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_expep_f64(<2 x double> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x double> %0, i64 1
  %3 = tail call spir_func double @__ocml_exp_f64(double noundef %2) #38
  %4 = extractelement <2 x double> %0, i64 0
  %5 = tail call double @llvm.fma.f64(double %3, double %4, double %3)
  %6 = tail call double @llvm.fabs.f64(double %3)
  %7 = fcmp oeq double %6, 0x7FF0000000000000
  %8 = select i1 %7, double %3, double %5
  ret double %8
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_expep_f32(<2 x float> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x float> %0, i64 1
  %3 = fcmp oeq float %2, 0x40562E4300000000
  %4 = select i1 %3, float 0x3EE0000000000000, float 0.000000e+00
  %5 = fsub float %2, %4
  %6 = extractelement <2 x float> %0, i64 0
  %7 = fadd float %6, %4
  %8 = tail call spir_func float @__ocml_exp_f32(float noundef %5) #38
  %9 = tail call float @llvm.fma.f32(float %8, float %7, float %8)
  %10 = tail call float @llvm.fabs.f32(float %8)
  %11 = fcmp oeq float %10, 0x7FF0000000000000
  %12 = select i1 %11, float %8, float %9
  ret float %12
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_expm1_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = fmul double %0, 0x3FF71547652B82FE
  %3 = tail call double @llvm.rint.f64(double %2)
  %4 = fneg double %3
  %5 = tail call double @llvm.fma.f64(double %4, double 0x3FE62E42FEFA39EF, double %0)
  %6 = tail call double @llvm.fma.f64(double %4, double 0x3C7ABC9E3B39803F, double %5)
  %7 = tail call double @llvm.fma.f64(double %6, double 0x3E21F32EA9D67F34, double 0x3E5AF4EB2A1B768B)
  %8 = tail call double @llvm.fma.f64(double %6, double %7, double 0x3E927E500E0AC05B)
  %9 = tail call double @llvm.fma.f64(double %6, double %8, double 0x3EC71DE01B889C29)
  %10 = tail call double @llvm.fma.f64(double %6, double %9, double 0x3EFA01A0197BCFD8)
  %11 = tail call double @llvm.fma.f64(double %6, double %10, double 0x3F2A01A01AC1A723)
  %12 = tail call double @llvm.fma.f64(double %6, double %11, double 0x3F56C16C16C18931)
  %13 = tail call double @llvm.fma.f64(double %6, double %12, double 0x3F81111111110056)
  %14 = tail call double @llvm.fma.f64(double %6, double %13, double 0x3FA5555555555552)
  %15 = tail call double @llvm.fma.f64(double %6, double %14, double 0x3FC5555555555557)
  %16 = tail call double @llvm.fma.f64(double %6, double %15, double 5.000000e-01)
  %17 = fmul double %6, %16
  %18 = tail call double @llvm.fma.f64(double %6, double %17, double %6)
  %19 = fcmp oeq double %3, 1.024000e+03
  %20 = fptosi double %3 to i32
  %21 = select i1 %19, i32 1023, i32 %20
  %22 = tail call spir_func double @_Z5ldexpdi(double noundef 1.000000e+00, i32 noundef %21) #38
  %23 = fadd double %22, -1.000000e+00
  %24 = tail call double @llvm.fma.f64(double %22, double %18, double %23)
  %25 = fmul double %24, 2.000000e+00
  %26 = select i1 %19, double %25, double %24
  %27 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %28 = icmp eq i8 %27, 0
  %29 = fcmp ogt double %0, 0x40862E42FEFA39EF
  %30 = and i1 %29, %28
  %31 = select i1 %30, double 0x7FF0000000000000, double %26
  %32 = fcmp olt double %0, -3.700000e+01
  %33 = select i1 %32, double -1.000000e+00, double %31
  ret double %33
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_expm1_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = fmul float %0, 0x3FF7154760000000
  %3 = tail call float @llvm.rint.f32(float %2)
  %4 = fneg float %3
  %5 = tail call float @llvm.fma.f32(float %4, float 0x3FE62E4300000000, float %0)
  %6 = tail call float @llvm.fma.f32(float %4, float 0xBE205C6100000000, float %5)
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef 0x3F2A267620000000, float noundef 0x3F56D2E000000000) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %7, float noundef 0x3F8110FF20000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %8, float noundef 0x3FA5555020000000) #38
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %9, float noundef 0x3FC5555560000000) #38
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %10, float noundef 5.000000e-01) #38
  %12 = fmul float %6, %11
  %13 = tail call float @llvm.fma.f32(float %6, float %12, float %6)
  %14 = fcmp oeq float %3, 1.280000e+02
  %15 = fptosi float %3 to i32
  %16 = select i1 %14, i32 127, i32 %15
  %17 = tail call spir_func float @_Z5ldexpfi(float noundef 1.000000e+00, i32 noundef %16) #38
  %18 = fadd float %17, -1.000000e+00
  %19 = tail call float @llvm.fma.f32(float %17, float %13, float %18)
  %20 = fmul float %19, 2.000000e+00
  %21 = select i1 %14, float %20, float %19
  %22 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %23 = icmp eq i8 %22, 0
  %24 = fcmp ogt float %0, 0x40562E42E0000000
  %25 = and i1 %24, %23
  %26 = select i1 %25, float 0x7FF0000000000000, float %21
  %27 = fcmp olt float %0, -1.700000e+01
  %28 = select i1 %27, float -1.000000e+00, float %26
  ret float %28
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_expm1_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = fmul float %3, 0x3FF7154760000000
  %5 = tail call float @llvm.exp2.f32(float %4)
  %6 = fadd float %5, -1.000000e+00
  %7 = fptrunc float %6 to half
  %8 = tail call half @llvm.fma.f16(half %2, half 0xH3155, half 0xH3800)
  %9 = fmul half %2, %8
  %10 = tail call half @llvm.fma.f16(half %2, half %9, half %2)
  %11 = tail call half @llvm.fabs.f16(half %2)
  %12 = fcmp olt half %11, 0xH2400
  %13 = select i1 %12, half %10, half %7
  %14 = insertelement <2 x half> poison, half %13, i64 0
  %15 = extractelement <2 x half> %0, i64 1
  %16 = fpext half %15 to float
  %17 = fmul float %16, 0x3FF7154760000000
  %18 = tail call float @llvm.exp2.f32(float %17)
  %19 = fadd float %18, -1.000000e+00
  %20 = fptrunc float %19 to half
  %21 = tail call half @llvm.fma.f16(half %15, half 0xH3155, half 0xH3800)
  %22 = fmul half %15, %21
  %23 = tail call half @llvm.fma.f16(half %15, half %22, half %15)
  %24 = tail call half @llvm.fabs.f16(half %15)
  %25 = fcmp olt half %24, 0xH2400
  %26 = select i1 %25, half %23, half %20
  %27 = insertelement <2 x half> %14, half %26, i64 1
  ret <2 x half> %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_expm1_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = fpext half %0 to float
  %3 = fmul float %2, 0x3FF7154760000000
  %4 = tail call float @llvm.exp2.f32(float %3)
  %5 = fadd float %4, -1.000000e+00
  %6 = fptrunc float %5 to half
  %7 = tail call half @llvm.fma.f16(half %0, half 0xH3155, half 0xH3800)
  %8 = fmul half %7, %0
  %9 = tail call half @llvm.fma.f16(half %0, half %8, half %0)
  %10 = tail call half @llvm.fabs.f16(half %0)
  %11 = fcmp olt half %10, 0xH2400
  %12 = select i1 %11, half %9, half %6
  ret half %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_fabs_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  ret double %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_fabs_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  ret float %2
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_fabs_2f16(<2 x half> noundef %0) local_unnamed_addr #31 {
  %2 = tail call spir_func <2 x half> @llvm.fabs.v2f16(<2 x half> noundef %0) #38
  ret <2 x half> %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x half> @llvm.fabs.v2f16(<2 x half>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_fabs_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  ret half %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_fdim_f64(double noundef %0, double noundef %1) local_unnamed_addr #23 {
  %3 = fcmp ugt double %0, %1
  %4 = fsub double %0, %1
  %5 = select i1 %3, double %4, double 0.000000e+00
  ret double %5
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_fdim_f32(float noundef %0, float noundef %1) local_unnamed_addr #23 {
  %3 = fcmp ugt float %0, %1
  %4 = fsub float %0, %1
  %5 = select i1 %3, float %4, float 0.000000e+00
  ret float %5
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_fdim_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #23 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = fcmp ugt half %3, %4
  %6 = fsub half %3, %4
  %7 = select i1 %5, half %6, half 0xH0000
  %8 = insertelement <2 x half> poison, half %7, i64 0
  %9 = extractelement <2 x half> %0, i64 1
  %10 = extractelement <2 x half> %1, i64 1
  %11 = fcmp ugt half %9, %10
  %12 = fsub half %9, %10
  %13 = select i1 %11, half %12, half 0xH0000
  %14 = insertelement <2 x half> %8, half %13, i64 1
  ret <2 x half> %14
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_fdim_f16(half noundef %0, half noundef %1) local_unnamed_addr #23 {
  %3 = fcmp ugt half %0, %1
  %4 = fsub half %0, %1
  %5 = select i1 %3, half %4, half 0xH0000
  ret half %5
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_floor_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.floor.f64(double %0)
  ret double %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.floor.f64(double) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_floor_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.floor.f32(float %0)
  ret float %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.floor.f32(float) #2

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_floor_2f16(<2 x half> noundef %0) local_unnamed_addr #31 {
  %2 = tail call spir_func <2 x half> @llvm.floor.v2f16(<2 x half> noundef %0) #38
  ret <2 x half> %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x half> @llvm.floor.v2f16(<2 x half>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_floor_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.floor.f16(half %0)
  ret half %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.floor.f16(half) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_fma_f64(double noundef %0, double noundef %1, double noundef %2) local_unnamed_addr #23 {
  %4 = tail call double @llvm.fma.f64(double %0, double %1, double %2)
  ret double %4
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x float> @__ocml_fma_2f32(<2 x float> noundef %0, <2 x float> noundef %1, <2 x float> noundef %2) local_unnamed_addr #31 {
  %4 = tail call spir_func <2 x float> @llvm.fma.v2f32(<2 x float> noundef %0, <2 x float> noundef %1, <2 x float> noundef %2) #38
  ret <2 x float> %4
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x float> @llvm.fma.v2f32(<2 x float>, <2 x float>, <2 x float>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_fma_f32(float noundef %0, float noundef %1, float noundef %2) local_unnamed_addr #23 {
  %4 = tail call float @llvm.fma.f32(float %0, float %1, float %2)
  ret float %4
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_fma_2f16(<2 x half> noundef %0, <2 x half> noundef %1, <2 x half> noundef %2) local_unnamed_addr #31 {
  %4 = tail call spir_func <2 x half> @llvm.fma.v2f16(<2 x half> noundef %0, <2 x half> noundef %1, <2 x half> noundef %2) #38
  ret <2 x half> %4
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x half> @llvm.fma.v2f16(<2 x half>, <2 x half>, <2 x half>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_fma_f16(half noundef %0, half noundef %1, half noundef %2) local_unnamed_addr #23 {
  %4 = tail call half @llvm.fma.f16(half %0, half %1, half %2)
  ret half %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_fmax_f64(double noundef %0, double noundef %1) local_unnamed_addr #23 {
  %3 = tail call double @llvm.maxnum.f64(double %0, double %1)
  ret double %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_fmax_f32(float noundef %0, float noundef %1) local_unnamed_addr #23 {
  %3 = tail call float @llvm.maxnum.f32(float %0, float %1)
  ret float %3
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_fmax_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #31 {
  %3 = tail call spir_func <2 x half> @llvm.maxnum.v2f16(<2 x half> noundef %0, <2 x half> noundef %1) #38
  ret <2 x half> %3
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x half> @llvm.maxnum.v2f16(<2 x half>, <2 x half>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_fmax_f16(half noundef %0, half noundef %1) local_unnamed_addr #23 {
  %3 = tail call half @llvm.maxnum.f16(half %0, half %1)
  ret half %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_fmin_f64(double noundef %0, double noundef %1) local_unnamed_addr #23 {
  %3 = tail call double @llvm.minnum.f64(double %0, double %1)
  ret double %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_fmin_f32(float noundef %0, float noundef %1) local_unnamed_addr #23 {
  %3 = tail call float @llvm.minnum.f32(float %0, float %1)
  ret float %3
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_fmin_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #31 {
  %3 = tail call spir_func <2 x half> @llvm.minnum.v2f16(<2 x half> noundef %0, <2 x half> noundef %1) #38
  ret <2 x half> %3
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x half> @llvm.minnum.v2f16(<2 x half>, <2 x half>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_fmin_f16(half noundef %0, half noundef %1) local_unnamed_addr #23 {
  %3 = tail call half @llvm.minnum.f16(half %0, half %1)
  ret half %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_fmod_f64(double noundef %0, double noundef %1) local_unnamed_addr #21 {
  %3 = alloca double, align 8
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = tail call double @llvm.fabs.f64(double %0)
  %7 = tail call double @llvm.fabs.f64(double %1)
  %8 = fcmp ogt double %6, %7
  br i1 %8, label %9, label %55

9:                                                ; preds = %2
  %10 = fptrunc double %6 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %11 = addrspacecast ptr %5 to ptr addrspace(4)
  %12 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %10, ptr addrspace(4) noundef %11) #40
  %13 = load i32, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %14 = call spir_func double @_Z5ldexpdi(double noundef %6, i32 noundef 26) #38
  %15 = fptrunc double %7 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %16 = addrspacecast ptr %4 to ptr addrspace(4)
  %17 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %15, ptr addrspace(4) noundef %16) #40
  %18 = load i32, ptr %4, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  %19 = add nsw i32 %18, -1
  %20 = call spir_func double @_Z5ldexpdi(double noundef %7, i32 noundef 1) #38
  %21 = sub i32 %13, %18
  %22 = fdiv double 1.000000e+00, %20
  %23 = icmp sgt i32 %21, 26
  br i1 %23, label %24, label %37

24:                                               ; preds = %9, %24
  %25 = phi double [ %34, %24 ], [ %14, %9 ]
  %26 = phi i32 [ %35, %24 ], [ %21, %9 ]
  %27 = fmul double %22, %25
  %28 = call double @llvm.rint.f64(double %27)
  %29 = fneg double %28
  %30 = call double @llvm.fma.f64(double %29, double %20, double %25)
  %31 = fcmp olt double %30, 0.000000e+00
  %32 = select i1 %31, double %20, double -0.000000e+00
  %33 = fadd double %30, %32
  %34 = call spir_func double @_Z5ldexpdi(double noundef %33, i32 noundef 26) #38
  %35 = add nsw i32 %26, -26
  %36 = icmp ugt i32 %26, 52
  br i1 %36, label %24, label %37

37:                                               ; preds = %24, %9
  %38 = phi i32 [ %21, %9 ], [ %35, %24 ]
  %39 = phi double [ %14, %9 ], [ %34, %24 ]
  %40 = add nsw i32 %38, -25
  %41 = call spir_func double @_Z5ldexpdi(double noundef %39, i32 noundef %40) #38
  %42 = fmul double %22, %41
  %43 = call double @llvm.rint.f64(double %42)
  %44 = fneg double %43
  %45 = call double @llvm.fma.f64(double %44, double %20, double %41)
  %46 = fcmp olt double %45, 0.000000e+00
  %47 = select i1 %46, double %20, double -0.000000e+00
  %48 = fadd double %45, %47
  %49 = call spir_func double @_Z5ldexpdi(double noundef %48, i32 noundef %19) #38
  %50 = bitcast double %0 to i64
  %51 = and i64 %50, -9223372036854775808
  %52 = bitcast double %49 to i64
  %53 = xor i64 %51, %52
  %54 = bitcast i64 %53 to double
  br label %59

55:                                               ; preds = %2
  %56 = fcmp oeq double %6, %7
  %57 = tail call double @llvm.copysign.f64(double 0.000000e+00, double %0)
  %58 = select i1 %56, double %57, double %0
  br label %59

59:                                               ; preds = %55, %37
  %60 = phi double [ %54, %37 ], [ %58, %55 ]
  %61 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %62 = icmp eq i8 %61, 0
  br i1 %62, label %63, label %81

63:                                               ; preds = %59
  %64 = fcmp uno double %1, 0.000000e+00
  br i1 %64, label %81, label %65

65:                                               ; preds = %63
  %66 = fcmp oeq double %1, 0.000000e+00
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %0, ptr %3, align 8, !tbaa !19
  %67 = addrspacecast ptr %3 to ptr addrspace(4)
  %68 = load i128, ptr addrspace(4) %67, align 8, !tbaa !29
  %69 = and i128 %68, 9223372036854775807
  %70 = icmp eq i128 %69, 0
  br i1 %70, label %77, label %71

71:                                               ; preds = %65
  %72 = and i128 %68, 9218868437227405312
  %73 = icmp ne i128 %72, 0
  %74 = and i128 %68, 4503599627370495
  %75 = icmp eq i128 %74, 0
  %76 = or i1 %73, %75
  br label %77

77:                                               ; preds = %65, %71
  %78 = phi i1 [ false, %65 ], [ %76, %71 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  %79 = or i1 %66, %78
  %80 = select i1 %79, double 0x7FF8000000000000, double %60
  br label %81

81:                                               ; preds = %63, %77, %59
  %82 = phi double [ %60, %59 ], [ 0x7FF8000000000000, %63 ], [ %80, %77 ]
  ret double %82
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_fmod_f32(float noundef %0, float noundef %1) local_unnamed_addr #21 {
  %3 = alloca float, align 8
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %7 = icmp eq i8 %6, 0
  %8 = select i1 %7, float %1, float 0.000000e+00
  %9 = select i1 %7, float %0, float 0.000000e+00
  %10 = tail call float @llvm.fabs.f32(float %9)
  %11 = tail call float @llvm.fabs.f32(float %8)
  %12 = fcmp ogt float %10, %11
  br i1 %12, label %13, label %55

13:                                               ; preds = %2
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %14 = addrspacecast ptr %5 to ptr addrspace(4)
  %15 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %10, ptr addrspace(4) noundef %14) #40
  %16 = load i32, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %17 = call spir_func float @_Z5ldexpfi(float noundef %10, i32 noundef 12) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %18 = addrspacecast ptr %4 to ptr addrspace(4)
  %19 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %11, ptr addrspace(4) noundef %18) #40
  %20 = load i32, ptr %4, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  %21 = add nsw i32 %20, -1
  %22 = call spir_func float @_Z5ldexpfi(float noundef %11, i32 noundef 1) #38
  %23 = sub i32 %16, %20
  %24 = call spir_func float @_Z12native_recipf(float noundef %22) #38
  %25 = icmp sgt i32 %23, 12
  br i1 %25, label %26, label %38

26:                                               ; preds = %13, %26
  %27 = phi float [ %35, %26 ], [ %17, %13 ]
  %28 = phi i32 [ %36, %26 ], [ %23, %13 ]
  %29 = fmul float %24, %27
  %30 = call float @llvm.rint.f32(float %29)
  %31 = call spir_func float @fnma(float noundef %30, float noundef %22, float noundef %27) #38
  %32 = fcmp olt float %31, 0.000000e+00
  %33 = select i1 %32, float %22, float -0.000000e+00
  %34 = fadd float %31, %33
  %35 = call spir_func float @_Z5ldexpfi(float noundef %34, i32 noundef 12) #38
  %36 = add nsw i32 %28, -12
  %37 = icmp ugt i32 %28, 24
  br i1 %37, label %26, label %38

38:                                               ; preds = %26, %13
  %39 = phi i32 [ %23, %13 ], [ %36, %26 ]
  %40 = phi float [ %17, %13 ], [ %35, %26 ]
  %41 = add nsw i32 %39, -11
  %42 = call spir_func float @_Z5ldexpfi(float noundef %40, i32 noundef %41) #38
  %43 = fmul float %24, %42
  %44 = call float @llvm.rint.f32(float %43)
  %45 = call spir_func float @fnma(float noundef %44, float noundef %22, float noundef %42) #38
  %46 = fcmp olt float %45, 0.000000e+00
  %47 = select i1 %46, float %22, float -0.000000e+00
  %48 = fadd float %45, %47
  %49 = call spir_func float @_Z5ldexpfi(float noundef %48, i32 noundef %21) #38
  %50 = bitcast float %9 to i32
  %51 = and i32 %50, -2147483648
  %52 = bitcast float %49 to i32
  %53 = xor i32 %51, %52
  %54 = bitcast i32 %53 to float
  br label %59

55:                                               ; preds = %2
  %56 = fcmp oeq float %10, %11
  %57 = tail call float @llvm.copysign.f32(float 0.000000e+00, float %9)
  %58 = select i1 %56, float %57, float %9
  br label %59

59:                                               ; preds = %55, %38
  %60 = phi float [ %54, %38 ], [ %58, %55 ]
  %61 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %62 = icmp eq i8 %61, 0
  br i1 %62, label %63, label %81

63:                                               ; preds = %59
  %64 = fcmp uno float %8, 0.000000e+00
  br i1 %64, label %81, label %65

65:                                               ; preds = %63
  %66 = fcmp oeq float %8, 0.000000e+00
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %9, ptr %3, align 8, !tbaa !16
  %67 = addrspacecast ptr %3 to ptr addrspace(4)
  %68 = load i64, ptr addrspace(4) %67, align 8, !tbaa !12
  %69 = and i64 %68, 2147483647
  %70 = icmp eq i64 %69, 0
  br i1 %70, label %77, label %71

71:                                               ; preds = %65
  %72 = and i64 %68, 2139095040
  %73 = icmp ne i64 %72, 0
  %74 = and i64 %68, 8388607
  %75 = icmp eq i64 %74, 0
  %76 = or i1 %73, %75
  br label %77

77:                                               ; preds = %65, %71
  %78 = phi i1 [ false, %65 ], [ %76, %71 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %79 = or i1 %66, %78
  %80 = select i1 %79, float 0x7FF8000000000000, float %60
  br label %81

81:                                               ; preds = %63, %77, %59
  %82 = phi float [ %60, %59 ], [ 0x7FF8000000000000, %63 ], [ %80, %77 ]
  ret float %82
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define internal spir_func float @fnma(float noundef %0, float noundef %1, float noundef %2) unnamed_addr #21 {
  %4 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %5 = freeze i32 %4
  %6 = icmp sgt i32 %5, 8999
  br i1 %6, label %8, label %7

7:                                                ; preds = %3
  switch i32 %5, label %11 [
    i32 8001, label %8
    i32 7001, label %8
  ]

8:                                                ; preds = %7, %7, %3
  %9 = fneg float %0
  %10 = tail call float @llvm.fma.f32(float %9, float %1, float %2)
  br label %31

11:                                               ; preds = %7
  %12 = bitcast float %0 to i32
  %13 = and i32 %12, -4096
  %14 = bitcast i32 %13 to float
  %15 = fsub float %0, %14
  %16 = bitcast float %1 to i32
  %17 = and i32 %16, -4096
  %18 = bitcast i32 %17 to float
  %19 = fsub float %1, %18
  %20 = fmul float %0, %1
  %21 = fneg float %20
  %22 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %18, float noundef %21) #38
  %23 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %19, float noundef %22) #38
  %24 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %15, float noundef %18, float noundef %23) #38
  %25 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %15, float noundef %19, float noundef %24) #38
  %26 = fsub float %2, %20
  %27 = fsub float %2, %26
  %28 = fsub float %27, %20
  %29 = fsub float %28, %25
  %30 = fadd float %26, %29
  br label %31

31:                                               ; preds = %11, %8
  %32 = phi float [ %10, %8 ], [ %30, %11 ]
  ret float %32
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_fmod_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #21 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = tail call spir_func half @__ocml_fmod_f16(half noundef %3, half noundef %4) #38
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = extractelement <2 x half> %1, i64 1
  %9 = tail call spir_func half @__ocml_fmod_f16(half noundef %7, half noundef %8) #38
  %10 = insertelement <2 x half> %6, half %9, i64 1
  ret <2 x half> %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_fmod_f16(half noundef %0, half noundef %1) local_unnamed_addr #24 {
  %3 = tail call half @llvm.fabs.f16(half %0)
  %4 = tail call half @llvm.fabs.f16(half %1)
  %5 = fcmp ogt half %3, %4
  br i1 %5, label %6, label %49

6:                                                ; preds = %2
  %7 = fpext half %4 to float
  %8 = fpext half %3 to float
  %9 = tail call spir_func i32 @frexp_exp(float noundef %8) #40
  %10 = tail call spir_func float @_Z5ldexpfi(float noundef %8, i32 noundef 11) #38
  %11 = tail call spir_func i32 @frexp_exp(float noundef %7) #40
  %12 = add nsw i32 %11, -1
  %13 = tail call spir_func float @_Z5ldexpfi(float noundef %7, i32 noundef 1) #38
  %14 = sub i32 %9, %11
  %15 = tail call spir_func float @_Z12native_recipf(float noundef %13) #38
  %16 = icmp sgt i32 %14, 11
  br i1 %16, label %17, label %30

17:                                               ; preds = %6, %17
  %18 = phi float [ %27, %17 ], [ %10, %6 ]
  %19 = phi i32 [ %28, %17 ], [ %14, %6 ]
  %20 = fmul float %15, %18
  %21 = tail call float @llvm.rint.f32(float %20)
  %22 = fneg float %21
  %23 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %22, float noundef %13, float noundef %18) #38
  %24 = fcmp olt float %23, 0.000000e+00
  %25 = select i1 %24, float %13, float -0.000000e+00
  %26 = fadd float %23, %25
  %27 = tail call spir_func float @_Z5ldexpfi(float noundef %26, i32 noundef 11) #38
  %28 = add nsw i32 %19, -11
  %29 = icmp ugt i32 %19, 22
  br i1 %29, label %17, label %30

30:                                               ; preds = %17, %6
  %31 = phi i32 [ %14, %6 ], [ %28, %17 ]
  %32 = phi float [ %10, %6 ], [ %27, %17 ]
  %33 = add nsw i32 %31, -10
  %34 = tail call spir_func float @_Z5ldexpfi(float noundef %32, i32 noundef %33) #38
  %35 = fmul float %15, %34
  %36 = tail call float @llvm.rint.f32(float %35)
  %37 = fneg float %36
  %38 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %37, float noundef %13, float noundef %34) #38
  %39 = fcmp olt float %38, 0.000000e+00
  %40 = select i1 %39, float %13, float -0.000000e+00
  %41 = fadd float %38, %40
  %42 = tail call spir_func float @_Z5ldexpfi(float noundef %41, i32 noundef %12) #38
  %43 = fptrunc float %42 to half
  %44 = bitcast half %43 to i16
  %45 = bitcast half %0 to i16
  %46 = and i16 %45, -32768
  %47 = xor i16 %46, %44
  %48 = bitcast i16 %47 to half
  br label %53

49:                                               ; preds = %2
  %50 = fcmp oeq half %3, %4
  %51 = tail call half @llvm.copysign.f16(half 0xH0000, half %0)
  %52 = select i1 %50, half %51, half %0
  br label %53

53:                                               ; preds = %49, %30
  %54 = phi half [ %48, %30 ], [ %52, %49 ]
  %55 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %56 = icmp eq i8 %55, 0
  br i1 %56, label %57, label %66

57:                                               ; preds = %53
  %58 = fcmp uno half %1, 0xH0000
  br i1 %58, label %66, label %59

59:                                               ; preds = %57
  %60 = fcmp oeq half %1, 0xH0000
  %61 = fptoui half %0 to i16
  %62 = tail call spir_func i32 @__builtin_generic_class_f16.60(i16 noundef zeroext %61) #39
  %63 = icmp eq i32 %62, 0
  %64 = or i1 %60, %63
  %65 = select i1 %64, half 0xH7E00, half %54
  br label %66

66:                                               ; preds = %57, %59, %53
  %67 = phi half [ %54, %53 ], [ 0xH7E00, %57 ], [ %65, %59 ]
  ret half %67
}

; Function Attrs: convergent inlinehint norecurse nounwind
define internal spir_func i32 @frexp_exp(float noundef %0) unnamed_addr #33 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %3 = addrspacecast ptr %2 to ptr addrspace(4)
  %4 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %0, ptr addrspace(4) noundef %3) #40
  %5 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret i32 %5
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func i32 @__builtin_generic_class_f16.60(i16 noundef zeroext %0) unnamed_addr #25 {
  %2 = and i16 %0, 32767
  %3 = icmp eq i16 %2, 0
  br i1 %3, label %12, label %4

4:                                                ; preds = %1
  %5 = zext i16 %0 to i32
  %6 = and i32 %5, 31744
  %7 = icmp eq i32 %6, 0
  %8 = and i32 %5, 1023
  %9 = icmp ne i32 %8, 0
  %10 = and i1 %7, %9
  %11 = sext i1 %10 to i32
  br label %12

12:                                               ; preds = %4, %1
  %13 = phi i32 [ -1, %1 ], [ %11, %4 ]
  ret i32 %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_fmuladd_f64(double noundef %0, double noundef %1, double noundef %2) local_unnamed_addr #23 {
  %4 = tail call double @llvm.fmuladd.f64(double %0, double %1, double %2)
  ret double %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x float> @__ocml_fmuladd_2f32(<2 x float> noundef %0, <2 x float> noundef %1, <2 x float> noundef %2) local_unnamed_addr #23 {
  %4 = tail call <2 x float> @llvm.fmuladd.v2f32(<2 x float> %0, <2 x float> %1, <2 x float> %2)
  ret <2 x float> %4
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x float> @llvm.fmuladd.v2f32(<2 x float>, <2 x float>, <2 x float>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_fmuladd_2f16(<2 x half> noundef %0, <2 x half> noundef %1, <2 x half> noundef %2) local_unnamed_addr #23 {
  %4 = tail call <2 x half> @llvm.fmuladd.v2f16(<2 x half> %0, <2 x half> %1, <2 x half> %2)
  ret <2 x half> %4
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x half> @llvm.fmuladd.v2f16(<2 x half>, <2 x half>, <2 x half>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_fmuladd_f16(half noundef %0, half noundef %1, half noundef %2) local_unnamed_addr #23 {
  %4 = tail call half @llvm.fmuladd.f16(half %0, half %1, half %2)
  ret half %4
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.fmuladd.f16(half, half, half) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func i32 @__ocml_fpclassify_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = alloca double, align 8
  %3 = alloca double, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %0, ptr %3, align 8, !tbaa !19
  %4 = addrspacecast ptr %3 to ptr addrspace(4)
  %5 = load i128, ptr addrspace(4) %4, align 8, !tbaa !29
  %6 = and i128 %5, 9223372036854775807
  %7 = icmp eq i128 %6, 0
  br i1 %7, label %8, label %9

8:                                                ; preds = %1
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  br label %13

9:                                                ; preds = %1
  %10 = tail call double @llvm.fabs.f64(double %0)
  %11 = fcmp oeq double %10, 0x7FF0000000000000
  %12 = zext i1 %11 to i32
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  br label %13

13:                                               ; preds = %8, %9
  %14 = phi i32 [ %12, %9 ], [ 2, %8 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %0, ptr %2, align 8, !tbaa !19
  %15 = addrspacecast ptr %2 to ptr addrspace(4)
  %16 = load i128, ptr addrspace(4) %15, align 8, !tbaa !29
  %17 = and i128 %16, 9218868437227405312
  %18 = icmp ne i128 %17, 0
  %19 = and i128 %16, 4503599627370495
  %20 = icmp eq i128 %19, 0
  %21 = or i1 %18, %20
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %22 = select i1 %21, i32 %14, i32 3
  ret i32 %22
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func i32 @__ocml_fpclassify_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = alloca float, align 8
  %3 = alloca float, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %0, ptr %3, align 8, !tbaa !16
  %4 = addrspacecast ptr %3 to ptr addrspace(4)
  %5 = load i64, ptr addrspace(4) %4, align 8, !tbaa !12
  %6 = and i64 %5, 2147483647
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %8, label %9

8:                                                ; preds = %1
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br label %13

9:                                                ; preds = %1
  %10 = tail call float @llvm.fabs.f32(float %0)
  %11 = fcmp oeq float %10, 0x7FF0000000000000
  %12 = zext i1 %11 to i32
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br label %13

13:                                               ; preds = %8, %9
  %14 = phi i32 [ %12, %9 ], [ 2, %8 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %0, ptr %2, align 8, !tbaa !16
  %15 = addrspacecast ptr %2 to ptr addrspace(4)
  %16 = load i64, ptr addrspace(4) %15, align 8, !tbaa !12
  %17 = and i64 %16, 2139095040
  %18 = icmp ne i64 %17, 0
  %19 = and i64 %16, 8388607
  %20 = icmp eq i64 %19, 0
  %21 = or i1 %18, %20
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %22 = select i1 %21, i32 %14, i32 3
  ret i32 %22
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func i32 @__ocml_fpclassify_f16(half noundef %0) local_unnamed_addr #26 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  %3 = fcmp oeq half %2, 0xH7C00
  %4 = zext i1 %3 to i32
  %5 = fptoui half %0 to i16
  %6 = tail call spir_func i32 @__builtin_generic_class_f16.63(i16 noundef zeroext %5, i32 noundef 96) #39, !range !56
  %7 = icmp eq i32 %6, 0
  %8 = select i1 %7, i32 %4, i32 2
  %9 = tail call spir_func i32 @__builtin_generic_class_f16.63(i16 noundef zeroext %5, i32 noundef 144) #39, !range !56
  %10 = icmp eq i32 %9, 0
  %11 = select i1 %10, i32 %8, i32 3
  %12 = tail call spir_func i32 @__builtin_generic_class_f16.63(i16 noundef zeroext %5, i32 noundef 264) #39, !range !56
  %13 = icmp eq i32 %12, 0
  %14 = select i1 %13, i32 %11, i32 4
  ret i32 %14
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16.63(i16 noundef zeroext %0, i32 noundef %1) unnamed_addr #25 {
  %3 = and i32 %1, 4
  %4 = icmp ne i32 %3, 0
  %5 = icmp eq i16 %0, -1024
  %6 = and i1 %5, %4
  br i1 %6, label %30, label %7

7:                                                ; preds = %2
  %8 = and i32 %1, 3
  %9 = icmp eq i32 %8, 0
  %10 = and i16 %0, 32256
  %11 = icmp eq i16 %10, 0
  %12 = or i1 %11, %9
  br i1 %12, label %13, label %30

13:                                               ; preds = %7
  %14 = and i32 %1, 96
  %15 = icmp ne i32 %14, 0
  %16 = and i16 %0, 32767
  %17 = icmp eq i16 %16, 0
  %18 = and i1 %17, %15
  br i1 %18, label %30, label %19

19:                                               ; preds = %13
  %20 = and i32 %1, 144
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %29, label %22

22:                                               ; preds = %19
  %23 = zext i16 %0 to i32
  %24 = and i32 %23, 31744
  %25 = icmp ne i32 %24, 0
  %26 = and i32 %23, 1023
  %27 = icmp eq i32 %26, 0
  %28 = or i1 %25, %27
  br i1 %28, label %29, label %30

29:                                               ; preds = %22, %19
  br label %30

30:                                               ; preds = %22, %13, %7, %2, %29
  %31 = phi i32 [ 0, %29 ], [ -1, %2 ], [ -1, %7 ], [ -1, %13 ], [ -1, %22 ]
  ret i32 %31
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func double @__ocml_fract_f64(double noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #29 {
  %3 = alloca double, align 8
  %4 = tail call double @llvm.floor.f64(double %0)
  %5 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4, !tbaa !4
  %6 = icmp slt i32 %5, 8000
  br i1 %6, label %7, label %21

7:                                                ; preds = %2
  %8 = fsub double %0, %4
  %9 = tail call double @llvm.minnum.f64(double %8, double 0x3FEFFFFFFFFFFFFF)
  %10 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %12, label %29

12:                                               ; preds = %7
  %13 = fcmp uno double %0, 0.000000e+00
  %14 = select i1 %13, double %0, double %9
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %0, ptr %3, align 8, !tbaa !19
  %15 = addrspacecast ptr %3 to ptr addrspace(4)
  %16 = load i128, ptr addrspace(4) %15, align 8, !tbaa !29
  %17 = add i128 %16, -9218868437227405312
  %18 = and i128 %17, -9223372036854775809
  %19 = icmp eq i128 %18, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  %20 = select i1 %19, double 0.000000e+00, double %14
  br label %29

21:                                               ; preds = %2
  %22 = fptosi double %0 to i64
  %23 = sitofp i64 %22 to double
  %24 = fsub double %0, %23
  %25 = tail call double @llvm.fabs.f64(double %0)
  %26 = bitcast double %25 to i64
  %27 = icmp eq i64 %26, 9218868437227405312
  %28 = select i1 %27, double 0.000000e+00, double %24
  br label %29

29:                                               ; preds = %7, %12, %21
  %30 = phi double [ %9, %7 ], [ %20, %12 ], [ %28, %21 ]
  store double %4, ptr %1, align 8, !tbaa !19
  ret double %30
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func float @__ocml_fract_f32(float noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #29 {
  %3 = tail call float @llvm.floor.f32(float %0)
  %4 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4, !tbaa !4
  %5 = icmp slt i32 %4, 8000
  br i1 %5, label %6, label %17

6:                                                ; preds = %2
  %7 = fsub float %0, %3
  %8 = tail call float @llvm.minnum.f32(float %7, float 0x3FEFFFFFE0000000)
  %9 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %25

11:                                               ; preds = %6
  %12 = fcmp uno float %0, 0.000000e+00
  %13 = select i1 %12, float %0, float %8
  %14 = tail call float @llvm.fabs.f32(float %0)
  %15 = fcmp oeq float %14, 0x7FF0000000000000
  %16 = select i1 %15, float 0.000000e+00, float %13
  br label %25

17:                                               ; preds = %2
  %18 = fptosi float %0 to i32
  %19 = sitofp i32 %18 to float
  %20 = fsub float %0, %19
  %21 = tail call float @llvm.fabs.f32(float %0)
  %22 = bitcast float %21 to i32
  %23 = icmp eq i32 %22, 2139095040
  %24 = select i1 %23, float 0.000000e+00, float %20
  br label %25

25:                                               ; preds = %6, %11, %17
  %26 = phi float [ %8, %6 ], [ %16, %11 ], [ %24, %17 ]
  store float %3, ptr %1, align 4, !tbaa !16
  ret float %26
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func <2 x half> @__ocml_fract_2f16(<2 x half> noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #34 {
  %3 = tail call spir_func <2 x half> @llvm.floor.v2f16(<2 x half> noundef %0) #38
  store <2 x half> %3, ptr %1, align 4, !tbaa !14
  %4 = extractelement <2 x half> %0, i64 0
  %5 = tail call spir_func float @__builtin_generic_frac_f16(half noundef %4) #39
  %6 = fptrunc float %5 to half
  %7 = insertelement <2 x half> poison, half %6, i64 0
  %8 = extractelement <2 x half> %0, i64 1
  %9 = tail call spir_func float @__builtin_generic_frac_f16(half noundef %8) #39
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %7, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func float @__builtin_generic_frac_f16(half noundef %0) unnamed_addr #25 {
  %2 = fptosi half %0 to i16
  %3 = sitofp i16 %2 to half
  %4 = fsub half %0, %3
  %5 = tail call half @llvm.fabs.f16(half %0)
  %6 = bitcast half %5 to i16
  %7 = icmp eq i16 %6, 31744
  %8 = fpext half %4 to float
  %9 = select i1 %7, float 0.000000e+00, float %8
  ret float %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func half @__ocml_fract_f16(half noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #32 {
  %3 = tail call half @llvm.floor.f16(half %0)
  store half %3, ptr %1, align 2, !tbaa !57
  %4 = tail call spir_func float @__builtin_generic_frac_f16(half noundef %0) #39
  %5 = fptrunc float %4 to half
  ret half %5
}

; Function Attrs: convergent norecurse nounwind
define protected spir_func noundef double @__ocml_frexp_f64(double noundef returned %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #35 {
  %3 = alloca double, align 8
  %4 = alloca i32, align 4
  %5 = fptrunc double %0 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %6 = addrspacecast ptr %4 to ptr addrspace(4)
  %7 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %5, ptr addrspace(4) noundef %6) #40
  %8 = load i32, ptr %4, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %0, ptr %3, align 8, !tbaa !19
  %9 = addrspacecast ptr %3 to ptr addrspace(4)
  %10 = load i128, ptr addrspace(4) %9, align 8, !tbaa !29
  switch i128 %10, label %12 [
    i128 9218868437227405312, label %11
    i128 18442240474082181120, label %11
  ]

11:                                               ; preds = %2, %2
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  br label %16

12:                                               ; preds = %2
  %13 = and i128 %10, 9221120237041090560
  %14 = icmp eq i128 %13, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  %15 = select i1 %14, i32 %8, i32 0
  br label %16

16:                                               ; preds = %12, %11
  %17 = phi i32 [ 0, %11 ], [ %15, %12 ]
  store i32 %17, ptr %1, align 4, !tbaa !4
  ret double %0
}

; Function Attrs: convergent norecurse nounwind
define protected spir_func noundef float @__ocml_frexp_f32(float noundef returned %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #35 {
  %3 = alloca float, align 8
  %4 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %5 = addrspacecast ptr %4 to ptr addrspace(4)
  %6 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %0, ptr addrspace(4) noundef %5) #40
  %7 = load i32, ptr %4, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %0, ptr %3, align 8, !tbaa !16
  %8 = addrspacecast ptr %3 to ptr addrspace(4)
  %9 = load i64, ptr addrspace(4) %8, align 8, !tbaa !12
  switch i64 %9, label %11 [
    i64 2139095040, label %10
    i64 -8388608, label %10
  ]

10:                                               ; preds = %2, %2
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br label %15

11:                                               ; preds = %2
  %12 = and i64 %9, 2143289344
  %13 = icmp eq i64 %12, 0
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %14 = select i1 %13, i32 %7, i32 0
  br label %15

15:                                               ; preds = %11, %10
  %16 = phi i32 [ 0, %10 ], [ %14, %11 ]
  store i32 %16, ptr %1, align 4, !tbaa !4
  ret float %0
}

; Function Attrs: convergent norecurse nounwind
define protected spir_func noundef <2 x half> @__ocml_frexp_2f16(<2 x half> noundef returned %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #36 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = fpext half %3 to float
  %5 = tail call spir_func i32 @frexp_exp.64(float noundef %4) #40
  %6 = fptoui half %3 to i16
  %7 = tail call spir_func i32 @__builtin_generic_class_f16.65(i16 noundef zeroext %6) #39
  %8 = icmp eq i32 %7, 0
  %9 = select i1 %8, i32 %5, i32 0
  %10 = extractelement <2 x half> %0, i64 1
  %11 = fpext half %10 to float
  %12 = tail call spir_func i32 @frexp_exp.64(float noundef %11) #40
  %13 = fptoui half %10 to i16
  %14 = tail call spir_func i32 @__builtin_generic_class_f16.65(i16 noundef zeroext %13) #39
  %15 = icmp eq i32 %14, 0
  %16 = select i1 %15, i32 %12, i32 0
  %17 = insertelement <2 x i32> poison, i32 %9, i64 0
  %18 = insertelement <2 x i32> %17, i32 %16, i64 1
  store <2 x i32> %18, ptr %1, align 8, !tbaa !14
  ret <2 x half> %0
}

; Function Attrs: convergent inlinehint norecurse nounwind
define internal spir_func i32 @frexp_exp.64(float noundef %0) unnamed_addr #33 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %3 = addrspacecast ptr %2 to ptr addrspace(4)
  %4 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %0, ptr addrspace(4) noundef %3) #40
  %5 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret i32 %5
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16.65(i16 noundef zeroext %0) unnamed_addr #25 {
  switch i16 %0, label %2 [
    i16 31744, label %6
    i16 -1024, label %6
  ]

2:                                                ; preds = %1
  %3 = and i16 %0, 32256
  %4 = icmp ne i16 %3, 0
  %5 = sext i1 %4 to i32
  br label %6

6:                                                ; preds = %2, %1, %1
  %7 = phi i32 [ -1, %1 ], [ -1, %1 ], [ %5, %2 ]
  ret i32 %7
}

; Function Attrs: convergent norecurse nounwind
define protected spir_func noundef half @__ocml_frexp_f16(half noundef returned %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #36 {
  %3 = fpext half %0 to float
  %4 = tail call spir_func i32 @frexp_exp.64(float noundef %3) #40
  %5 = fptoui half %0 to i16
  %6 = tail call spir_func i32 @__builtin_generic_class_f16.65(i16 noundef zeroext %5) #39
  %7 = icmp eq i32 %6, 0
  %8 = select i1 %7, i32 %4, i32 0
  store i32 %8, ptr %1, align 4, !tbaa !4
  ret half %0
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_hypot_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #21 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = fpext half %3 to float
  %6 = fpext half %4 to float
  %7 = fmul float %6, %6
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef %5, float noundef %7) #38
  %9 = tail call float @llvm.sqrt.f32(float %8), !fpmath !18
  %10 = fptrunc float %9 to half
  %11 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %13, label %20

13:                                               ; preds = %2
  %14 = tail call half @llvm.fabs.f16(half %3)
  %15 = fcmp oeq half %14, 0xH7C00
  %16 = tail call half @llvm.fabs.f16(half %4)
  %17 = fcmp oeq half %16, 0xH7C00
  %18 = or i1 %15, %17
  %19 = select i1 %18, half 0xH7C00, half %10
  br label %20

20:                                               ; preds = %2, %13
  %21 = phi half [ %10, %2 ], [ %19, %13 ]
  %22 = extractelement <2 x half> %0, i64 1
  %23 = extractelement <2 x half> %1, i64 1
  %24 = fpext half %22 to float
  %25 = fpext half %23 to float
  %26 = fmul float %25, %25
  %27 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %24, float noundef %24, float noundef %26) #38
  %28 = tail call float @llvm.sqrt.f32(float %27), !fpmath !18
  %29 = fptrunc float %28 to half
  br i1 %12, label %30, label %37

30:                                               ; preds = %20
  %31 = tail call half @llvm.fabs.f16(half %22)
  %32 = fcmp oeq half %31, 0xH7C00
  %33 = tail call half @llvm.fabs.f16(half %23)
  %34 = fcmp oeq half %33, 0xH7C00
  %35 = or i1 %32, %34
  %36 = select i1 %35, half 0xH7C00, half %29
  br label %37

37:                                               ; preds = %20, %30
  %38 = phi half [ %29, %20 ], [ %36, %30 ]
  %39 = insertelement <2 x half> poison, half %21, i64 0
  %40 = insertelement <2 x half> %39, half %38, i64 1
  ret <2 x half> %40
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_hypot_f16(half noundef %0, half noundef %1) local_unnamed_addr #21 {
  %3 = fpext half %0 to float
  %4 = fpext half %1 to float
  %5 = fmul float %4, %4
  %6 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %3, float noundef %5) #38
  %7 = tail call float @llvm.sqrt.f32(float %6), !fpmath !18
  %8 = fptrunc float %7 to half
  %9 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %18

11:                                               ; preds = %2
  %12 = tail call half @llvm.fabs.f16(half %0)
  %13 = fcmp oeq half %12, 0xH7C00
  %14 = tail call half @llvm.fabs.f16(half %1)
  %15 = fcmp oeq half %14, 0xH7C00
  %16 = or i1 %13, %15
  %17 = select i1 %16, half 0xH7C00, half %8
  br label %18

18:                                               ; preds = %11, %2
  %19 = phi half [ %8, %2 ], [ %17, %11 ]
  ret half %19
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_i0_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = tail call double @llvm.fabs.f64(double %0)
  %4 = fcmp olt double %3, 8.000000e+00
  br i1 %4, label %5, label %25

5:                                                ; preds = %1
  %6 = fmul double %3, 2.500000e-01
  %7 = fmul double %3, %6
  %8 = tail call double @llvm.fma.f64(double %7, double 0x39EDD78750FF79B2, double 0x3A64394559531E65)
  %9 = tail call double @llvm.fma.f64(double %7, double %8, double 0x3AE6F7123F151C79)
  %10 = tail call double @llvm.fma.f64(double %7, double %9, double 0x3B63D9E7C5528048)
  %11 = tail call double @llvm.fma.f64(double %7, double %10, double 0x3BDE736F323A0CAB)
  %12 = tail call double @llvm.fma.f64(double %7, double %11, double 0x3C54196CE3B298C5)
  %13 = tail call double @llvm.fma.f64(double %7, double %12, double 0x3CC69CAAC7BF9255)
  %14 = tail call double @llvm.fma.f64(double %7, double %13, double 0x3D35601878C06AC8)
  %15 = tail call double @llvm.fma.f64(double %7, double %14, double 0x3DA0B313291F5E48)
  %16 = tail call double @llvm.fma.f64(double %7, double %15, double 0x3E0522A43F5DCB54)
  %17 = tail call double @llvm.fma.f64(double %7, double %16, double 0x3E6522A43F659634)
  %18 = tail call double @llvm.fma.f64(double %7, double %17, double 0x3EC02E85C0898945)
  %19 = tail call double @llvm.fma.f64(double %7, double %18, double 0x3F123456789ABCF3)
  %20 = tail call double @llvm.fma.f64(double %7, double %19, double 0x3F5C71C71C71C71C)
  %21 = tail call double @llvm.fma.f64(double %7, double %20, double 0x3F9C71C71C71C71C)
  %22 = tail call double @llvm.fma.f64(double %7, double %21, double 2.500000e-01)
  %23 = tail call double @llvm.fma.f64(double %7, double %22, double 1.000000e+00)
  %24 = tail call double @llvm.fma.f64(double %7, double %23, double 1.000000e+00)
  br label %57

25:                                               ; preds = %1
  %26 = fdiv double 1.000000e+00, %3
  %27 = tail call double @llvm.fma.f64(double %26, double 0x430CC967BACB549D, double 0xC315BA7722975981)
  %28 = tail call double @llvm.fma.f64(double %26, double %27, double 0x430DF0F836763276)
  %29 = tail call double @llvm.fma.f64(double %26, double %28, double 0xC2F9042A430F3F43)
  %30 = tail call double @llvm.fma.f64(double %26, double %29, double 0x42DC630541C4F568)
  %31 = tail call double @llvm.fma.f64(double %26, double %30, double 0xC2B7366BE5A9784F)
  %32 = tail call double @llvm.fma.f64(double %26, double %31, double 0x428C5669A48F574E)
  %33 = tail call double @llvm.fma.f64(double %26, double %32, double 0xC25A664CAC47F0EA)
  %34 = tail call double @llvm.fma.f64(double %26, double %33, double 0x422308250566988C)
  %35 = tail call double @llvm.fma.f64(double %26, double %34, double 0xC1E56874C2DDB061)
  %36 = tail call double @llvm.fma.f64(double %26, double %35, double 0x41A2DA58968DA2AA)
  %37 = tail call double @llvm.fma.f64(double %26, double %36, double 0xC159FAAA33F0D6BC)
  %38 = tail call double @llvm.fma.f64(double %26, double %37, double 0x410BE0A8F2BC76DD)
  %39 = tail call double @llvm.fma.f64(double %26, double %38, double 0xC0B7123C68C3CB02)
  %40 = tail call double @llvm.fma.f64(double %26, double %39, double 0x405D402150CC72AA)
  %41 = tail call double @llvm.fma.f64(double %26, double %40, double 0xBFF7A8AE85359520)
  %42 = tail call double @llvm.fma.f64(double %26, double %41, double 0x3FBBD7E0B6A753CD)
  %43 = tail call double @llvm.fma.f64(double %26, double %42, double 0x3FA6D6CE3774506D)
  %44 = tail call double @llvm.fma.f64(double %26, double %43, double 0x3F9DEBDD3D2F7CF9)
  %45 = tail call double @llvm.fma.f64(double %26, double %44, double 0x3F9CB94DB8D452D5)
  %46 = tail call double @llvm.fma.f64(double %26, double %45, double 0x3FA9884533DAEA3D)
  %47 = tail call double @llvm.fma.f64(double %26, double %46, double 0x3FD9884533D4362F)
  %48 = fadd double %3, -7.090000e+02
  %49 = fcmp ogt double %3, 7.090000e+02
  %50 = select i1 %49, double %48, double %3
  %51 = tail call spir_func double @__ocml_exp_f64(double noundef %50) #38
  %52 = select i1 %49, double 0x7FDD422D2BE5DC9B, double 1.000000e+00
  %53 = tail call spir_func double @__ocml_rsqrt_f64(double noundef %3) #38
  %54 = fmul double %51, %53
  %55 = fmul double %47, %54
  %56 = fmul double %52, %55
  br label %57

57:                                               ; preds = %25, %5
  %58 = phi double [ %24, %5 ], [ %56, %25 ]
  %59 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %60 = icmp eq i8 %59, 0
  br i1 %60, label %61, label %67

61:                                               ; preds = %57
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %3, ptr %2, align 8, !tbaa !19
  %62 = addrspacecast ptr %2 to ptr addrspace(4)
  %63 = load i128, ptr addrspace(4) %62, align 8, !tbaa !29
  %64 = and i128 %63, 9221120237041090560
  %65 = icmp eq i128 %64, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %66 = select i1 %65, double %58, double %3
  br label %67

67:                                               ; preds = %61, %57
  %68 = phi double [ %58, %57 ], [ %66, %61 ]
  ret double %68
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_rsqrt_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = fptrunc double %0 to float
  %4 = tail call spir_func float @_Z12native_rsqrtf(float noundef %3) #38
  %5 = fpext float %4 to double
  %6 = fneg double %0
  %7 = fmul double %6, %5
  %8 = tail call double @llvm.fma.f64(double %7, double %5, double 1.000000e+00)
  %9 = fmul double %8, %5
  %10 = tail call double @llvm.fma.f64(double %8, double 3.750000e-01, double 5.000000e-01)
  %11 = tail call double @llvm.fma.f64(double %9, double %10, double %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %5, ptr %2, align 8, !tbaa !19
  %12 = addrspacecast ptr %2 to ptr addrspace(4)
  %13 = load i128, ptr addrspace(4) %12, align 8, !tbaa !29
  %14 = and i128 %13, 9218868437227405312
  %15 = icmp ne i128 %14, 0
  %16 = and i128 %13, 4503599627370495
  %17 = icmp eq i128 %16, 0
  %18 = or i1 %15, %17
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %19 = select i1 %18, double %5, double %11
  ret double %19
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_i0_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = tail call float @llvm.fabs.f32(float %0)
  %4 = fcmp olt float %3, 8.000000e+00
  br i1 %4, label %5, label %18

5:                                                ; preds = %1
  %6 = fmul float %3, 2.500000e-01
  %7 = fmul float %3, %6
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef 0x3D438D7600000000, float noundef 0x3D97FD5C60000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %8, float noundef 0x3E066FFC80000000) #38
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %9, float noundef 0x3E64ECB6E0000000) #38
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %10, float noundef 0x3EC033C700000000) #38
  %12 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %11, float noundef 0x3F1233BB20000000) #38
  %13 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %12, float noundef 0x3F5C71DB20000000) #38
  %14 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %13, float noundef 0x3F9C71C5E0000000) #38
  %15 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %14, float noundef 2.500000e-01) #38
  %16 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %15, float noundef 1.000000e+00) #38
  %17 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %16, float noundef 1.000000e+00) #38
  br label %34

18:                                               ; preds = %1
  %19 = tail call spir_func float @_Z12native_recipf(float noundef %3) #38
  %20 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef 0x3FDC499160000000, float noundef 0xBFA110F5E0000000) #38
  %21 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef %20, float noundef 0x3FA2A130A0000000) #38
  %22 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef %21, float noundef 0x3F9C687020000000) #38
  %23 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef %22, float noundef 0x3FA9890AE0000000) #38
  %24 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef %23, float noundef 0x3FD9884500000000) #38
  %25 = fadd float %3, -8.800000e+01
  %26 = fcmp ogt float %3, 8.800000e+01
  %27 = select i1 %26, float %25, float %3
  %28 = tail call spir_func float @__ocml_exp_f32(float noundef %27) #38
  %29 = select i1 %26, float 0x47DF1056E0000000, float 1.000000e+00
  %30 = tail call spir_func float @_Z12native_rsqrtf(float noundef %3) #38
  %31 = fmul float %28, %30
  %32 = fmul float %24, %31
  %33 = fmul float %29, %32
  br label %34

34:                                               ; preds = %18, %5
  %35 = phi float [ %17, %5 ], [ %33, %18 ]
  %36 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %38, label %44

38:                                               ; preds = %34
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %3, ptr %2, align 8, !tbaa !16
  %39 = addrspacecast ptr %2 to ptr addrspace(4)
  %40 = load i64, ptr addrspace(4) %39, align 8, !tbaa !12
  %41 = and i64 %40, 2143289344
  %42 = icmp eq i64 %41, 0
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %43 = select i1 %42, float %35, float %3
  br label %44

44:                                               ; preds = %38, %34
  %45 = phi float [ %35, %34 ], [ %43, %38 ]
  ret float %45
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_i0_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_i0_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_i0_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_i0_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_i0_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_i1_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = tail call double @llvm.fabs.f64(double %0)
  %4 = fcmp olt double %3, 8.000000e+00
  br i1 %4, label %5, label %25

5:                                                ; preds = %1
  %6 = fmul double %3, 5.000000e-01
  %7 = fmul double %6, %6
  %8 = tail call double @llvm.fma.f64(double %7, double 0x3A2FC892C836E80A, double 0x3AA432352D94A857)
  %9 = tail call double @llvm.fma.f64(double %7, double %8, double 0x3B2588AE4F7B7A4A)
  %10 = tail call double @llvm.fma.f64(double %7, double %9, double 0x3BA15E96E9231B49)
  %11 = tail call double @llvm.fma.f64(double %7, double %10, double 0x3C18BDCB5F2184D1)
  %12 = tail call double @llvm.fma.f64(double %7, double %11, double 0x3C8E26237A1E02FE)
  %13 = tail call double @llvm.fma.f64(double %7, double %12, double 0x3CFF176ACA1A831F)
  %14 = tail call double @llvm.fma.f64(double %7, double %13, double 0x3D6AB81E97C83E75)
  %15 = tail call double @llvm.fma.f64(double %7, double %14, double 0x3DD2C9758E3649FF)
  %16 = tail call double @llvm.fma.f64(double %7, double %15, double 0x3E3522A43F5ED306)
  %17 = tail call double @llvm.fma.f64(double %7, double %16, double 0x3E927E4FB778D591)
  %18 = tail call double @llvm.fma.f64(double %7, double %17, double 0x3EE845C8A0CE4EDA)
  %19 = tail call double @llvm.fma.f64(double %7, double %18, double 0x3F36C16C16C16C26)
  %20 = tail call double @llvm.fma.f64(double %7, double %19, double 0x3F7C71C71C71C71C)
  %21 = tail call double @llvm.fma.f64(double %7, double %20, double 0x3FB5555555555555)
  %22 = tail call double @llvm.fma.f64(double %7, double %21, double 5.000000e-01)
  %23 = fmul double %6, %22
  %24 = tail call double @llvm.fma.f64(double %7, double %23, double %6)
  br label %57

25:                                               ; preds = %1
  %26 = fdiv double 1.000000e+00, %3
  %27 = tail call double @llvm.fma.f64(double %26, double 0xC30C9D8D43214423, double 0x4315C072E12FB4BA)
  %28 = tail call double @llvm.fma.f64(double %26, double %27, double 0xC30E26CFF438B6F6)
  %29 = tail call double @llvm.fma.f64(double %26, double %28, double 0x42F952224C61A221)
  %30 = tail call double @llvm.fma.f64(double %26, double %29, double 0xC2DCDC7C873CF435)
  %31 = tail call double @llvm.fma.f64(double %26, double %30, double 0x42B7B1E32A15FB86)
  %32 = tail call double @llvm.fma.f64(double %26, double %31, double 0xC28D07DBD6696F1C)
  %33 = tail call double @llvm.fma.f64(double %26, double %32, double 0x425B227934F2CED2)
  %34 = tail call double @llvm.fma.f64(double %26, double %33, double 0xC2239F23E6685444)
  %35 = tail call double @llvm.fma.f64(double %26, double %34, double 0x41E6229383F6F890)
  %36 = tail call double @llvm.fma.f64(double %26, double %35, double 0xC1A38BF1CEEEE865)
  %37 = tail call double @llvm.fma.f64(double %26, double %36, double 0x415B01A348B749B8)
  %38 = tail call double @llvm.fma.f64(double %26, double %37, double 0xC10D0E043EF0916A)
  %39 = tail call double @llvm.fma.f64(double %26, double %38, double 0x40B81B06F82CFBAC)
  %40 = tail call double @llvm.fma.f64(double %26, double %39, double 0xC05EA879B2A6508B)
  %41 = tail call double @llvm.fma.f64(double %26, double %40, double 0x3FF85CFFC8D54F52)
  %42 = tail call double @llvm.fma.f64(double %26, double %41, double 0xBFC09F107EE0F7E2)
  %43 = tail call double @llvm.fma.f64(double %26, double %42, double 0xBFAD61631539FB0D)
  %44 = tail call double @llvm.fma.f64(double %26, double %43, double 0xBFA4F1E01D904EBA)
  %45 = tail call double @llvm.fma.f64(double %26, double %44, double 0xBFA7EFC0CED79C58)
  %46 = tail call double @llvm.fma.f64(double %26, double %45, double 0xBFC32633E6E0F07A)
  %47 = tail call double @llvm.fma.f64(double %26, double %46, double 0x3FD9884533D43674)
  %48 = fadd double %0, -7.090000e+02
  %49 = fcmp ogt double %0, 7.090000e+02
  %50 = select i1 %49, double %48, double %0
  %51 = tail call spir_func double @__ocml_exp_f64(double noundef %50) #38
  %52 = select i1 %49, double 0x7FDD422D2BE5DC9B, double 1.000000e+00
  %53 = tail call spir_func double @__ocml_rsqrt_f64(double noundef %0) #38
  %54 = fmul double %51, %53
  %55 = fmul double %47, %54
  %56 = fmul double %52, %55
  br label %57

57:                                               ; preds = %25, %5
  %58 = phi double [ %24, %5 ], [ %56, %25 ]
  %59 = phi double [ %6, %5 ], [ %3, %25 ]
  %60 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %61 = icmp eq i8 %60, 0
  br i1 %61, label %62, label %68

62:                                               ; preds = %57
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %59, ptr %2, align 8, !tbaa !19
  %63 = addrspacecast ptr %2 to ptr addrspace(4)
  %64 = load i128, ptr addrspace(4) %63, align 8, !tbaa !29
  %65 = and i128 %64, 9221120237041090560
  %66 = icmp eq i128 %65, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %67 = select i1 %66, double %58, double %59
  br label %68

68:                                               ; preds = %62, %57
  %69 = phi double [ %58, %57 ], [ %67, %62 ]
  %70 = tail call double @llvm.copysign.f64(double %69, double %0)
  ret double %70
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_i1_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = tail call float @llvm.fabs.f32(float %0)
  %4 = fcmp olt float %3, 8.000000e+00
  br i1 %4, label %5, label %18

5:                                                ; preds = %1
  %6 = fmul float %3, 5.000000e-01
  %7 = fmul float %6, %6
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef 0x3D7882DD20000000, float noundef 0x3DCAF97F60000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %8, float noundef 0x3E366A3EA0000000) #38
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %9, float noundef 0x3E9251B320000000) #38
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %10, float noundef 0x3EE84CBB60000000) #38
  %12 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %11, float noundef 0x3F36C0D4A0000000) #38
  %13 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %12, float noundef 0x3F7C71D3A0000000) #38
  %14 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %13, float noundef 0x3FB5555500000000) #38
  %15 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %14, float noundef 5.000000e-01) #38
  %16 = fmul float %6, %15
  %17 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %16, float noundef %6) #38
  br label %34

18:                                               ; preds = %1
  %19 = tail call spir_func float @_Z12native_recipf(float noundef %3) #38
  %20 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef 0xBFE06DE320000000, float noundef 0x3FA043B220000000) #38
  %21 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef %20, float noundef 0xBFA9252760000000) #38
  %22 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef %21, float noundef 0xBFA7C15C80000000) #38
  %23 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef %22, float noundef 0xBFC3266CC0000000) #38
  %24 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %19, float noundef %23, float noundef 0x3FD9884560000000) #38
  %25 = fadd float %3, -8.800000e+01
  %26 = fcmp ogt float %3, 8.800000e+01
  %27 = select i1 %26, float %25, float %3
  %28 = tail call spir_func float @__ocml_exp_f32(float noundef %27) #38
  %29 = select i1 %26, float 0x47DF1056E0000000, float 1.000000e+00
  %30 = tail call spir_func float @_Z12native_rsqrtf(float noundef %3) #38
  %31 = fmul float %28, %30
  %32 = fmul float %24, %31
  %33 = fmul float %29, %32
  br label %34

34:                                               ; preds = %18, %5
  %35 = phi float [ %17, %5 ], [ %33, %18 ]
  %36 = phi float [ %6, %5 ], [ %3, %18 ]
  %37 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %38 = icmp eq i8 %37, 0
  br i1 %38, label %39, label %45

39:                                               ; preds = %34
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %36, ptr %2, align 8, !tbaa !16
  %40 = addrspacecast ptr %2 to ptr addrspace(4)
  %41 = load i64, ptr addrspace(4) %40, align 8, !tbaa !12
  %42 = and i64 %41, 2143289344
  %43 = icmp eq i64 %42, 0
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %44 = select i1 %43, float %35, float %36
  br label %45

45:                                               ; preds = %39, %34
  %46 = phi float [ %35, %34 ], [ %44, %39 ]
  %47 = tail call float @llvm.copysign.f32(float %46, float %0)
  ret float %47
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_i1_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_i1_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_i1_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_i1_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_i1_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func i32 @__ocml_ilogb_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = fptrunc double %0 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %4 = addrspacecast ptr %2 to ptr addrspace(4)
  %5 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %3, ptr addrspace(4) noundef %4) #40
  %6 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %7 = add nsw i32 %6, -1
  %8 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %9 = icmp eq i8 %8, 0
  %10 = call double @llvm.fabs.f64(double %0)
  %11 = fcmp ueq double %10, 0x7FF0000000000000
  %12 = and i1 %11, %9
  %13 = select i1 %12, i32 2147483647, i32 %7
  %14 = fcmp oeq double %0, 0.000000e+00
  %15 = select i1 %14, i32 -2147483648, i32 %13
  ret i32 %15
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func i32 @__ocml_ilogb_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %3 = addrspacecast ptr %2 to ptr addrspace(4)
  %4 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %0, ptr addrspace(4) noundef %3) #40
  %5 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %6 = add nsw i32 %5, -1
  %7 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %8 = icmp eq i8 %7, 0
  %9 = call float @llvm.fabs.f32(float %0)
  %10 = fcmp ueq float %9, 0x7FF0000000000000
  %11 = and i1 %10, %8
  %12 = select i1 %11, i32 2147483647, i32 %6
  %13 = fcmp oeq float %0, 0.000000e+00
  %14 = select i1 %13, i32 -2147483648, i32 %12
  ret i32 %14
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x i32> @__ocml_ilogb_2f16(<2 x half> noundef %0) local_unnamed_addr #24 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func i32 @frexp_exp.70(float noundef %3) #40
  %5 = add nsw i32 %4, -1
  %6 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %7 = icmp eq i8 %6, 0
  %8 = tail call half @llvm.fabs.f16(half %2)
  %9 = fcmp ueq half %8, 0xH7C00
  %10 = and i1 %9, %7
  %11 = select i1 %10, i32 2147483647, i32 %5
  %12 = fcmp oeq half %2, 0xH0000
  %13 = select i1 %12, i32 -2147483648, i32 %11
  %14 = insertelement <2 x i32> poison, i32 %13, i64 0
  %15 = extractelement <2 x half> %0, i64 1
  %16 = fpext half %15 to float
  %17 = tail call spir_func i32 @frexp_exp.70(float noundef %16) #40
  %18 = add nsw i32 %17, -1
  %19 = tail call half @llvm.fabs.f16(half %15)
  %20 = fcmp ueq half %19, 0xH7C00
  %21 = and i1 %20, %7
  %22 = select i1 %21, i32 2147483647, i32 %18
  %23 = fcmp oeq half %15, 0xH0000
  %24 = select i1 %23, i32 -2147483648, i32 %22
  %25 = insertelement <2 x i32> %14, i32 %24, i64 1
  ret <2 x i32> %25
}

; Function Attrs: convergent inlinehint norecurse nounwind
define internal spir_func i32 @frexp_exp.70(float noundef %0) unnamed_addr #33 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %3 = addrspacecast ptr %2 to ptr addrspace(4)
  %4 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %0, ptr addrspace(4) noundef %3) #40
  %5 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret i32 %5
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func i32 @__ocml_ilogb_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func i32 @frexp_exp.70(float noundef %2) #40
  %4 = add nsw i32 %3, -1
  %5 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %6 = icmp eq i8 %5, 0
  %7 = tail call half @llvm.fabs.f16(half %0)
  %8 = fcmp ueq half %7, 0xH7C00
  %9 = and i1 %8, %6
  %10 = select i1 %9, i32 2147483647, i32 %4
  %11 = fcmp oeq half %0, 0xH0000
  %12 = select i1 %11, i32 -2147483648, i32 %10
  ret i32 %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func i32 @__ocml_isfinite_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = alloca double, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %0, ptr %2, align 8, !tbaa !19
  %3 = addrspacecast ptr %2 to ptr addrspace(4)
  %4 = load i128, ptr addrspace(4) %3, align 8, !tbaa !29
  %5 = and i128 %4, 9223372036854775807
  %6 = icmp eq i128 %5, 0
  br i1 %6, label %14, label %7

7:                                                ; preds = %1
  %8 = and i128 %4, 9218868437227405312
  %9 = icmp eq i128 %8, 0
  %10 = and i128 %4, 4503599627370495
  %11 = icmp ne i128 %10, 0
  %12 = and i1 %9, %11
  %13 = sext i1 %12 to i32
  br label %14

14:                                               ; preds = %1, %7
  %15 = phi i32 [ -1, %1 ], [ %13, %7 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  ret i32 %15
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func i32 @__ocml_isfinite_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = alloca float, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %0, ptr %2, align 8, !tbaa !16
  %3 = addrspacecast ptr %2 to ptr addrspace(4)
  %4 = load i64, ptr addrspace(4) %3, align 8, !tbaa !12
  %5 = and i64 %4, 2147483647
  %6 = icmp eq i64 %5, 0
  br i1 %6, label %14, label %7

7:                                                ; preds = %1
  %8 = and i64 %4, 2139095040
  %9 = icmp eq i64 %8, 0
  %10 = and i64 %4, 8388607
  %11 = icmp ne i64 %10, 0
  %12 = and i1 %9, %11
  %13 = sext i1 %12 to i32
  br label %14

14:                                               ; preds = %1, %7
  %15 = phi i32 [ -1, %1 ], [ %13, %7 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  ret i32 %15
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x i16> @__ocml_isfinite_2f16(<2 x half> noundef %0) local_unnamed_addr #26 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fptoui half %2 to i16
  %4 = tail call spir_func i32 @__builtin_generic_class_f16.71(i16 noundef zeroext %3) #39
  %5 = icmp ne i32 %4, 0
  %6 = sext i1 %5 to i16
  %7 = insertelement <2 x i16> poison, i16 %6, i64 0
  %8 = extractelement <2 x half> %0, i64 1
  %9 = fptoui half %8 to i16
  %10 = tail call spir_func i32 @__builtin_generic_class_f16.71(i16 noundef zeroext %9) #39
  %11 = icmp ne i32 %10, 0
  %12 = sext i1 %11 to i16
  %13 = insertelement <2 x i16> %7, i16 %12, i64 1
  ret <2 x i16> %13
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func i32 @__builtin_generic_class_f16.71(i16 noundef zeroext %0) unnamed_addr #25 {
  %2 = and i16 %0, 32767
  %3 = icmp eq i16 %2, 0
  br i1 %3, label %12, label %4

4:                                                ; preds = %1
  %5 = zext i16 %0 to i32
  %6 = and i32 %5, 31744
  %7 = icmp eq i32 %6, 0
  %8 = and i32 %5, 1023
  %9 = icmp ne i32 %8, 0
  %10 = and i1 %7, %9
  %11 = sext i1 %10 to i32
  br label %12

12:                                               ; preds = %4, %1
  %13 = phi i32 [ -1, %1 ], [ %11, %4 ]
  ret i32 %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func i32 @__ocml_isfinite_f16(half noundef %0) local_unnamed_addr #26 {
  %2 = fptoui half %0 to i16
  %3 = tail call spir_func i32 @__builtin_generic_class_f16.71(i16 noundef zeroext %2) #39
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef i32 @__ocml_isinf_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fcmp oeq double %2, 0x7FF0000000000000
  %4 = zext i1 %3 to i32
  ret i32 %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef i32 @__ocml_isinf_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = fcmp oeq float %2, 0x7FF0000000000000
  %4 = zext i1 %3 to i32
  ret i32 %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x i16> @__ocml_isinf_2f16(<2 x half> noundef %0) local_unnamed_addr #26 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call half @llvm.fabs.f16(half %2)
  %4 = fcmp oeq half %3, 0xH7C00
  %5 = sext i1 %4 to i16
  %6 = insertelement <2 x i16> poison, i16 %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = tail call half @llvm.fabs.f16(half %7)
  %9 = fcmp oeq half %8, 0xH7C00
  %10 = sext i1 %9 to i16
  %11 = insertelement <2 x i16> %6, i16 %10, i64 1
  ret <2 x i16> %11
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef i32 @__ocml_isinf_f16(half noundef %0) local_unnamed_addr #26 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  %3 = fcmp oeq half %2, 0xH7C00
  %4 = zext i1 %3 to i32
  ret i32 %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef i32 @__ocml_isnan_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = fcmp uno double %0, 0.000000e+00
  %3 = zext i1 %2 to i32
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef i32 @__ocml_isnan_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = fcmp uno float %0, 0.000000e+00
  %3 = zext i1 %2 to i32
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x i16> @__ocml_isnan_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fcmp uno half %2, 0xH0000
  %4 = sext i1 %3 to i16
  %5 = insertelement <2 x i16> poison, i16 %4, i64 0
  %6 = extractelement <2 x half> %0, i64 1
  %7 = fcmp uno half %6, 0xH0000
  %8 = sext i1 %7 to i16
  %9 = insertelement <2 x i16> %5, i16 %8, i64 1
  ret <2 x i16> %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef i32 @__ocml_isnan_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = fcmp uno half %0, 0xH0000
  %3 = zext i1 %2 to i32
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef i32 @__ocml_isnormal_f64(double noundef %0) local_unnamed_addr #23 {
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef i32 @__ocml_isnormal_f32(float noundef %0) local_unnamed_addr #23 {
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x i16> @__ocml_isnormal_2f16(<2 x half> noundef %0) local_unnamed_addr #26 {
  ret <2 x i16> zeroinitializer
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef i32 @__ocml_isnormal_f16(half noundef %0) local_unnamed_addr #26 {
  ret i32 0
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_j0_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = tail call double @llvm.fabs.f64(double %0)
  %4 = fcmp ugt double %3, 0x4029280000000000
  br i1 %4, label %74, label %5

5:                                                ; preds = %1
  %6 = fcmp ugt double %3, 0x4019100000000000
  br i1 %6, label %16, label %7

7:                                                ; preds = %5
  %8 = fcmp ugt double %3, 1.656250e+00
  br i1 %8, label %9, label %25

9:                                                ; preds = %7
  %10 = fcmp ugt double %3, 3.125000e+00
  br i1 %10, label %11, label %25

11:                                               ; preds = %9
  %12 = fcmp ugt double %3, 4.687500e+00
  %13 = select i1 %12, double 0x3C975054CD60A517, double 0xBCA60155A9D1B256
  %14 = select i1 %12, double 0x4016148F5B2C2E45, double 0x400EA75575AF6F09
  %15 = select i1 %12, ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J0, i64 0, i64 45), ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J0, i64 0, i64 30)
  br label %25

16:                                               ; preds = %5
  %17 = fcmp ugt double %3, 7.843750e+00
  br i1 %17, label %18, label %25

18:                                               ; preds = %16
  %19 = fcmp ugt double %3, 0x4022D80000000000
  br i1 %19, label %20, label %25

20:                                               ; preds = %18
  %21 = fcmp ugt double %3, 0x4025F80000000000
  %22 = select i1 %21, double 0x3CB444FD5821D5B1, double 0x3CC02610A51562B6
  %23 = select i1 %21, double 0x40279544008272B6, double 0x402458D0D0BDFC29
  %24 = select i1 %21, ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J0, i64 0, i64 105), ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J0, i64 0, i64 90)
  br label %25

25:                                               ; preds = %20, %18, %16, %11, %9, %7
  %26 = phi double [ 0.000000e+00, %7 ], [ 0xBCA0F539D7DA258E, %9 ], [ %13, %11 ], [ 0xBC9B226D9D243827, %16 ], [ 0xBCB51970714C7C25, %18 ], [ %22, %20 ]
  %27 = phi double [ 0.000000e+00, %7 ], [ 0x40033D152E971B40, %9 ], [ %14, %11 ], [ 0x401C0FF5F3B47250, %16 ], [ 0x40214EB56CCCDECA, %18 ], [ %23, %20 ]
  %28 = phi ptr addrspace(2) [ @__ocmltbl_M64_J0, %7 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J0, i64 0, i64 15), %9 ], [ %15, %11 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J0, i64 0, i64 60), %16 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J0, i64 0, i64 75), %18 ], [ %24, %20 ]
  %29 = fsub double %3, %27
  %30 = fsub double %29, %26
  %31 = getelementptr inbounds double, ptr addrspace(2) %28, i64 14
  %32 = load double, ptr addrspace(2) %31, align 8, !tbaa !19
  %33 = getelementptr inbounds double, ptr addrspace(2) %28, i64 13
  %34 = load double, ptr addrspace(2) %33, align 8, !tbaa !19
  %35 = tail call double @llvm.fma.f64(double %30, double %32, double %34)
  %36 = getelementptr inbounds double, ptr addrspace(2) %28, i64 12
  %37 = load double, ptr addrspace(2) %36, align 8, !tbaa !19
  %38 = tail call double @llvm.fma.f64(double %30, double %35, double %37)
  %39 = getelementptr inbounds double, ptr addrspace(2) %28, i64 11
  %40 = load double, ptr addrspace(2) %39, align 8, !tbaa !19
  %41 = tail call double @llvm.fma.f64(double %30, double %38, double %40)
  %42 = getelementptr inbounds double, ptr addrspace(2) %28, i64 10
  %43 = load double, ptr addrspace(2) %42, align 8, !tbaa !19
  %44 = tail call double @llvm.fma.f64(double %30, double %41, double %43)
  %45 = getelementptr inbounds double, ptr addrspace(2) %28, i64 9
  %46 = load double, ptr addrspace(2) %45, align 8, !tbaa !19
  %47 = tail call double @llvm.fma.f64(double %30, double %44, double %46)
  %48 = getelementptr inbounds double, ptr addrspace(2) %28, i64 8
  %49 = load double, ptr addrspace(2) %48, align 8, !tbaa !19
  %50 = tail call double @llvm.fma.f64(double %30, double %47, double %49)
  %51 = getelementptr inbounds double, ptr addrspace(2) %28, i64 7
  %52 = load double, ptr addrspace(2) %51, align 8, !tbaa !19
  %53 = tail call double @llvm.fma.f64(double %30, double %50, double %52)
  %54 = getelementptr inbounds double, ptr addrspace(2) %28, i64 6
  %55 = load double, ptr addrspace(2) %54, align 8, !tbaa !19
  %56 = tail call double @llvm.fma.f64(double %30, double %53, double %55)
  %57 = getelementptr inbounds double, ptr addrspace(2) %28, i64 5
  %58 = load double, ptr addrspace(2) %57, align 8, !tbaa !19
  %59 = tail call double @llvm.fma.f64(double %30, double %56, double %58)
  %60 = getelementptr inbounds double, ptr addrspace(2) %28, i64 4
  %61 = load double, ptr addrspace(2) %60, align 8, !tbaa !19
  %62 = tail call double @llvm.fma.f64(double %30, double %59, double %61)
  %63 = getelementptr inbounds double, ptr addrspace(2) %28, i64 3
  %64 = load double, ptr addrspace(2) %63, align 8, !tbaa !19
  %65 = tail call double @llvm.fma.f64(double %30, double %62, double %64)
  %66 = getelementptr inbounds double, ptr addrspace(2) %28, i64 2
  %67 = load double, ptr addrspace(2) %66, align 8, !tbaa !19
  %68 = tail call double @llvm.fma.f64(double %30, double %65, double %67)
  %69 = getelementptr inbounds double, ptr addrspace(2) %28, i64 1
  %70 = load double, ptr addrspace(2) %69, align 8, !tbaa !19
  %71 = tail call double @llvm.fma.f64(double %30, double %68, double %70)
  %72 = load double, ptr addrspace(2) %28, align 8, !tbaa !19
  %73 = tail call double @llvm.fma.f64(double %30, double %71, double %72)
  br label %102

74:                                               ; preds = %1
  %75 = fdiv double 1.000000e+00, %3
  %76 = fmul double %75, %75
  %77 = tail call spir_func double @__ocmlpriv_bp0_f64(double noundef %76) #38
  %78 = fmul double %75, %77
  %79 = fptrunc double %75 to float
  %80 = tail call spir_func float @_Z12native_rsqrtf(float noundef %79) #38
  %81 = fpext float %80 to double
  %82 = fmul double %75, %81
  %83 = fmul double %81, 5.000000e-01
  %84 = fneg double %83
  %85 = tail call double @llvm.fma.f64(double %84, double %82, double 5.000000e-01)
  %86 = tail call double @llvm.fma.f64(double %83, double %85, double %83)
  %87 = tail call double @llvm.fma.f64(double %82, double %85, double %82)
  %88 = fneg double %87
  %89 = tail call double @llvm.fma.f64(double %88, double %87, double %75)
  %90 = tail call double @llvm.fma.f64(double %89, double %86, double %87)
  %91 = fcmp oeq double %75, 0.000000e+00
  %92 = select i1 %91, double %75, double %90
  %93 = fmul double %92, 0x3FE9884533D43651
  %94 = tail call spir_func double @__ocmlpriv_ba0_f64(double noundef %76) #38
  %95 = fmul double %94, %93
  %96 = tail call spir_func double @__ocmlpriv_cosb_f64(double noundef %3, i32 noundef 0, double noundef %78) #40
  %97 = fmul double %96, %95
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %3, ptr %2, align 8, !tbaa !19
  %98 = addrspacecast ptr %2 to ptr addrspace(4)
  %99 = load i128, ptr addrspace(4) %98, align 8, !tbaa !29
  %100 = icmp eq i128 %99, 9218868437227405312
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %101 = select i1 %100, double 0.000000e+00, double %97
  br label %102

102:                                              ; preds = %74, %25
  %103 = phi double [ %73, %25 ], [ %101, %74 ]
  ret double %103
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_j0_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = tail call float @llvm.fabs.f32(float %0)
  %4 = fcmp ugt float %3, 0x4029280000000000
  br i1 %4, label %56, label %5

5:                                                ; preds = %1
  %6 = fcmp ugt float %3, 0x4019100000000000
  br i1 %6, label %16, label %7

7:                                                ; preds = %5
  %8 = fcmp ugt float %3, 1.656250e+00
  br i1 %8, label %9, label %25

9:                                                ; preds = %7
  %10 = fcmp ugt float %3, 3.125000e+00
  br i1 %10, label %11, label %25

11:                                               ; preds = %9
  %12 = fcmp ugt float %3, 4.687500e+00
  %13 = select i1 %12, float 0xBE734F46E0000000, float 0xBE74A121E0000000
  %14 = select i1 %12, float 0x4016148F60000000, float 0x400EA75580000000
  %15 = select i1 %12, ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J0, i64 0, i64 27), ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J0, i64 0, i64 18)
  br label %25

16:                                               ; preds = %5
  %17 = fcmp ugt float %3, 7.843750e+00
  br i1 %17, label %18, label %25

18:                                               ; preds = %16
  %19 = fcmp ugt float %3, 0x4022D80000000000
  br i1 %19, label %20, label %25

20:                                               ; preds = %18
  %21 = fcmp ugt float %3, 0x4025F80000000000
  %22 = select i1 %21, float 0x3E504E56C0000000, float 0xBE9E8407A0000000
  %23 = select i1 %21, float 0x4027954400000000, float 0x402458D0E0000000
  %24 = select i1 %21, ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J0, i64 0, i64 63), ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J0, i64 0, i64 54)
  br label %25

25:                                               ; preds = %20, %18, %16, %11, %9, %7
  %26 = phi float [ 0.000000e+00, %7 ], [ 0x3E7D2E3680000000, %9 ], [ %13, %11 ], [ 0xBE88971B60000000, %16 ], [ 0x3E9999BDA0000000, %18 ], [ %22, %20 ]
  %27 = phi float [ 0.000000e+00, %7 ], [ 0x40033D1520000000, %9 ], [ %14, %11 ], [ 0x401C0FF600000000, %16 ], [ 0x40214EB560000000, %18 ], [ %23, %20 ]
  %28 = phi ptr addrspace(2) [ @__ocmltbl_M32_J0, %7 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J0, i64 0, i64 9), %9 ], [ %15, %11 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J0, i64 0, i64 36), %16 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J0, i64 0, i64 45), %18 ], [ %24, %20 ]
  %29 = fsub float %3, %27
  %30 = fsub float %29, %26
  %31 = getelementptr inbounds float, ptr addrspace(2) %28, i64 8
  %32 = load float, ptr addrspace(2) %31, align 4, !tbaa !16
  %33 = getelementptr inbounds float, ptr addrspace(2) %28, i64 7
  %34 = load float, ptr addrspace(2) %33, align 4, !tbaa !16
  %35 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %32, float noundef %34) #38
  %36 = getelementptr inbounds float, ptr addrspace(2) %28, i64 6
  %37 = load float, ptr addrspace(2) %36, align 4, !tbaa !16
  %38 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %35, float noundef %37) #38
  %39 = getelementptr inbounds float, ptr addrspace(2) %28, i64 5
  %40 = load float, ptr addrspace(2) %39, align 4, !tbaa !16
  %41 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %38, float noundef %40) #38
  %42 = getelementptr inbounds float, ptr addrspace(2) %28, i64 4
  %43 = load float, ptr addrspace(2) %42, align 4, !tbaa !16
  %44 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %41, float noundef %43) #38
  %45 = getelementptr inbounds float, ptr addrspace(2) %28, i64 3
  %46 = load float, ptr addrspace(2) %45, align 4, !tbaa !16
  %47 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %44, float noundef %46) #38
  %48 = getelementptr inbounds float, ptr addrspace(2) %28, i64 2
  %49 = load float, ptr addrspace(2) %48, align 4, !tbaa !16
  %50 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %47, float noundef %49) #38
  %51 = getelementptr inbounds float, ptr addrspace(2) %28, i64 1
  %52 = load float, ptr addrspace(2) %51, align 4, !tbaa !16
  %53 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %50, float noundef %52) #38
  %54 = load float, ptr addrspace(2) %28, align 4, !tbaa !16
  %55 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %53, float noundef %54) #38
  br label %71

56:                                               ; preds = %1
  %57 = fdiv float 1.000000e+00, %3, !fpmath !15
  %58 = fmul float %57, %57
  %59 = tail call spir_func float @__ocmlpriv_bp0_f32(float noundef %58) #38
  %60 = fmul float %57, %59
  %61 = tail call spir_func float @_Z12native_rsqrtf(float noundef %3) #38
  %62 = fmul float %61, 0x3FE9884540000000
  %63 = tail call spir_func float @__ocmlpriv_ba0_f32(float noundef %58) #38
  %64 = fmul float %62, %63
  %65 = tail call spir_func float @__ocmlpriv_cosb_f32(float noundef %3, i32 noundef 0, float noundef %60) #40
  %66 = fmul float %64, %65
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %3, ptr %2, align 8, !tbaa !16
  %67 = addrspacecast ptr %2 to ptr addrspace(4)
  %68 = load i64, ptr addrspace(4) %67, align 8, !tbaa !12
  %69 = icmp eq i64 %68, 2139095040
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %70 = select i1 %69, float 0.000000e+00, float %66
  br label %71

71:                                               ; preds = %56, %25
  %72 = phi float [ %55, %25 ], [ %70, %56 ]
  ret float %72
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_j0_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_j0_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_j0_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_j0_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_j0_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_j1_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = tail call double @llvm.fabs.f64(double %0)
  %4 = fcmp ugt double %3, 0x4029080000000000
  br i1 %4, label %74, label %5

5:                                                ; preds = %1
  %6 = fcmp ugt double %3, 0x4018B00000000000
  br i1 %6, label %16, label %7

7:                                                ; preds = %5
  %8 = fcmp ugt double %3, 1.093750e+00
  br i1 %8, label %9, label %25

9:                                                ; preds = %7
  %10 = fcmp ugt double %3, 2.843750e+00
  br i1 %10, label %11, label %25

11:                                               ; preds = %9
  %12 = fcmp ugt double %3, 0x4012500000000000
  %13 = select i1 %12, double 0x3CA5C646A75D7539, double 0xBCA60155A9D1B256
  %14 = select i1 %12, double 0x40155365BC032467, double 0x400EA75575AF6F09
  %15 = select i1 %12, ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J1, i64 0, i64 45), ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J1, i64 0, i64 30)
  br label %25

16:                                               ; preds = %5
  %17 = fcmp ugt double %3, 7.781250e+00
  br i1 %17, label %18, label %25

18:                                               ; preds = %16
  %19 = fcmp ugt double %3, 0x4022B80000000000
  br i1 %19, label %20, label %25

20:                                               ; preds = %18
  %21 = fcmp ugt double %3, 0x4025E80000000000
  %22 = select i1 %21, double 0x3CC9A84D3A5FEDC2, double 0x3CC02610A51562B6
  %23 = select i1 %21, double 0x40276979797EE5AC, double 0x402458D0D0BDFC29
  %24 = select i1 %21, ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J1, i64 0, i64 105), ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J1, i64 0, i64 90)
  br label %25

25:                                               ; preds = %20, %18, %16, %11, %9, %7
  %26 = phi double [ 0.000000e+00, %7 ], [ 0x3C5616D820CFDAEB, %9 ], [ %13, %11 ], [ 0xBC9B226D9D243827, %16 ], [ 0xBCA63E17EC20A31D, %18 ], [ %22, %20 ]
  %27 = phi double [ 0.000000e+00, %7 ], [ 0x3FFD757D1FEC8A3A, %9 ], [ %14, %11 ], [ 0x401C0FF5F3B47250, %16 ], [ 0x402112980F0B88A1, %18 ], [ %23, %20 ]
  %28 = phi ptr addrspace(2) [ @__ocmltbl_M64_J1, %7 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J1, i64 0, i64 15), %9 ], [ %15, %11 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J1, i64 0, i64 60), %16 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_J1, i64 0, i64 75), %18 ], [ %24, %20 ]
  %29 = fsub double %3, %27
  %30 = fsub double %29, %26
  %31 = getelementptr inbounds double, ptr addrspace(2) %28, i64 14
  %32 = load double, ptr addrspace(2) %31, align 8, !tbaa !19
  %33 = getelementptr inbounds double, ptr addrspace(2) %28, i64 13
  %34 = load double, ptr addrspace(2) %33, align 8, !tbaa !19
  %35 = tail call double @llvm.fma.f64(double %30, double %32, double %34)
  %36 = getelementptr inbounds double, ptr addrspace(2) %28, i64 12
  %37 = load double, ptr addrspace(2) %36, align 8, !tbaa !19
  %38 = tail call double @llvm.fma.f64(double %30, double %35, double %37)
  %39 = getelementptr inbounds double, ptr addrspace(2) %28, i64 11
  %40 = load double, ptr addrspace(2) %39, align 8, !tbaa !19
  %41 = tail call double @llvm.fma.f64(double %30, double %38, double %40)
  %42 = getelementptr inbounds double, ptr addrspace(2) %28, i64 10
  %43 = load double, ptr addrspace(2) %42, align 8, !tbaa !19
  %44 = tail call double @llvm.fma.f64(double %30, double %41, double %43)
  %45 = getelementptr inbounds double, ptr addrspace(2) %28, i64 9
  %46 = load double, ptr addrspace(2) %45, align 8, !tbaa !19
  %47 = tail call double @llvm.fma.f64(double %30, double %44, double %46)
  %48 = getelementptr inbounds double, ptr addrspace(2) %28, i64 8
  %49 = load double, ptr addrspace(2) %48, align 8, !tbaa !19
  %50 = tail call double @llvm.fma.f64(double %30, double %47, double %49)
  %51 = getelementptr inbounds double, ptr addrspace(2) %28, i64 7
  %52 = load double, ptr addrspace(2) %51, align 8, !tbaa !19
  %53 = tail call double @llvm.fma.f64(double %30, double %50, double %52)
  %54 = getelementptr inbounds double, ptr addrspace(2) %28, i64 6
  %55 = load double, ptr addrspace(2) %54, align 8, !tbaa !19
  %56 = tail call double @llvm.fma.f64(double %30, double %53, double %55)
  %57 = getelementptr inbounds double, ptr addrspace(2) %28, i64 5
  %58 = load double, ptr addrspace(2) %57, align 8, !tbaa !19
  %59 = tail call double @llvm.fma.f64(double %30, double %56, double %58)
  %60 = getelementptr inbounds double, ptr addrspace(2) %28, i64 4
  %61 = load double, ptr addrspace(2) %60, align 8, !tbaa !19
  %62 = tail call double @llvm.fma.f64(double %30, double %59, double %61)
  %63 = getelementptr inbounds double, ptr addrspace(2) %28, i64 3
  %64 = load double, ptr addrspace(2) %63, align 8, !tbaa !19
  %65 = tail call double @llvm.fma.f64(double %30, double %62, double %64)
  %66 = getelementptr inbounds double, ptr addrspace(2) %28, i64 2
  %67 = load double, ptr addrspace(2) %66, align 8, !tbaa !19
  %68 = tail call double @llvm.fma.f64(double %30, double %65, double %67)
  %69 = getelementptr inbounds double, ptr addrspace(2) %28, i64 1
  %70 = load double, ptr addrspace(2) %69, align 8, !tbaa !19
  %71 = tail call double @llvm.fma.f64(double %30, double %68, double %70)
  %72 = load double, ptr addrspace(2) %28, align 8, !tbaa !19
  %73 = tail call double @llvm.fma.f64(double %30, double %71, double %72)
  br label %102

74:                                               ; preds = %1
  %75 = fdiv double 1.000000e+00, %3
  %76 = fmul double %75, %75
  %77 = tail call spir_func double @__ocmlpriv_bp1_f64(double noundef %76) #38
  %78 = fmul double %75, %77
  %79 = fptrunc double %75 to float
  %80 = tail call spir_func float @_Z12native_rsqrtf(float noundef %79) #38
  %81 = fpext float %80 to double
  %82 = fmul double %75, %81
  %83 = fmul double %81, 5.000000e-01
  %84 = fneg double %83
  %85 = tail call double @llvm.fma.f64(double %84, double %82, double 5.000000e-01)
  %86 = tail call double @llvm.fma.f64(double %83, double %85, double %83)
  %87 = tail call double @llvm.fma.f64(double %82, double %85, double %82)
  %88 = fneg double %87
  %89 = tail call double @llvm.fma.f64(double %88, double %87, double %75)
  %90 = tail call double @llvm.fma.f64(double %89, double %86, double %87)
  %91 = fcmp oeq double %75, 0.000000e+00
  %92 = select i1 %91, double %75, double %90
  %93 = fmul double %92, 0x3FE9884533D43651
  %94 = tail call spir_func double @__ocmlpriv_ba1_f64(double noundef %76) #38
  %95 = fmul double %94, %93
  %96 = tail call spir_func double @__ocmlpriv_cosb_f64(double noundef %3, i32 noundef 1, double noundef %78) #40
  %97 = fmul double %96, %95
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %3, ptr %2, align 8, !tbaa !19
  %98 = addrspacecast ptr %2 to ptr addrspace(4)
  %99 = load i128, ptr addrspace(4) %98, align 8, !tbaa !29
  %100 = icmp eq i128 %99, 9218868437227405312
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %101 = select i1 %100, double 0.000000e+00, double %97
  br label %102

102:                                              ; preds = %74, %25
  %103 = phi double [ %73, %25 ], [ %101, %74 ]
  %104 = fcmp olt double %0, 0.000000e+00
  %105 = fneg double %103
  %106 = select i1 %104, double %105, double %103
  ret double %106
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_j1_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = tail call float @llvm.fabs.f32(float %0)
  %4 = fcmp ugt float %3, 0x4029080000000000
  br i1 %4, label %56, label %5

5:                                                ; preds = %1
  %6 = fcmp ugt float %3, 0x4018B00000000000
  br i1 %6, label %16, label %7

7:                                                ; preds = %5
  %8 = fcmp ugt float %3, 1.093750e+00
  br i1 %8, label %9, label %25

9:                                                ; preds = %7
  %10 = fcmp ugt float %3, 2.843750e+00
  br i1 %10, label %11, label %25

11:                                               ; preds = %9
  %12 = fcmp ugt float %3, 0x4012500000000000
  %13 = select i1 %12, float 0xBE6FE6DCC0000000, float 0xBE74A121E0000000
  %14 = select i1 %12, float 0x40155365C0000000, float 0x400EA75580000000
  %15 = select i1 %12, ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J1, i64 0, i64 27), ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J1, i64 0, i64 18)
  br label %25

16:                                               ; preds = %5
  %17 = fcmp ugt float %3, 7.781250e+00
  br i1 %17, label %18, label %25

18:                                               ; preds = %16
  %19 = fcmp ugt float %3, 0x4022B80000000000
  br i1 %19, label %20, label %25

20:                                               ; preds = %18
  %21 = fcmp ugt float %3, 0x4025E80000000000
  %22 = select i1 %21, float 0xBE8A046940000000, float 0xBE9E8407A0000000
  %23 = select i1 %21, float 0x4027697980000000, float 0x402458D0E0000000
  %24 = select i1 %21, ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J1, i64 0, i64 63), ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J1, i64 0, i64 54)
  br label %25

25:                                               ; preds = %20, %18, %16, %11, %9, %7
  %26 = phi float [ 0.000000e+00, %7 ], [ 0xBDF375C600000000, %9 ], [ %13, %11 ], [ 0xBE88971B60000000, %16 ], [ 0x3E9E171140000000, %18 ], [ %22, %20 ]
  %27 = phi float [ 0.000000e+00, %7 ], [ 0x3FFD757D20000000, %9 ], [ %14, %11 ], [ 0x401C0FF600000000, %16 ], [ 0x4021129800000000, %18 ], [ %23, %20 ]
  %28 = phi ptr addrspace(2) [ @__ocmltbl_M32_J1, %7 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J1, i64 0, i64 9), %9 ], [ %15, %11 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J1, i64 0, i64 36), %16 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_J1, i64 0, i64 45), %18 ], [ %24, %20 ]
  %29 = fsub float %3, %27
  %30 = fsub float %29, %26
  %31 = getelementptr inbounds float, ptr addrspace(2) %28, i64 8
  %32 = load float, ptr addrspace(2) %31, align 4, !tbaa !16
  %33 = getelementptr inbounds float, ptr addrspace(2) %28, i64 7
  %34 = load float, ptr addrspace(2) %33, align 4, !tbaa !16
  %35 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %32, float noundef %34) #38
  %36 = getelementptr inbounds float, ptr addrspace(2) %28, i64 6
  %37 = load float, ptr addrspace(2) %36, align 4, !tbaa !16
  %38 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %35, float noundef %37) #38
  %39 = getelementptr inbounds float, ptr addrspace(2) %28, i64 5
  %40 = load float, ptr addrspace(2) %39, align 4, !tbaa !16
  %41 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %38, float noundef %40) #38
  %42 = getelementptr inbounds float, ptr addrspace(2) %28, i64 4
  %43 = load float, ptr addrspace(2) %42, align 4, !tbaa !16
  %44 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %41, float noundef %43) #38
  %45 = getelementptr inbounds float, ptr addrspace(2) %28, i64 3
  %46 = load float, ptr addrspace(2) %45, align 4, !tbaa !16
  %47 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %44, float noundef %46) #38
  %48 = getelementptr inbounds float, ptr addrspace(2) %28, i64 2
  %49 = load float, ptr addrspace(2) %48, align 4, !tbaa !16
  %50 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %47, float noundef %49) #38
  %51 = getelementptr inbounds float, ptr addrspace(2) %28, i64 1
  %52 = load float, ptr addrspace(2) %51, align 4, !tbaa !16
  %53 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %50, float noundef %52) #38
  %54 = load float, ptr addrspace(2) %28, align 4, !tbaa !16
  %55 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %30, float noundef %53, float noundef %54) #38
  br label %71

56:                                               ; preds = %1
  %57 = fdiv float 1.000000e+00, %3, !fpmath !15
  %58 = fmul float %57, %57
  %59 = tail call spir_func float @__ocmlpriv_bp1_f32(float noundef %58) #38
  %60 = fmul float %57, %59
  %61 = tail call spir_func float @_Z12native_rsqrtf(float noundef %3) #38
  %62 = fmul float %61, 0x3FE9884540000000
  %63 = tail call spir_func float @__ocmlpriv_ba1_f32(float noundef %58) #38
  %64 = fmul float %62, %63
  %65 = tail call spir_func float @__ocmlpriv_cosb_f32(float noundef %3, i32 noundef 1, float noundef %60) #40
  %66 = fmul float %64, %65
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %3, ptr %2, align 8, !tbaa !16
  %67 = addrspacecast ptr %2 to ptr addrspace(4)
  %68 = load i64, ptr addrspace(4) %67, align 8, !tbaa !12
  %69 = icmp eq i64 %68, 2139095040
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %70 = select i1 %69, float 0.000000e+00, float %66
  br label %71

71:                                               ; preds = %56, %25
  %72 = phi float [ %55, %25 ], [ %70, %56 ]
  %73 = fcmp olt float %0, 0.000000e+00
  %74 = fneg float %72
  %75 = select i1 %73, float %74, float %72
  ret float %75
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_j1_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_j1_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_j1_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_j1_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_j1_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_ldexp_f64(double noundef %0, i32 noundef %1) local_unnamed_addr #21 {
  %3 = tail call spir_func double @_Z5ldexpdi(double noundef %0, i32 noundef %1) #38
  ret double %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_ldexp_f32(float noundef %0, i32 noundef %1) local_unnamed_addr #21 {
  %3 = tail call spir_func float @_Z5ldexpfi(float noundef %0, i32 noundef %1) #38
  ret float %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_ldexp_2f16(<2 x half> noundef %0, <2 x i32> noundef %1) local_unnamed_addr #24 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x i32> %1, i64 0
  %5 = tail call i32 @llvm.smax.i32(i32 %4, i32 -32768)
  %6 = tail call i32 @llvm.smin.i32(i32 %5, i32 32767)
  %7 = tail call spir_func half @_Z5ldexpDhi(half noundef %3, i32 noundef %6) #38
  %8 = insertelement <2 x half> poison, half %7, i64 0
  %9 = extractelement <2 x half> %0, i64 1
  %10 = extractelement <2 x i32> %1, i64 1
  %11 = tail call i32 @llvm.smax.i32(i32 %10, i32 -32768)
  %12 = tail call i32 @llvm.smin.i32(i32 %11, i32 32767)
  %13 = tail call spir_func half @_Z5ldexpDhi(half noundef %9, i32 noundef %12) #38
  %14 = insertelement <2 x half> %8, half %13, i64 1
  ret <2 x half> %14
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #2

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func half @_Z5ldexpDhi(half noundef, i32 noundef) local_unnamed_addr #22

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_ldexp_f16(half noundef %0, i32 noundef %1) local_unnamed_addr #24 {
  %3 = tail call i32 @llvm.smax.i32(i32 %1, i32 -32768)
  %4 = tail call i32 @llvm.smin.i32(i32 %3, i32 32767)
  %5 = tail call spir_func half @_Z5ldexpDhi(half noundef %0, i32 noundef %4) #38
  ret half %5
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_len3_f64(double noundef %0, double noundef %1, double noundef %2) local_unnamed_addr #21 {
  %4 = alloca double, align 8
  %5 = alloca double, align 8
  %6 = alloca double, align 8
  %7 = alloca i32, align 4
  %8 = tail call double @llvm.fabs.f64(double %0)
  %9 = tail call double @llvm.fabs.f64(double %1)
  %10 = tail call double @llvm.fabs.f64(double %2)
  %11 = tail call double @llvm.maxnum.f64(double %8, double %9)
  %12 = tail call double @llvm.minnum.f64(double %8, double %9)
  %13 = tail call double @llvm.maxnum.f64(double %11, double %10)
  %14 = tail call double @llvm.minnum.f64(double %11, double %10)
  %15 = tail call double @llvm.maxnum.f64(double %12, double %14)
  %16 = tail call double @llvm.minnum.f64(double %12, double %14)
  %17 = fptrunc double %13 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %7) #39
  %18 = addrspacecast ptr %7 to ptr addrspace(4)
  %19 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %17, ptr addrspace(4) noundef %18) #40
  %20 = load i32, ptr %7, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %7) #39
  %21 = sub nsw i32 0, %20
  %22 = call spir_func double @_Z5ldexpdi(double noundef %13, i32 noundef %21) #38
  %23 = call spir_func double @_Z5ldexpdi(double noundef %15, i32 noundef %21) #38
  %24 = call spir_func double @_Z5ldexpdi(double noundef %16, i32 noundef %21) #38
  %25 = fmul double %24, %24
  %26 = call double @llvm.fma.f64(double %23, double %23, double %25)
  %27 = call double @llvm.fma.f64(double %22, double %22, double %26)
  %28 = fptrunc double %27 to float
  %29 = call spir_func float @_Z12native_rsqrtf(float noundef %28) #38
  %30 = fpext float %29 to double
  %31 = fmul double %27, %30
  %32 = fmul double %30, 5.000000e-01
  %33 = fneg double %32
  %34 = call double @llvm.fma.f64(double %33, double %31, double 5.000000e-01)
  %35 = call double @llvm.fma.f64(double %32, double %34, double %32)
  %36 = call double @llvm.fma.f64(double %31, double %34, double %31)
  %37 = fneg double %36
  %38 = call double @llvm.fma.f64(double %37, double %36, double %27)
  %39 = call double @llvm.fma.f64(double %38, double %35, double %36)
  %40 = fcmp oeq double %27, 0.000000e+00
  %41 = select i1 %40, double %27, double %39
  %42 = call spir_func double @_Z5ldexpdi(double noundef %41, i32 noundef %20) #38
  %43 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %44 = icmp eq i8 %43, 0
  br i1 %44, label %45, label %68

45:                                               ; preds = %3
  %46 = fcmp uno double %0, %1
  %47 = fcmp uno double %2, 0.000000e+00
  %48 = or i1 %46, %47
  %49 = select i1 %48, double 0x7FF8000000000000, double %42
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %6)
  store double %0, ptr %6, align 8, !tbaa !19
  %50 = addrspacecast ptr %6 to ptr addrspace(4)
  %51 = load i128, ptr addrspace(4) %50, align 8, !tbaa !29
  %52 = add i128 %51, -9218868437227405312
  %53 = and i128 %52, -9223372036854775809
  %54 = icmp eq i128 %53, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5)
  store double %1, ptr %5, align 8, !tbaa !19
  %55 = addrspacecast ptr %5 to ptr addrspace(4)
  %56 = load i128, ptr addrspace(4) %55, align 8, !tbaa !29
  %57 = add i128 %56, -9218868437227405312
  %58 = and i128 %57, -9223372036854775809
  %59 = icmp eq i128 %58, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5)
  %60 = or i1 %54, %59
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  store double %2, ptr %4, align 8, !tbaa !19
  %61 = addrspacecast ptr %4 to ptr addrspace(4)
  %62 = load i128, ptr addrspace(4) %61, align 8, !tbaa !29
  %63 = add i128 %62, -9218868437227405312
  %64 = and i128 %63, -9223372036854775809
  %65 = icmp eq i128 %64, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %66 = or i1 %60, %65
  %67 = select i1 %66, double 0x7FF0000000000000, double %49
  br label %68

68:                                               ; preds = %45, %3
  %69 = phi double [ %42, %3 ], [ %67, %45 ]
  ret double %69
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_len3_f32(float noundef %0, float noundef %1, float noundef %2) local_unnamed_addr #21 {
  %4 = alloca i32, align 4
  %5 = tail call float @llvm.fabs.f32(float %0)
  %6 = tail call float @llvm.fabs.f32(float %1)
  %7 = tail call float @llvm.fabs.f32(float %2)
  %8 = bitcast float %5 to i32
  %9 = bitcast float %6 to i32
  %10 = tail call i32 @llvm.umax.i32(i32 %8, i32 %9)
  %11 = tail call i32 @llvm.umin.i32(i32 %8, i32 %9)
  %12 = bitcast float %7 to i32
  %13 = tail call i32 @llvm.umax.i32(i32 %10, i32 %12)
  %14 = bitcast i32 %13 to float
  %15 = tail call i32 @llvm.umin.i32(i32 %10, i32 %12)
  %16 = tail call i32 @llvm.umax.i32(i32 %11, i32 %15)
  %17 = bitcast i32 %16 to float
  %18 = tail call i32 @llvm.umin.i32(i32 %11, i32 %15)
  %19 = bitcast i32 %18 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %20 = addrspacecast ptr %4 to ptr addrspace(4)
  %21 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %14, ptr addrspace(4) noundef %20) #40
  %22 = load i32, ptr %4, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  %23 = sub nsw i32 0, %22
  %24 = call spir_func float @_Z5ldexpfi(float noundef %14, i32 noundef %23) #38
  %25 = call spir_func float @_Z5ldexpfi(float noundef %17, i32 noundef %23) #38
  %26 = call spir_func float @_Z5ldexpfi(float noundef %19, i32 noundef %23) #38
  %27 = fmul float %26, %26
  %28 = call spir_func float @__ocml_fmuladd_f32(float noundef %25, float noundef %25, float noundef %27) #38
  %29 = call spir_func float @__ocml_fmuladd_f32(float noundef %24, float noundef %24, float noundef %28) #38
  %30 = call float @llvm.sqrt.f32(float %29), !fpmath !18
  %31 = call spir_func float @_Z5ldexpfi(float noundef %30, i32 noundef %22) #38
  %32 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %34, label %41

34:                                               ; preds = %3
  %35 = fcmp oeq float %5, 0x7FF0000000000000
  %36 = fcmp oeq float %6, 0x7FF0000000000000
  %37 = or i1 %35, %36
  %38 = fcmp oeq float %7, 0x7FF0000000000000
  %39 = or i1 %37, %38
  %40 = select i1 %39, float 0x7FF0000000000000, float %31
  br label %41

41:                                               ; preds = %34, %3
  %42 = phi float [ %31, %3 ], [ %40, %34 ]
  ret float %42
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_len3_f16(half noundef %0, half noundef %1, half noundef %2) local_unnamed_addr #26 {
  %4 = fmul half %2, %2
  %5 = tail call half @llvm.fma.f16(half %1, half %1, half %4)
  %6 = tail call half @llvm.fma.f16(half %0, half %0, half %5)
  %7 = fpext half %6 to float
  %8 = tail call float @llvm.sqrt.f32(float %7), !fpmath !18
  %9 = fptrunc float %8 to half
  %10 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %12, label %22

12:                                               ; preds = %3
  %13 = tail call half @llvm.fabs.f16(half %0)
  %14 = fcmp oeq half %13, 0xH7C00
  %15 = tail call half @llvm.fabs.f16(half %1)
  %16 = fcmp oeq half %15, 0xH7C00
  %17 = or i1 %14, %16
  %18 = tail call half @llvm.fabs.f16(half %2)
  %19 = fcmp oeq half %18, 0xH7C00
  %20 = or i1 %17, %19
  %21 = select i1 %20, half 0xH7C00, half %9
  br label %22

22:                                               ; preds = %12, %3
  %23 = phi half [ %9, %3 ], [ %21, %12 ]
  ret half %23
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_len4_f64(double noundef %0, double noundef %1, double noundef %2, double noundef %3) local_unnamed_addr #21 {
  %5 = alloca i32, align 4
  %6 = tail call double @llvm.fabs.f64(double %0)
  %7 = tail call double @llvm.fabs.f64(double %1)
  %8 = tail call double @llvm.fabs.f64(double %2)
  %9 = tail call double @llvm.fabs.f64(double %3)
  %10 = tail call double @llvm.maxnum.f64(double %6, double %7)
  %11 = tail call double @llvm.minnum.f64(double %6, double %7)
  %12 = tail call double @llvm.maxnum.f64(double %8, double %9)
  %13 = tail call double @llvm.minnum.f64(double %8, double %9)
  %14 = tail call double @llvm.maxnum.f64(double %10, double %12)
  %15 = tail call double @llvm.minnum.f64(double %10, double %12)
  %16 = tail call double @llvm.maxnum.f64(double %11, double %13)
  %17 = tail call double @llvm.minnum.f64(double %11, double %13)
  %18 = tail call double @llvm.maxnum.f64(double %16, double %15)
  %19 = tail call double @llvm.minnum.f64(double %16, double %15)
  %20 = fptrunc double %14 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %21 = addrspacecast ptr %5 to ptr addrspace(4)
  %22 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %20, ptr addrspace(4) noundef %21) #40
  %23 = load i32, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %24 = sub nsw i32 0, %23
  %25 = call spir_func double @_Z5ldexpdi(double noundef %14, i32 noundef %24) #38
  %26 = call spir_func double @_Z5ldexpdi(double noundef %18, i32 noundef %24) #38
  %27 = call spir_func double @_Z5ldexpdi(double noundef %19, i32 noundef %24) #38
  %28 = call spir_func double @_Z5ldexpdi(double noundef %17, i32 noundef %24) #38
  %29 = fmul double %28, %28
  %30 = call double @llvm.fma.f64(double %27, double %27, double %29)
  %31 = call double @llvm.fma.f64(double %26, double %26, double %30)
  %32 = call double @llvm.fma.f64(double %25, double %25, double %31)
  %33 = fptrunc double %32 to float
  %34 = call spir_func float @_Z12native_rsqrtf(float noundef %33) #38
  %35 = fpext float %34 to double
  %36 = fmul double %32, %35
  %37 = fmul double %35, 5.000000e-01
  %38 = fneg double %37
  %39 = call double @llvm.fma.f64(double %38, double %36, double 5.000000e-01)
  %40 = call double @llvm.fma.f64(double %37, double %39, double %37)
  %41 = call double @llvm.fma.f64(double %36, double %39, double %36)
  %42 = fneg double %41
  %43 = call double @llvm.fma.f64(double %42, double %41, double %32)
  %44 = call double @llvm.fma.f64(double %43, double %40, double %41)
  %45 = fcmp oeq double %32, 0.000000e+00
  %46 = select i1 %45, double %32, double %44
  %47 = call spir_func double @_Z5ldexpdi(double noundef %46, i32 noundef %23) #38
  %48 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %50, label %63

50:                                               ; preds = %4
  %51 = fcmp uno double %0, %1
  %52 = fcmp uno double %3, %2
  %53 = or i1 %51, %52
  %54 = select i1 %53, double 0x7FF8000000000000, double %47
  %55 = fcmp oeq double %6, 0x7FF0000000000000
  %56 = fcmp oeq double %7, 0x7FF0000000000000
  %57 = or i1 %55, %56
  %58 = fcmp oeq double %8, 0x7FF0000000000000
  %59 = or i1 %57, %58
  %60 = fcmp oeq double %9, 0x7FF0000000000000
  %61 = or i1 %59, %60
  %62 = select i1 %61, double 0x7FF0000000000000, double %54
  br label %63

63:                                               ; preds = %50, %4
  %64 = phi double [ %47, %4 ], [ %62, %50 ]
  ret double %64
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_len4_f32(float noundef %0, float noundef %1, float noundef %2, float noundef %3) local_unnamed_addr #21 {
  %5 = alloca i32, align 4
  %6 = tail call float @llvm.fabs.f32(float %0)
  %7 = tail call float @llvm.fabs.f32(float %1)
  %8 = tail call float @llvm.fabs.f32(float %2)
  %9 = tail call float @llvm.fabs.f32(float %3)
  %10 = bitcast float %6 to i32
  %11 = bitcast float %7 to i32
  %12 = tail call i32 @llvm.umax.i32(i32 %10, i32 %11)
  %13 = tail call i32 @llvm.umin.i32(i32 %10, i32 %11)
  %14 = bitcast float %8 to i32
  %15 = bitcast float %9 to i32
  %16 = tail call i32 @llvm.umax.i32(i32 %14, i32 %15)
  %17 = tail call i32 @llvm.umin.i32(i32 %14, i32 %15)
  %18 = tail call i32 @llvm.umax.i32(i32 %12, i32 %16)
  %19 = bitcast i32 %18 to float
  %20 = tail call i32 @llvm.umin.i32(i32 %12, i32 %16)
  %21 = tail call i32 @llvm.umax.i32(i32 %13, i32 %17)
  %22 = tail call i32 @llvm.umin.i32(i32 %13, i32 %17)
  %23 = bitcast i32 %22 to float
  %24 = tail call i32 @llvm.umax.i32(i32 %21, i32 %20)
  %25 = bitcast i32 %24 to float
  %26 = tail call i32 @llvm.umin.i32(i32 %21, i32 %20)
  %27 = bitcast i32 %26 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %28 = addrspacecast ptr %5 to ptr addrspace(4)
  %29 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %19, ptr addrspace(4) noundef %28) #40
  %30 = load i32, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %31 = sub nsw i32 0, %30
  %32 = call spir_func float @_Z5ldexpfi(float noundef %19, i32 noundef %31) #38
  %33 = call spir_func float @_Z5ldexpfi(float noundef %25, i32 noundef %31) #38
  %34 = call spir_func float @_Z5ldexpfi(float noundef %27, i32 noundef %31) #38
  %35 = call spir_func float @_Z5ldexpfi(float noundef %23, i32 noundef %31) #38
  %36 = fmul float %35, %35
  %37 = call spir_func float @__ocml_fmuladd_f32(float noundef %34, float noundef %34, float noundef %36) #38
  %38 = call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef %33, float noundef %37) #38
  %39 = call spir_func float @__ocml_fmuladd_f32(float noundef %32, float noundef %32, float noundef %38) #38
  %40 = call float @llvm.sqrt.f32(float %39), !fpmath !18
  %41 = call spir_func float @_Z5ldexpfi(float noundef %40, i32 noundef %30) #38
  %42 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %44, label %53

44:                                               ; preds = %4
  %45 = fcmp oeq float %6, 0x7FF0000000000000
  %46 = fcmp oeq float %7, 0x7FF0000000000000
  %47 = or i1 %45, %46
  %48 = fcmp oeq float %8, 0x7FF0000000000000
  %49 = or i1 %47, %48
  %50 = fcmp oeq float %9, 0x7FF0000000000000
  %51 = or i1 %49, %50
  %52 = select i1 %51, float 0x7FF0000000000000, float %41
  br label %53

53:                                               ; preds = %44, %4
  %54 = phi float [ %41, %4 ], [ %52, %44 ]
  ret float %54
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_len4_f16(half noundef %0, half noundef %1, half noundef %2, half noundef %3) local_unnamed_addr #26 {
  %5 = fmul half %3, %3
  %6 = tail call half @llvm.fma.f16(half %2, half %2, half %5)
  %7 = tail call half @llvm.fma.f16(half %1, half %1, half %6)
  %8 = tail call half @llvm.fma.f16(half %0, half %0, half %7)
  %9 = fpext half %8 to float
  %10 = tail call float @llvm.sqrt.f32(float %9), !fpmath !18
  %11 = fptrunc float %10 to half
  %12 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %14, label %27

14:                                               ; preds = %4
  %15 = tail call half @llvm.fabs.f16(half %0)
  %16 = fcmp oeq half %15, 0xH7C00
  %17 = tail call half @llvm.fabs.f16(half %1)
  %18 = fcmp oeq half %17, 0xH7C00
  %19 = or i1 %16, %18
  %20 = tail call half @llvm.fabs.f16(half %2)
  %21 = fcmp oeq half %20, 0xH7C00
  %22 = or i1 %19, %21
  %23 = tail call half @llvm.fabs.f16(half %3)
  %24 = fcmp oeq half %23, 0xH7C00
  %25 = or i1 %22, %24
  %26 = select i1 %25, half 0xH7C00, half %11
  br label %27

27:                                               ; preds = %14, %4
  %28 = phi half [ %11, %4 ], [ %26, %14 ]
  ret half %28
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_lgamma_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %3 = call spir_func double @__ocml_lgamma_r_f64(double noundef %0, ptr noundef nonnull %2) #40
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret double %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write)
define protected spir_func double @__ocml_lgamma_r_f64(double noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #30 {
  %3 = alloca double, align 8
  %4 = tail call double @llvm.fabs.f64(double %0)
  %5 = bitcast double %4 to <2 x i32>
  %6 = extractelement <2 x i32> %5, i64 1
  %7 = icmp ult i32 %6, 1064304640
  br i1 %7, label %8, label %16

8:                                                ; preds = %2
  %9 = tail call double @llvm.fma.f64(double %4, double 0xBFCA8B9C17AA6149, double 0x3FD151322AC7D848)
  %10 = tail call double @llvm.fma.f64(double %4, double %9, double 0xBFD9A4D55BEAB2D7)
  %11 = tail call double @llvm.fma.f64(double %4, double %10, double 0x3FEA51A6625307D3)
  %12 = tail call double @llvm.fma.f64(double %4, double %11, double 0xBFE2788CFC6FB619)
  %13 = tail call spir_func double @__ocml_log_f64(double noundef %4) #38
  %14 = fneg double %13
  %15 = tail call double @llvm.fma.f64(double %4, double %12, double %14)
  br label %155

16:                                               ; preds = %2
  %17 = icmp ult i32 %6, 1073741824
  br i1 %17, label %18, label %94

18:                                               ; preds = %16
  %19 = icmp ult i32 %6, 1072483533
  br i1 %19, label %20, label %28

20:                                               ; preds = %18
  %21 = tail call spir_func double @__ocml_log_f64(double noundef %4) #38
  %22 = fneg double %21
  %23 = fsub double 1.000000e+00, %4
  %24 = icmp ult i32 %6, 1072130372
  %25 = fadd double %4, 0xBFDD8B618D5AF8FC
  %26 = select i1 %24, double %25, double %23
  %27 = icmp ult i32 %6, 1070442081
  br i1 %27, label %74, label %35

28:                                               ; preds = %18
  %29 = fsub double 2.000000e+00, %4
  %30 = icmp ult i32 %6, 1073460419
  %31 = fadd double %4, 0xBFF762D86356BE3F
  %32 = select i1 %30, double %31, double %29
  %33 = icmp ult i32 %6, 1072936132
  %34 = fadd double %4, -1.000000e+00
  br i1 %33, label %74, label %35

35:                                               ; preds = %28, %20
  %36 = phi double [ %26, %20 ], [ %32, %28 ]
  %37 = phi i1 [ %24, %20 ], [ %30, %28 ]
  %38 = phi double [ %22, %20 ], [ 0.000000e+00, %28 ]
  %39 = fmul double %36, %36
  br i1 %37, label %54, label %40

40:                                               ; preds = %35
  %41 = tail call double @llvm.fma.f64(double %39, double 0x3EFA7074428CFA52, double 0x3F2CF2ECED10E54D)
  %42 = tail call double @llvm.fma.f64(double %39, double %41, double 0x3F538A94116F3F5D)
  %43 = tail call double @llvm.fma.f64(double %39, double %42, double 0x3F7E404FB68FEFE8)
  %44 = tail call double @llvm.fma.f64(double %39, double %43, double 0x3FB13E001A5562A7)
  %45 = tail call double @llvm.fma.f64(double %39, double %44, double 0x3FB3C467E37DB0C8)
  %46 = tail call double @llvm.fma.f64(double %39, double 0x3F07858E90A45837, double 0x3F1C5088987DFB07)
  %47 = tail call double @llvm.fma.f64(double %39, double %46, double 0x3F40B6C689B99C00)
  %48 = tail call double @llvm.fma.f64(double %39, double %47, double 0x3F67ADD8CCB7926B)
  %49 = tail call double @llvm.fma.f64(double %39, double %48, double 0x3F951322AC92547B)
  %50 = tail call double @llvm.fma.f64(double %39, double %49, double 0x3FD4A34CC4A60FAD)
  %51 = fmul double %39, %50
  %52 = tail call double @llvm.fma.f64(double %36, double %45, double %51)
  %53 = tail call double @llvm.fma.f64(double %36, double -5.000000e-01, double %52)
  br label %90

54:                                               ; preds = %35
  %55 = fmul double %36, %39
  %56 = tail call double @llvm.fma.f64(double %55, double 0x3F34AF6D6C0EBBF7, double 0xBF56FE8EBF2D1AF1)
  %57 = tail call double @llvm.fma.f64(double %55, double %56, double 0x3F78FCE0E370E344)
  %58 = tail call double @llvm.fma.f64(double %55, double %57, double 0xBFA0C9A8DF35B713)
  %59 = tail call double @llvm.fma.f64(double %55, double %58, double 0x3FDEF72BC8EE38A2)
  %60 = tail call double @llvm.fma.f64(double %55, double 0xBF347F24ECC38C38, double 0x3F4CDF0CEF61A8E9)
  %61 = tail call double @llvm.fma.f64(double %55, double %60, double 0xBF6E2EFFB3E914D7)
  %62 = tail call double @llvm.fma.f64(double %55, double %61, double 0x3F9266E7970AF9EC)
  %63 = tail call double @llvm.fma.f64(double %55, double %62, double 0xBFC2E4278DC6C509)
  %64 = tail call double @llvm.fma.f64(double %55, double 0x3F35FD3EE8C2D3F4, double 0xBF41A6109C73E0EC)
  %65 = tail call double @llvm.fma.f64(double %55, double %64, double 0x3F6282D32E15C915)
  %66 = tail call double @llvm.fma.f64(double %55, double %65, double 0xBF851F9FBA91EC6A)
  %67 = tail call double @llvm.fma.f64(double %55, double %66, double 0x3FB08B4294D5419B)
  %68 = tail call double @llvm.fma.f64(double %36, double %67, double %63)
  %69 = fneg double %68
  %70 = tail call double @llvm.fma.f64(double %55, double %69, double 0xBC50C7CAA48A971F)
  %71 = fneg double %70
  %72 = tail call double @llvm.fma.f64(double %39, double %59, double %71)
  %73 = fadd double %72, 0xBFBF19B9BCC38A42
  br label %90

74:                                               ; preds = %28, %20
  %75 = phi double [ %22, %20 ], [ 0.000000e+00, %28 ]
  %76 = phi double [ %4, %20 ], [ %34, %28 ]
  %77 = tail call double @llvm.fma.f64(double %76, double 0x3F8B678BBF2BAB09, double 0x3FCD4EAEF6010924)
  %78 = tail call double @llvm.fma.f64(double %76, double %77, double 0x3FEF497644EA8450)
  %79 = tail call double @llvm.fma.f64(double %76, double %78, double 0x3FF7475CD119BD6F)
  %80 = tail call double @llvm.fma.f64(double %76, double %79, double 0x3FE4401E8B005DFF)
  %81 = tail call double @llvm.fma.f64(double %76, double %80, double 0xBFB3C467E37DB0C8)
  %82 = fmul double %76, %81
  %83 = tail call double @llvm.fma.f64(double %76, double 0x3F6A5ABB57D0CF61, double 0x3FBAAE55D6537C88)
  %84 = tail call double @llvm.fma.f64(double %76, double %83, double 0x3FE89DFBE45050AF)
  %85 = tail call double @llvm.fma.f64(double %76, double %84, double 0x40010725A42B18F5)
  %86 = tail call double @llvm.fma.f64(double %76, double %85, double 0x4003A5D7C2BD619C)
  %87 = tail call double @llvm.fma.f64(double %76, double %86, double 1.000000e+00)
  %88 = fdiv double %82, %87
  %89 = tail call double @llvm.fma.f64(double %76, double -5.000000e-01, double %88)
  br label %90

90:                                               ; preds = %74, %54, %40
  %91 = phi double [ %75, %74 ], [ %38, %54 ], [ %38, %40 ]
  %92 = phi double [ %89, %74 ], [ %73, %54 ], [ %53, %40 ]
  %93 = fadd double %91, %92
  br label %155

94:                                               ; preds = %16
  %95 = icmp ult i32 %6, 1075838976
  br i1 %95, label %96, label %136

96:                                               ; preds = %94
  %97 = fptosi double %4 to i32
  %98 = sitofp i32 %97 to double
  %99 = fsub double %4, %98
  %100 = tail call double @llvm.fma.f64(double %99, double 0x3F00BFECDD17E945, double 0x3F5E26B67368F239)
  %101 = tail call double @llvm.fma.f64(double %99, double %100, double 0x3F9B481C7E939961)
  %102 = tail call double @llvm.fma.f64(double %99, double %101, double 0x3FC2BB9CBEE5F2F7)
  %103 = tail call double @llvm.fma.f64(double %99, double %102, double 0x3FD4D98F4F139F59)
  %104 = tail call double @llvm.fma.f64(double %99, double %103, double 0x3FCB848B36E20878)
  %105 = tail call double @llvm.fma.f64(double %99, double %104, double 0xBFB3C467E37DB0C8)
  %106 = fmul double %99, %105
  %107 = tail call double @llvm.fma.f64(double %99, double 0x3EDEBAF7A5B38140, double 0x3F497DDACA41A95B)
  %108 = tail call double @llvm.fma.f64(double %99, double %107, double 0x3F9317EA742ED475)
  %109 = tail call double @llvm.fma.f64(double %99, double %108, double 0x3FC601EDCCFBDF27)
  %110 = tail call double @llvm.fma.f64(double %99, double %109, double 0x3FE71A1893D3DCDC)
  %111 = tail call double @llvm.fma.f64(double %99, double %110, double 0x3FF645A762C4AB74)
  %112 = tail call double @llvm.fma.f64(double %99, double %111, double 1.000000e+00)
  %113 = fdiv double %106, %112
  %114 = tail call double @llvm.fma.f64(double %99, double 5.000000e-01, double %113)
  %115 = fadd double %99, 2.000000e+00
  %116 = fadd double %99, 3.000000e+00
  %117 = fadd double %99, 4.000000e+00
  %118 = fadd double %99, 5.000000e+00
  %119 = fadd double %99, 6.000000e+00
  %120 = icmp sgt i32 %97, 2
  %121 = select i1 %120, double %115, double 1.000000e+00
  %122 = icmp sgt i32 %97, 3
  %123 = select i1 %122, double %116, double 1.000000e+00
  %124 = fmul double %121, %123
  %125 = icmp sgt i32 %97, 4
  %126 = select i1 %125, double %117, double 1.000000e+00
  %127 = fmul double %126, %124
  %128 = icmp sgt i32 %97, 5
  %129 = select i1 %128, double %118, double 1.000000e+00
  %130 = fmul double %129, %127
  %131 = icmp sgt i32 %97, 6
  %132 = select i1 %131, double %119, double 1.000000e+00
  %133 = fmul double %132, %130
  %134 = tail call spir_func double @__ocml_log_f64(double noundef %133) #38
  %135 = fadd double %114, %134
  br label %155

136:                                              ; preds = %94
  %137 = icmp ult i32 %6, 1133510656
  br i1 %137, label %138, label %151

138:                                              ; preds = %136
  %139 = fdiv double 1.000000e+00, %4
  %140 = fmul double %139, %139
  %141 = tail call double @llvm.fma.f64(double %140, double 0xBF5AB89D0B9E43E4, double 0x3F4B67BA4CDAD5D1)
  %142 = tail call double @llvm.fma.f64(double %140, double %141, double 0xBF4380CB8C0FE741)
  %143 = tail call double @llvm.fma.f64(double %140, double %142, double 0x3F4A019F98CF38B6)
  %144 = tail call double @llvm.fma.f64(double %140, double %143, double 0xBF66C16C16B02E5C)
  %145 = tail call double @llvm.fma.f64(double %140, double %144, double 0x3FB555555555553B)
  %146 = tail call double @llvm.fma.f64(double %139, double %145, double 0x3FDACFE390C97D69)
  %147 = fadd double %4, -5.000000e-01
  %148 = tail call spir_func double @__ocml_log_f64(double noundef %4) #38
  %149 = fadd double %148, -1.000000e+00
  %150 = tail call double @llvm.fma.f64(double %147, double %149, double %146)
  br label %155

151:                                              ; preds = %136
  %152 = tail call spir_func double @__ocml_log_f64(double noundef %4) #38
  %153 = fneg double %4
  %154 = tail call double @llvm.fma.f64(double %4, double %152, double %153)
  br label %155

155:                                              ; preds = %151, %138, %96, %90, %8
  %156 = phi double [ %15, %8 ], [ %93, %90 ], [ %135, %96 ], [ %150, %138 ], [ %154, %151 ]
  %157 = fcmp ult double %0, 0.000000e+00
  br i1 %157, label %165, label %158

158:                                              ; preds = %155
  %159 = fcmp oeq double %0, 1.000000e+00
  %160 = fcmp oeq double %0, 2.000000e+00
  %161 = or i1 %159, %160
  %162 = select i1 %161, double 0.000000e+00, double %156
  %163 = fcmp une double %0, 0.000000e+00
  %164 = zext i1 %163 to i32
  br label %187

165:                                              ; preds = %155
  %166 = icmp ult i32 %6, 1127219200
  br i1 %166, label %167, label %187

167:                                              ; preds = %165
  %168 = icmp ugt i32 %6, 1020264448
  br i1 %168, label %169, label %187

169:                                              ; preds = %167
  %170 = tail call spir_func double @__ocml_sinpi_f64(double noundef %0) #38
  %171 = fmul double %170, %0
  %172 = tail call double @llvm.fabs.f64(double %171)
  %173 = fdiv double 0x400921FB54442D18, %172
  %174 = tail call spir_func double @__ocml_log_f64(double noundef %173) #38
  %175 = fsub double %174, %156
  %176 = fptosi double %0 to i64
  %177 = sitofp i64 %176 to double
  %178 = fsub double %0, %177
  %179 = bitcast double %4 to i64
  %180 = icmp eq i64 %179, 9218868437227405312
  %181 = select i1 %180, double 0.000000e+00, double %178
  %182 = fcmp oeq double %181, 0.000000e+00
  %183 = select i1 %182, double 0x7FF0000000000000, double %175
  %184 = fcmp olt double %170, 0.000000e+00
  %185 = select i1 %184, i32 -1, i32 1
  %186 = select i1 %182, i32 0, i32 %185
  br label %187

187:                                              ; preds = %169, %167, %165, %158
  %188 = phi i32 [ %164, %158 ], [ %186, %169 ], [ 0, %165 ], [ -1, %167 ]
  %189 = phi double [ %162, %158 ], [ %183, %169 ], [ %156, %165 ], [ %156, %167 ]
  %190 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noalias !58, !noundef !28
  %191 = icmp eq i8 %190, 0
  br i1 %191, label %192, label %206

192:                                              ; preds = %187
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %4, ptr %3, align 8, !tbaa !19, !noalias !58
  %193 = addrspacecast ptr %3 to ptr addrspace(4)
  %194 = load i128, ptr addrspace(4) %193, align 8, !tbaa !29, !noalias !58
  %195 = icmp ne i128 %194, 9218868437227405312
  %196 = and i128 %194, 9223372036854775807
  %197 = icmp ne i128 %196, 0
  %198 = and i1 %195, %197
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  %199 = fcmp uge double %0, 0.000000e+00
  %200 = icmp ult i32 %6, 1127219200
  %201 = or i1 %199, %200
  %202 = and i1 %201, %198
  %203 = select i1 %202, double %189, double 0x7FF0000000000000
  %204 = fcmp uno double %0, 0.000000e+00
  %205 = select i1 %204, double %0, double %203
  br label %206

206:                                              ; preds = %187, %192
  %207 = phi double [ %189, %187 ], [ %205, %192 ]
  store i32 %188, ptr %1, align 4, !tbaa !4
  ret double %207
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_log_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = fcmp olt double %0, 0x3FE5555555555555
  %4 = zext i1 %3 to i32
  %5 = tail call spir_func double @_Z5ldexpdi(double noundef %0, i32 noundef %4) #38
  %6 = fptrunc double %0 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %7 = addrspacecast ptr %2 to ptr addrspace(4)
  %8 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %6, ptr addrspace(4) noundef %7) #40
  %9 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %10 = sub nsw i32 %9, %4
  %11 = fadd double %5, -1.000000e+00
  %12 = fadd double %5, 1.000000e+00
  %13 = fadd double %12, -1.000000e+00
  %14 = fsub double %5, %13
  %15 = fptrunc double %12 to float
  %16 = call spir_func float @_Z12native_recipf(float noundef %15) #38
  %17 = fpext float %16 to double
  %18 = fneg double %12
  %19 = call double @llvm.fma.f64(double %18, double %17, double 1.000000e+00)
  %20 = call double @llvm.fma.f64(double %19, double %17, double %17)
  %21 = call double @llvm.fma.f64(double %18, double %20, double 1.000000e+00)
  %22 = call double @llvm.fma.f64(double %21, double %20, double %20)
  %23 = fmul double %11, %22
  %24 = fmul double %12, %23
  %25 = fneg double %24
  %26 = call double @llvm.fma.f64(double %23, double %12, double %25)
  %27 = call double @llvm.fma.f64(double %23, double %14, double %26)
  %28 = fadd double %24, %27
  %29 = fsub double %28, %24
  %30 = fsub double %11, %28
  %31 = fsub double %11, %30
  %32 = fsub double %31, %28
  %33 = fsub double %29, %27
  %34 = fadd double %33, %32
  %35 = fadd double %30, %34
  %36 = fmul double %22, %35
  %37 = fadd double %23, %36
  %38 = fsub double %37, %23
  %39 = fsub double %36, %38
  %40 = fmul double %37, %37
  %41 = call double @llvm.fma.f64(double %40, double 0x3FC3AB76BF559E2B, double 0x3FC385386B47B09A)
  %42 = call double @llvm.fma.f64(double %40, double %41, double 0x3FC7474DD7F4DF2E)
  %43 = call double @llvm.fma.f64(double %40, double %42, double 0x3FCC71C016291751)
  %44 = call double @llvm.fma.f64(double %40, double %43, double 0x3FD249249B27ACF1)
  %45 = call double @llvm.fma.f64(double %40, double %44, double 0x3FD99999998EF7B6)
  %46 = call double @llvm.fma.f64(double %40, double %45, double 0x3FE5555555555780)
  %47 = call spir_func double @_Z5ldexpdi(double noundef %37, i32 noundef 1) #38
  %48 = call spir_func double @_Z5ldexpdi(double noundef %39, i32 noundef 1) #38
  %49 = fmul double %37, %40
  %50 = fmul double %49, %46
  %51 = fadd double %47, %50
  %52 = fsub double %51, %47
  %53 = fsub double %50, %52
  %54 = fadd double %48, %53
  %55 = fadd double %51, %54
  %56 = fsub double %55, %51
  %57 = fsub double %54, %56
  %58 = sitofp i32 %10 to double
  %59 = fmul double %58, 0x3FE62E42FEFA39EF
  %60 = fneg double %59
  %61 = call double @llvm.fma.f64(double %58, double 0x3FE62E42FEFA39EF, double %60)
  %62 = call double @llvm.fma.f64(double %58, double 0x3C7ABC9E3B39803F, double %61)
  %63 = fadd double %59, %62
  %64 = fsub double %63, %59
  %65 = fsub double %62, %64
  %66 = fadd double %63, %55
  %67 = fsub double %66, %63
  %68 = fsub double %66, %67
  %69 = fsub double %63, %68
  %70 = fsub double %55, %67
  %71 = fadd double %70, %69
  %72 = fadd double %65, %57
  %73 = fsub double %72, %65
  %74 = fsub double %72, %73
  %75 = fsub double %65, %74
  %76 = fsub double %57, %73
  %77 = fadd double %76, %75
  %78 = fadd double %72, %71
  %79 = fadd double %66, %78
  %80 = fsub double %79, %66
  %81 = fsub double %78, %80
  %82 = fadd double %77, %81
  %83 = fadd double %79, %82
  %84 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %85 = icmp eq i8 %84, 0
  br i1 %85, label %86, label %94

86:                                               ; preds = %1
  %87 = call double @llvm.fabs.f64(double %0)
  %88 = fcmp oeq double %87, 0x7FF0000000000000
  %89 = select i1 %88, double %0, double %83
  %90 = fcmp olt double %0, 0.000000e+00
  %91 = select i1 %90, double 0x7FF8000000000000, double %89
  %92 = fcmp oeq double %0, 0.000000e+00
  %93 = select i1 %92, double 0xFFF0000000000000, double %91
  br label %94

94:                                               ; preds = %86, %1
  %95 = phi double [ %83, %1 ], [ %93, %86 ]
  ret double %95
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_sinpi_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca %struct.redret.8, align 8
  %4 = alloca %struct.scret, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %3) #39
  %5 = tail call double @llvm.fabs.f64(double %0)
  call spir_func void @__ocmlpriv_trigpired_f64(ptr dead_on_unwind nonnull writable sret(%struct.redret.8) align 8 %3, double noundef %5) #43
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #39
  %6 = load double, ptr %3, align 8, !tbaa !53
  call spir_func void @__ocmlpriv_sincospired_f64(ptr dead_on_unwind nonnull writable sret(%struct.scret) align 8 %4, double noundef %6) #43
  %7 = getelementptr inbounds %struct.redret.8, ptr %3, i64 0, i32 1
  %8 = load i32, ptr %7, align 8, !tbaa !55
  %9 = and i32 %8, 1
  %10 = icmp eq i32 %9, 0
  %11 = getelementptr inbounds %struct.scret, ptr %4, i64 0, i32 1
  %12 = load double, ptr %11, align 8
  %13 = load double, ptr %4, align 8
  %14 = select i1 %10, double %12, double %13
  %15 = bitcast double %14 to <2 x i32>
  %16 = icmp sgt i32 %8, 1
  %17 = select i1 %16, i32 -2147483648, i32 0
  %18 = bitcast double %0 to <2 x i32>
  %19 = extractelement <2 x i32> %18, i64 1
  %20 = and i32 %19, -2147483648
  %21 = xor i32 %17, %20
  %22 = extractelement <2 x i32> %15, i64 1
  %23 = xor i32 %21, %22
  %24 = insertelement <2 x i32> %15, i32 %23, i64 1
  %25 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %26 = icmp eq i8 %25, 0
  br i1 %26, label %27, label %35

27:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %0, ptr %2, align 8, !tbaa !19
  %28 = addrspacecast ptr %2 to ptr addrspace(4)
  %29 = load i128, ptr addrspace(4) %28, align 8, !tbaa !29
  switch i128 %29, label %31 [
    i128 9218868437227405312, label %30
    i128 18442240474082181120, label %30
  ]

30:                                               ; preds = %27, %27
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  br label %35

31:                                               ; preds = %27
  %32 = and i128 %29, 9221120237041090560
  %33 = icmp eq i128 %32, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %34 = select i1 %33, <2 x i32> %24, <2 x i32> <i32 0, i32 2146959360>
  br label %35

35:                                               ; preds = %31, %30, %1
  %36 = phi <2 x i32> [ %24, %1 ], [ <i32 0, i32 2146959360>, %30 ], [ %34, %31 ]
  %37 = bitcast <2 x i32> %36 to double
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %3) #39
  ret double %37
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_lgamma_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %3 = call spir_func float @__ocml_lgamma_r_f32(float noundef %0, ptr noundef nonnull %2) #40
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret float %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write)
define protected spir_func float @__ocml_lgamma_r_f32(float noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #30 {
  %3 = tail call float @llvm.fabs.f32(float %0)
  %4 = fcmp olt float %3, 1.562500e-02
  br i1 %4, label %5, label %12

5:                                                ; preds = %2
  %6 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef 0x3FD1513220000000, float noundef 0xBFD9A4D560000000) #38
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %6, float noundef 0x3FEA51A660000000) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %7, float noundef 0xBFE2788D00000000) #38
  %9 = tail call spir_func float @__ocml_log_f32(float noundef %3) #38
  %10 = fneg float %9
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %8, float noundef %10) #38
  br label %156

12:                                               ; preds = %2
  %13 = fcmp olt float %3, 2.000000e+00
  br i1 %13, label %14, label %94

14:                                               ; preds = %12
  %15 = fcmp ugt float %3, 0x3FECCCCCC0000000
  br i1 %15, label %25, label %16

16:                                               ; preds = %14
  %17 = tail call spir_func float @__ocml_log_f32(float noundef %3) #38
  %18 = fneg float %17
  %19 = fsub float 1.000000e+00, %3
  %20 = fcmp olt float %3, 0x3FE7694460000000
  %21 = fadd float %3, 0xBFDD8B6180000000
  %22 = select i1 %20, float %21, float %19
  %23 = zext i1 %20 to i32
  %24 = fcmp olt float %3, 0x3FCDA66120000000
  br i1 %24, label %76, label %34

25:                                               ; preds = %14
  %26 = fsub float 2.000000e+00, %3
  %27 = fcmp olt float %3, 0x3FFBB4A240000000
  %28 = fadd float %3, 0xBFF762D860000000
  %29 = select i1 %27, float %28, float %26
  %30 = select i1 %27, float 1.000000e+00, float %26
  %31 = fptosi float %30 to i32
  %32 = fcmp olt float %3, 0x3FF3AE1480000000
  %33 = fadd float %3, -1.000000e+00
  br i1 %32, label %76, label %34

34:                                               ; preds = %25, %16
  %35 = phi float [ %22, %16 ], [ %29, %25 ]
  %36 = phi i32 [ %23, %16 ], [ %31, %25 ]
  %37 = phi float [ %18, %16 ], [ 0.000000e+00, %25 ]
  switch i32 %36, label %156 [
    i32 0, label %38
    i32 1, label %54
    i32 2, label %76
  ]

38:                                               ; preds = %34
  %39 = fmul float %35, %35
  %40 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %39, float noundef 0x3EFA707440000000, float noundef 0x3F2CF2ECE0000000) #38
  %41 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %39, float noundef %40, float noundef 0x3F538A9420000000) #38
  %42 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %39, float noundef %41, float noundef 0x3F7E404FC0000000) #38
  %43 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %39, float noundef %42, float noundef 0x3FB13E0020000000) #38
  %44 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %39, float noundef %43, float noundef 0x3FB3C467E0000000) #38
  %45 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %39, float noundef 0x3F07858EA0000000, float noundef 0x3F1C5088A0000000) #38
  %46 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %39, float noundef %45, float noundef 0x3F40B6C680000000) #38
  %47 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %39, float noundef %46, float noundef 0x3F67ADD8C0000000) #38
  %48 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %39, float noundef %47, float noundef 0x3F951322A0000000) #38
  %49 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %39, float noundef %48, float noundef 0x3FD4A34CC0000000) #38
  %50 = fmul float %39, %49
  %51 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %35, float noundef %44, float noundef %50) #38
  %52 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %35, float noundef -5.000000e-01, float noundef %51) #38
  %53 = fadd float %37, %52
  br label %156

54:                                               ; preds = %34
  %55 = fmul float %35, %35
  %56 = fmul float %35, %55
  %57 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef 0x3F34AF6D60000000, float noundef 0xBF56FE8EC0000000) #38
  %58 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef %57, float noundef 0x3F78FCE0E0000000) #38
  %59 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef %58, float noundef 0xBFA0C9A8E0000000) #38
  %60 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef %59, float noundef 0x3FDEF72BC0000000) #38
  %61 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef 0xBF347F24E0000000, float noundef 0x3F4CDF0CE0000000) #38
  %62 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef %61, float noundef 0xBF6E2EFFC0000000) #38
  %63 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef %62, float noundef 0x3F9266E7A0000000) #38
  %64 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef %63, float noundef 0xBFC2E42780000000) #38
  %65 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef 0x3F35FD3EE0000000, float noundef 0xBF41A610A0000000) #38
  %66 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef %65, float noundef 0x3F6282D320000000) #38
  %67 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef %66, float noundef 0xBF851F9FC0000000) #38
  %68 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef %67, float noundef 0x3FB08B42A0000000) #38
  %69 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %35, float noundef %68, float noundef %64) #38
  %70 = fneg float %69
  %71 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %56, float noundef %70, float noundef 0xBC50C7CAA0000000) #38
  %72 = fneg float %71
  %73 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %55, float noundef %60, float noundef %72) #38
  %74 = fadd float %73, 0xBFBF19B9C0000000
  %75 = fadd float %37, %74
  br label %156

76:                                               ; preds = %34, %25, %16
  %77 = phi float [ %37, %34 ], [ %18, %16 ], [ 0.000000e+00, %25 ]
  %78 = phi float [ %35, %34 ], [ %3, %16 ], [ %33, %25 ]
  %79 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %78, float noundef 0x3F8B678BC0000000, float noundef 0x3FCD4EAF00000000) #38
  %80 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %78, float noundef %79, float noundef 0x3FEF497640000000) #38
  %81 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %78, float noundef %80, float noundef 0x3FF7475CE0000000) #38
  %82 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %78, float noundef %81, float noundef 0x3FE4401E80000000) #38
  %83 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %78, float noundef %82, float noundef 0xBFB3C467E0000000) #38
  %84 = fmul float %78, %83
  %85 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %78, float noundef 0x3F6A5ABB60000000, float noundef 0x3FBAAE55E0000000) #38
  %86 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %78, float noundef %85, float noundef 0x3FE89DFBE0000000) #38
  %87 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %78, float noundef %86, float noundef 0x40010725A0000000) #38
  %88 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %78, float noundef %87, float noundef 0x4003A5D7C0000000) #38
  %89 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %78, float noundef %88, float noundef 1.000000e+00) #38
  %90 = tail call spir_func float @_Z12native_recipf(float noundef %89) #38
  %91 = fmul float %84, %90
  %92 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %78, float noundef -5.000000e-01, float noundef %91) #38
  %93 = fadd float %77, %92
  br label %156

94:                                               ; preds = %12
  %95 = fcmp olt float %3, 8.000000e+00
  br i1 %95, label %96, label %137

96:                                               ; preds = %94
  %97 = fptosi float %3 to i32
  %98 = sitofp i32 %97 to float
  %99 = fsub float %3, %98
  %100 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef 0x3F00BFECE0000000, float noundef 0x3F5E26B680000000) #38
  %101 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef %100, float noundef 0x3F9B481C80000000) #38
  %102 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef %101, float noundef 0x3FC2BB9CC0000000) #38
  %103 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef %102, float noundef 0x3FD4D98F40000000) #38
  %104 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef %103, float noundef 0x3FCB848B40000000) #38
  %105 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef %104, float noundef 0xBFB3C467E0000000) #38
  %106 = fmul float %99, %105
  %107 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef 0x3EDEBAF7A0000000, float noundef 0x3F497DDAC0000000) #38
  %108 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef %107, float noundef 0x3F9317EA80000000) #38
  %109 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef %108, float noundef 0x3FC601EDC0000000) #38
  %110 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef %109, float noundef 0x3FE71A18A0000000) #38
  %111 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef %110, float noundef 0x3FF645A760000000) #38
  %112 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef %111, float noundef 1.000000e+00) #38
  %113 = tail call spir_func float @_Z12native_recipf(float noundef %112) #38
  %114 = fmul float %106, %113
  %115 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %99, float noundef 5.000000e-01, float noundef %114) #38
  %116 = fadd float %99, 2.000000e+00
  %117 = fadd float %99, 3.000000e+00
  %118 = fadd float %99, 4.000000e+00
  %119 = fadd float %99, 5.000000e+00
  %120 = fadd float %99, 6.000000e+00
  %121 = icmp sgt i32 %97, 2
  %122 = select i1 %121, float %116, float 1.000000e+00
  %123 = icmp sgt i32 %97, 3
  %124 = select i1 %123, float %117, float 1.000000e+00
  %125 = fmul float %122, %124
  %126 = icmp sgt i32 %97, 4
  %127 = select i1 %126, float %118, float 1.000000e+00
  %128 = fmul float %127, %125
  %129 = icmp sgt i32 %97, 5
  %130 = select i1 %129, float %119, float 1.000000e+00
  %131 = fmul float %130, %128
  %132 = icmp sgt i32 %97, 6
  %133 = select i1 %132, float %120, float 1.000000e+00
  %134 = fmul float %133, %131
  %135 = tail call spir_func float @__ocml_log_f32(float noundef %134) #38
  %136 = fadd float %115, %135
  br label %156

137:                                              ; preds = %94
  %138 = fcmp olt float %3, 0x4390000000000000
  br i1 %138, label %139, label %152

139:                                              ; preds = %137
  %140 = tail call spir_func float @_Z12native_recipf(float noundef %3) #38
  %141 = fmul float %140, %140
  %142 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %141, float noundef 0xBF5AB89D00000000, float noundef 0x3F4B67BA40000000) #38
  %143 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %141, float noundef %142, float noundef 0xBF4380CB80000000) #38
  %144 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %141, float noundef %143, float noundef 0x3F4A019FA0000000) #38
  %145 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %141, float noundef %144, float noundef 0xBF66C16C20000000) #38
  %146 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %141, float noundef %145, float noundef 0x3FB5555560000000) #38
  %147 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %140, float noundef %146, float noundef 0x3FDACFE3A0000000) #38
  %148 = fadd float %3, -5.000000e-01
  %149 = tail call spir_func float @__ocml_log_f32(float noundef %3) #38
  %150 = fadd float %149, -1.000000e+00
  %151 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %148, float noundef %150, float noundef %147) #38
  br label %156

152:                                              ; preds = %137
  %153 = tail call spir_func float @__ocml_log_f32(float noundef %3) #38
  %154 = fneg float %3
  %155 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %153, float noundef %154) #38
  br label %156

156:                                              ; preds = %152, %139, %96, %76, %54, %38, %34, %5
  %157 = phi float [ %11, %5 ], [ %136, %96 ], [ %151, %139 ], [ %155, %152 ], [ %37, %34 ], [ %93, %76 ], [ %75, %54 ], [ %53, %38 ]
  %158 = fcmp oge float %0, 0.000000e+00
  br i1 %158, label %159, label %166

159:                                              ; preds = %156
  %160 = fcmp oeq float %0, 1.000000e+00
  %161 = fcmp oeq float %0, 2.000000e+00
  %162 = or i1 %160, %161
  %163 = select i1 %162, float 0.000000e+00, float %157
  %164 = fcmp une float %0, 0.000000e+00
  %165 = zext i1 %164 to i32
  br label %188

166:                                              ; preds = %156
  %167 = fcmp olt float %3, 0x4160000000000000
  br i1 %167, label %168, label %188

168:                                              ; preds = %166
  %169 = fcmp ogt float %3, 0x3EA0000000000000
  br i1 %169, label %170, label %188

170:                                              ; preds = %168
  %171 = tail call spir_func float @__ocml_sinpi_f32(float noundef %0) #38
  %172 = fmul float %171, %0
  %173 = tail call float @llvm.fabs.f32(float %172)
  %174 = fdiv float 0x400921FB60000000, %173, !fpmath !15
  %175 = tail call spir_func float @__ocml_log_f32(float noundef %174) #38
  %176 = fsub float %175, %157
  %177 = fptosi float %0 to i32
  %178 = sitofp i32 %177 to float
  %179 = fsub float %0, %178
  %180 = bitcast float %3 to i32
  %181 = icmp eq i32 %180, 2139095040
  %182 = select i1 %181, float 0.000000e+00, float %179
  %183 = fcmp oeq float %182, 0.000000e+00
  %184 = select i1 %183, float 0x7FF0000000000000, float %176
  %185 = fcmp olt float %171, 0.000000e+00
  %186 = select i1 %185, i32 -1, i32 1
  %187 = select i1 %183, i32 0, i32 %186
  br label %188

188:                                              ; preds = %170, %168, %166, %159
  %189 = phi i32 [ %165, %159 ], [ %187, %170 ], [ 0, %166 ], [ -1, %168 ]
  %190 = phi float [ %163, %159 ], [ %184, %170 ], [ %157, %166 ], [ %157, %168 ]
  %191 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noalias !61, !noundef !28
  %192 = icmp eq i8 %191, 0
  br i1 %192, label %193, label %201

193:                                              ; preds = %188
  %194 = tail call i1 @llvm.is.fpclass.f32(float %0, i32 612)
  %195 = fcmp olt float %3, 0x4160000000000000
  %196 = or i1 %158, %195
  %197 = select i1 %196, float %190, float 0x7FF0000000000000
  %198 = select i1 %194, float 0x7FF0000000000000, float %197
  %199 = fcmp uno float %0, 0.000000e+00
  %200 = select i1 %199, float %0, float %198
  br label %201

201:                                              ; preds = %188, %193
  %202 = phi float [ %190, %188 ], [ %200, %193 ]
  store i32 %189, ptr %1, align 4, !tbaa !4
  ret float %202
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_log_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca float, align 8
  %4 = alloca float, align 8
  %5 = alloca float, align 8
  %6 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %7 = icmp eq i8 %6, 0
  %8 = load i8, ptr addrspace(2) @__oclc_unsafe_math_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %9 = icmp eq i8 %8, 0
  br i1 %7, label %43, label %10

10:                                               ; preds = %1
  %11 = tail call float @llvm.log2.f32(float %0)
  br i1 %9, label %14, label %12

12:                                               ; preds = %10
  %13 = fmul float %11, 0x3FE62E4300000000
  br label %100

14:                                               ; preds = %10
  %15 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %16 = freeze i32 %15
  %17 = icmp sgt i32 %16, 8999
  br i1 %17, label %19, label %18

18:                                               ; preds = %14
  switch i32 %16, label %25 [
    i32 8001, label %19
    i32 7001, label %19
  ]

19:                                               ; preds = %18, %18, %14
  %20 = fmul float %11, 0x3FE62E42E0000000
  %21 = fneg float %20
  %22 = tail call float @llvm.fma.f32(float %11, float 0x3FE62E42E0000000, float %21)
  %23 = tail call float @llvm.fma.f32(float %11, float 0x3E6EFA39E0000000, float %22)
  %24 = fadd float %20, %23
  br label %34

25:                                               ; preds = %18
  %26 = bitcast float %11 to i32
  %27 = and i32 %26, -4096
  %28 = bitcast i32 %27 to float
  %29 = fsub float %11, %28
  %30 = fmul float %29, 0x3F00BFBE80000000
  %31 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %28, float noundef 0x3F00BFBE80000000, float noundef %30) #38
  %32 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %29, float noundef 0x3FE62E0000000000, float noundef %31) #38
  %33 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %28, float noundef 0x3FE62E0000000000, float noundef %32) #38
  br label %34

34:                                               ; preds = %25, %19
  %35 = phi float [ %24, %19 ], [ %33, %25 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  store float %11, ptr %5, align 8, !tbaa !16
  %36 = addrspacecast ptr %5 to ptr addrspace(4)
  %37 = load i64, ptr addrspace(4) %36, align 8, !tbaa !12
  switch i64 %37, label %38 [
    i64 2139095040, label %41
    i64 -8388608, label %41
  ]

38:                                               ; preds = %34
  %39 = and i64 %37, 2143289344
  %40 = icmp eq i64 %39, 0
  br i1 %40, label %42, label %41

41:                                               ; preds = %34, %34, %38
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  br label %100

42:                                               ; preds = %38
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  br label %100

43:                                               ; preds = %1
  br i1 %9, label %57, label %44

44:                                               ; preds = %43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  store float %0, ptr %4, align 8, !tbaa !16
  %45 = addrspacecast ptr %4 to ptr addrspace(4)
  %46 = load i64, ptr addrspace(4) %45, align 8, !tbaa !12
  %47 = and i64 %46, 2139095040
  %48 = icmp ne i64 %47, 0
  %49 = and i64 %46, 8388607
  %50 = icmp eq i64 %49, 0
  %51 = or i1 %48, %50
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  %52 = select i1 %51, float 1.000000e+00, float 0x41F0000000000000
  %53 = fmul float %52, %0
  %54 = tail call float @llvm.log2.f32(float %53)
  %55 = select i1 %51, float 0.000000e+00, float 0xC0362E4300000000
  %56 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %54, float noundef 0x3FE62E4300000000, float noundef %55) #38
  br label %100

57:                                               ; preds = %43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %0, ptr %3, align 8, !tbaa !16
  %58 = addrspacecast ptr %3 to ptr addrspace(4)
  %59 = load i64, ptr addrspace(4) %58, align 8, !tbaa !12
  %60 = and i64 %59, 2139095040
  %61 = icmp ne i64 %60, 0
  %62 = and i64 %59, 8388607
  %63 = icmp eq i64 %62, 0
  %64 = or i1 %61, %63
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %65 = select i1 %64, float 1.000000e+00, float 0x41F0000000000000
  %66 = fmul float %65, %0
  %67 = tail call float @llvm.log2.f32(float %66)
  %68 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %69 = freeze i32 %68
  %70 = icmp sgt i32 %69, 8999
  br i1 %70, label %72, label %71

71:                                               ; preds = %57
  switch i32 %69, label %78 [
    i32 8001, label %72
    i32 7001, label %72
  ]

72:                                               ; preds = %71, %71, %57
  %73 = fmul float %67, 0x3FE62E42E0000000
  %74 = fneg float %73
  %75 = tail call float @llvm.fma.f32(float %67, float 0x3FE62E42E0000000, float %74)
  %76 = tail call float @llvm.fma.f32(float %67, float 0x3E6EFA39E0000000, float %75)
  %77 = fadd float %73, %76
  br label %87

78:                                               ; preds = %71
  %79 = bitcast float %67 to i32
  %80 = and i32 %79, -4096
  %81 = bitcast i32 %80 to float
  %82 = fsub float %67, %81
  %83 = fmul float %82, 0x3F00BFBE80000000
  %84 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %81, float noundef 0x3F00BFBE80000000, float noundef %83) #38
  %85 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %82, float noundef 0x3FE62E0000000000, float noundef %84) #38
  %86 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %81, float noundef 0x3FE62E0000000000, float noundef %85) #38
  br label %87

87:                                               ; preds = %78, %72
  %88 = phi float [ %77, %72 ], [ %86, %78 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %67, ptr %2, align 8, !tbaa !16
  %89 = addrspacecast ptr %2 to ptr addrspace(4)
  %90 = load i64, ptr addrspace(4) %89, align 8, !tbaa !12
  switch i64 %90, label %91 [
    i64 2139095040, label %94
    i64 -8388608, label %94
  ]

91:                                               ; preds = %87
  %92 = and i64 %90, 2143289344
  %93 = icmp eq i64 %92, 0
  br i1 %93, label %95, label %94

94:                                               ; preds = %87, %87, %91
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %96

95:                                               ; preds = %91
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %96

96:                                               ; preds = %94, %95
  %97 = phi float [ %88, %95 ], [ %67, %94 ]
  %98 = select i1 %64, float 0.000000e+00, float 0x40362E4300000000
  %99 = fsub float %97, %98
  br label %100

100:                                              ; preds = %42, %41, %96, %44, %12
  %101 = phi float [ %13, %12 ], [ %56, %44 ], [ %99, %96 ], [ %35, %42 ], [ %11, %41 ]
  ret float %101
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_sinpi_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca %struct.redret.0, align 4
  %4 = alloca %struct.scret.1, align 4
  %5 = tail call float @llvm.fabs.f32(float %0)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #39
  call spir_func void @__ocmlpriv_trigpired_f32(ptr dead_on_unwind nonnull writable sret(%struct.redret.0) align 4 %3, float noundef %5) #43
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #39
  %6 = load float, ptr %3, align 4, !tbaa !38
  call spir_func void @__ocmlpriv_sincospired_f32(ptr dead_on_unwind nonnull writable sret(%struct.scret.1) align 4 %4, float noundef %6) #43
  %7 = getelementptr inbounds %struct.redret.0, ptr %3, i64 0, i32 1
  %8 = load i32, ptr %7, align 4, !tbaa !40
  %9 = and i32 %8, 1
  %10 = icmp eq i32 %9, 0
  %11 = load float, ptr %4, align 4
  %12 = getelementptr inbounds %struct.scret.1, ptr %4, i64 0, i32 1
  %13 = load float, ptr %12, align 4
  %14 = select i1 %10, float %11, float %13
  %15 = bitcast float %14 to i32
  %16 = icmp sgt i32 %8, 1
  %17 = select i1 %16, i32 -2147483648, i32 0
  %18 = bitcast float %0 to i32
  %19 = bitcast float %5 to i32
  %20 = xor i32 %19, %18
  %21 = xor i32 %20, %17
  %22 = xor i32 %21, %15
  %23 = bitcast i32 %22 to float
  %24 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %26, label %40

26:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %5, ptr %2, align 8, !tbaa !16
  %27 = addrspacecast ptr %2 to ptr addrspace(4)
  %28 = load i64, ptr addrspace(4) %27, align 8, !tbaa !12
  %29 = and i64 %28, 2147483647
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %32

31:                                               ; preds = %26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %40

32:                                               ; preds = %26
  %33 = and i64 %28, 2139095040
  %34 = icmp ne i64 %33, 0
  %35 = and i64 %28, 8388607
  %36 = icmp eq i64 %35, 0
  %37 = or i1 %34, %36
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %38 = freeze i1 %37
  %39 = select i1 %38, float 0x7FF8000000000000, float %23
  br label %40

40:                                               ; preds = %32, %31, %1
  %41 = phi float [ %23, %1 ], [ %23, %31 ], [ %39, %32 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #39
  ret float %41
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_lgamma_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = extractelement <2 x half> %0, i64 0
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %5 = call spir_func half @__ocml_lgamma_r_f16(half noundef %4, ptr noundef nonnull %3) #40
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %8 = call spir_func half @__ocml_lgamma_r_f16(half noundef %7, ptr noundef nonnull %2) #40
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %9 = insertelement <2 x half> %6, half %8, i64 1
  ret <2 x half> %9
}

; Function Attrs: convergent norecurse nounwind
define protected spir_func half @__ocml_lgamma_r_f16(half noundef %0, ptr noundef %1) local_unnamed_addr #35 {
  %3 = fpext half %0 to float
  %4 = tail call spir_func float @__ocml_lgamma_r_f32(float noundef %3, ptr noundef %1) #40
  %5 = fptrunc float %4 to half
  ret half %5
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_lgamma_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %3 = call spir_func half @__ocml_lgamma_r_f16(half noundef %0, ptr noundef nonnull %2) #40
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret half %3
}

; Function Attrs: convergent norecurse nounwind
define protected spir_func <2 x half> @__ocml_lgamma_r_2f16(<2 x half> noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #35 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %5 = extractelement <2 x half> %0, i64 0
  %6 = fpext half %5 to float
  %7 = call spir_func float @__ocml_lgamma_r_f32(float noundef %6, ptr noundef nonnull %3) #40
  %8 = fptrunc float %7 to half
  %9 = insertelement <2 x half> poison, half %8, i64 0
  %10 = extractelement <2 x half> %0, i64 1
  %11 = fpext half %10 to float
  %12 = call spir_func float @__ocml_lgamma_r_f32(float noundef %11, ptr noundef nonnull %4) #40
  %13 = fptrunc float %12 to half
  %14 = insertelement <2 x half> %9, half %13, i64 1
  %15 = load i32, ptr %3, align 4, !tbaa !4
  %16 = insertelement <2 x i32> poison, i32 %15, i64 0
  %17 = load i32, ptr %4, align 4, !tbaa !4
  %18 = insertelement <2 x i32> %16, i32 %17, i64 1
  store <2 x i32> %18, ptr %1, align 8, !tbaa !14
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  ret <2 x half> %14
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_log10_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = fcmp olt double %0, 0x3FE5555555555555
  %4 = zext i1 %3 to i32
  %5 = tail call spir_func double @_Z5ldexpdi(double noundef %0, i32 noundef %4) #38
  %6 = fptrunc double %0 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %7 = addrspacecast ptr %2 to ptr addrspace(4)
  %8 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %6, ptr addrspace(4) noundef %7) #40
  %9 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %10 = sub nsw i32 %9, %4
  %11 = fadd double %5, -1.000000e+00
  %12 = fadd double %5, 1.000000e+00
  %13 = fadd double %12, -1.000000e+00
  %14 = fsub double %5, %13
  %15 = fptrunc double %12 to float
  %16 = call spir_func float @_Z12native_recipf(float noundef %15) #38
  %17 = fpext float %16 to double
  %18 = fneg double %12
  %19 = call double @llvm.fma.f64(double %18, double %17, double 1.000000e+00)
  %20 = call double @llvm.fma.f64(double %19, double %17, double %17)
  %21 = call double @llvm.fma.f64(double %18, double %20, double 1.000000e+00)
  %22 = call double @llvm.fma.f64(double %21, double %20, double %20)
  %23 = fmul double %11, %22
  %24 = fmul double %12, %23
  %25 = fneg double %24
  %26 = call double @llvm.fma.f64(double %23, double %12, double %25)
  %27 = call double @llvm.fma.f64(double %23, double %14, double %26)
  %28 = fadd double %24, %27
  %29 = fsub double %28, %24
  %30 = fsub double %11, %28
  %31 = fsub double %11, %30
  %32 = fsub double %31, %28
  %33 = fsub double %29, %27
  %34 = fadd double %33, %32
  %35 = fadd double %30, %34
  %36 = fmul double %22, %35
  %37 = fadd double %23, %36
  %38 = fsub double %37, %23
  %39 = fsub double %36, %38
  %40 = fmul double %37, %37
  %41 = call double @llvm.fma.f64(double %40, double 0x3FC3AB76BF559E2B, double 0x3FC385386B47B09A)
  %42 = call double @llvm.fma.f64(double %40, double %41, double 0x3FC7474DD7F4DF2E)
  %43 = call double @llvm.fma.f64(double %40, double %42, double 0x3FCC71C016291751)
  %44 = call double @llvm.fma.f64(double %40, double %43, double 0x3FD249249B27ACF1)
  %45 = call double @llvm.fma.f64(double %40, double %44, double 0x3FD99999998EF7B6)
  %46 = call double @llvm.fma.f64(double %40, double %45, double 0x3FE5555555555780)
  %47 = call spir_func double @_Z5ldexpdi(double noundef %37, i32 noundef 1) #38
  %48 = call spir_func double @_Z5ldexpdi(double noundef %39, i32 noundef 1) #38
  %49 = fmul double %37, %40
  %50 = fmul double %49, %46
  %51 = fadd double %47, %50
  %52 = fsub double %51, %47
  %53 = fsub double %50, %52
  %54 = fadd double %48, %53
  %55 = fadd double %51, %54
  %56 = fsub double %55, %51
  %57 = fsub double %54, %56
  %58 = sitofp i32 %10 to double
  %59 = fmul double %58, 0x3FD34413509F79FF
  %60 = fneg double %59
  %61 = call double @llvm.fma.f64(double %58, double 0x3FD34413509F79FF, double %60)
  %62 = call double @llvm.fma.f64(double %58, double 0xBC49DC1DA994FD21, double %61)
  %63 = fadd double %59, %62
  %64 = fsub double %63, %59
  %65 = fsub double %62, %64
  %66 = fmul double %55, 0x3FDBCB7B1526E50E
  %67 = fneg double %66
  %68 = call double @llvm.fma.f64(double %55, double 0x3FDBCB7B1526E50E, double %67)
  %69 = call double @llvm.fma.f64(double %57, double 0x3FDBCB7B1526E50E, double %68)
  %70 = call double @llvm.fma.f64(double %55, double 0x3C695355BAAAFAD3, double %69)
  %71 = fadd double %66, %70
  %72 = fsub double %71, %66
  %73 = fsub double %70, %72
  %74 = fadd double %63, %71
  %75 = fsub double %74, %63
  %76 = fsub double %74, %75
  %77 = fsub double %63, %76
  %78 = fsub double %71, %75
  %79 = fadd double %78, %77
  %80 = fadd double %65, %73
  %81 = fsub double %80, %65
  %82 = fsub double %80, %81
  %83 = fsub double %65, %82
  %84 = fsub double %73, %81
  %85 = fadd double %84, %83
  %86 = fadd double %80, %79
  %87 = fadd double %74, %86
  %88 = fsub double %87, %74
  %89 = fsub double %86, %88
  %90 = fadd double %85, %89
  %91 = fadd double %87, %90
  %92 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %93 = icmp eq i8 %92, 0
  br i1 %93, label %94, label %102

94:                                               ; preds = %1
  %95 = call double @llvm.fabs.f64(double %0)
  %96 = fcmp oeq double %95, 0x7FF0000000000000
  %97 = select i1 %96, double %0, double %91
  %98 = fcmp olt double %0, 0.000000e+00
  %99 = select i1 %98, double 0x7FF8000000000000, double %97
  %100 = fcmp oeq double %0, 0.000000e+00
  %101 = select i1 %100, double 0xFFF0000000000000, double %99
  br label %102

102:                                              ; preds = %94, %1
  %103 = phi double [ %91, %1 ], [ %101, %94 ]
  ret double %103
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_log10_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca float, align 8
  %4 = alloca float, align 8
  %5 = alloca float, align 8
  %6 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %7 = icmp eq i8 %6, 0
  %8 = load i8, ptr addrspace(2) @__oclc_unsafe_math_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %9 = icmp eq i8 %8, 0
  br i1 %7, label %43, label %10

10:                                               ; preds = %1
  %11 = tail call float @llvm.log2.f32(float %0)
  br i1 %9, label %14, label %12

12:                                               ; preds = %10
  %13 = fmul float %11, 0x3FD3441360000000
  br label %100

14:                                               ; preds = %10
  %15 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %16 = freeze i32 %15
  %17 = icmp sgt i32 %16, 8999
  br i1 %17, label %19, label %18

18:                                               ; preds = %14
  switch i32 %16, label %25 [
    i32 8001, label %19
    i32 7001, label %19
  ]

19:                                               ; preds = %18, %18, %14
  %20 = fmul float %11, 0x3FD3441340000000
  %21 = fneg float %20
  %22 = tail call float @llvm.fma.f32(float %11, float 0x3FD3441340000000, float %21)
  %23 = tail call float @llvm.fma.f32(float %11, float 0x3E509F79E0000000, float %22)
  %24 = fadd float %20, %23
  br label %34

25:                                               ; preds = %18
  %26 = bitcast float %11 to i32
  %27 = and i32 %26, -4096
  %28 = bitcast i32 %27 to float
  %29 = fsub float %11, %28
  %30 = fmul float %29, 0x3ED3509F60000000
  %31 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %28, float noundef 0x3ED3509F60000000, float noundef %30) #38
  %32 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %29, float noundef 0x3FD3440000000000, float noundef %31) #38
  %33 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %28, float noundef 0x3FD3440000000000, float noundef %32) #38
  br label %34

34:                                               ; preds = %25, %19
  %35 = phi float [ %24, %19 ], [ %33, %25 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5)
  store float %11, ptr %5, align 8, !tbaa !16
  %36 = addrspacecast ptr %5 to ptr addrspace(4)
  %37 = load i64, ptr addrspace(4) %36, align 8, !tbaa !12
  switch i64 %37, label %38 [
    i64 2139095040, label %41
    i64 -8388608, label %41
  ]

38:                                               ; preds = %34
  %39 = and i64 %37, 2143289344
  %40 = icmp eq i64 %39, 0
  br i1 %40, label %42, label %41

41:                                               ; preds = %34, %34, %38
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  br label %100

42:                                               ; preds = %38
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5)
  br label %100

43:                                               ; preds = %1
  br i1 %9, label %57, label %44

44:                                               ; preds = %43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  store float %0, ptr %4, align 8, !tbaa !16
  %45 = addrspacecast ptr %4 to ptr addrspace(4)
  %46 = load i64, ptr addrspace(4) %45, align 8, !tbaa !12
  %47 = and i64 %46, 2139095040
  %48 = icmp ne i64 %47, 0
  %49 = and i64 %46, 8388607
  %50 = icmp eq i64 %49, 0
  %51 = or i1 %48, %50
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  %52 = select i1 %51, float 1.000000e+00, float 0x41F0000000000000
  %53 = fmul float %52, %0
  %54 = tail call float @llvm.log2.f32(float %53)
  %55 = select i1 %51, float 0.000000e+00, float 0xC023441360000000
  %56 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %54, float noundef 0x3FD3441360000000, float noundef %55) #38
  br label %100

57:                                               ; preds = %43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %0, ptr %3, align 8, !tbaa !16
  %58 = addrspacecast ptr %3 to ptr addrspace(4)
  %59 = load i64, ptr addrspace(4) %58, align 8, !tbaa !12
  %60 = and i64 %59, 2139095040
  %61 = icmp ne i64 %60, 0
  %62 = and i64 %59, 8388607
  %63 = icmp eq i64 %62, 0
  %64 = or i1 %61, %63
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %65 = select i1 %64, float 1.000000e+00, float 0x41F0000000000000
  %66 = fmul float %65, %0
  %67 = tail call float @llvm.log2.f32(float %66)
  %68 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %69 = freeze i32 %68
  %70 = icmp sgt i32 %69, 8999
  br i1 %70, label %72, label %71

71:                                               ; preds = %57
  switch i32 %69, label %78 [
    i32 8001, label %72
    i32 7001, label %72
  ]

72:                                               ; preds = %71, %71, %57
  %73 = fmul float %67, 0x3FD3441340000000
  %74 = fneg float %73
  %75 = tail call float @llvm.fma.f32(float %67, float 0x3FD3441340000000, float %74)
  %76 = tail call float @llvm.fma.f32(float %67, float 0x3E509F79E0000000, float %75)
  %77 = fadd float %73, %76
  br label %87

78:                                               ; preds = %71
  %79 = bitcast float %67 to i32
  %80 = and i32 %79, -4096
  %81 = bitcast i32 %80 to float
  %82 = fsub float %67, %81
  %83 = fmul float %82, 0x3ED3509F60000000
  %84 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %81, float noundef 0x3ED3509F60000000, float noundef %83) #38
  %85 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %82, float noundef 0x3FD3440000000000, float noundef %84) #38
  %86 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %81, float noundef 0x3FD3440000000000, float noundef %85) #38
  br label %87

87:                                               ; preds = %78, %72
  %88 = phi float [ %77, %72 ], [ %86, %78 ]
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %67, ptr %2, align 8, !tbaa !16
  %89 = addrspacecast ptr %2 to ptr addrspace(4)
  %90 = load i64, ptr addrspace(4) %89, align 8, !tbaa !12
  switch i64 %90, label %91 [
    i64 2139095040, label %94
    i64 -8388608, label %94
  ]

91:                                               ; preds = %87
  %92 = and i64 %90, 2143289344
  %93 = icmp eq i64 %92, 0
  br i1 %93, label %95, label %94

94:                                               ; preds = %87, %87, %91
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %96

95:                                               ; preds = %91
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %96

96:                                               ; preds = %94, %95
  %97 = phi float [ %88, %95 ], [ %67, %94 ]
  %98 = select i1 %64, float 0.000000e+00, float 0x4023441360000000
  %99 = fsub float %97, %98
  br label %100

100:                                              ; preds = %42, %41, %96, %44, %12
  %101 = phi float [ %13, %12 ], [ %56, %44 ], [ %99, %96 ], [ %35, %42 ], [ %11, %41 ]
  ret float %101
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_log10_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call float @llvm.log2.f32(float %3)
  %5 = fmul float %4, 0x3FD3441360000000
  %6 = fptrunc float %5 to half
  %7 = insertelement <2 x half> poison, half %6, i64 0
  %8 = extractelement <2 x half> %0, i64 1
  %9 = fpext half %8 to float
  %10 = tail call float @llvm.log2.f32(float %9)
  %11 = fmul float %10, 0x3FD3441360000000
  %12 = fptrunc float %11 to half
  %13 = insertelement <2 x half> %7, half %12, i64 1
  ret <2 x half> %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_log10_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = fpext half %0 to float
  %3 = tail call float @llvm.log2.f32(float %2)
  %4 = fmul float %3, 0x3FD3441360000000
  %5 = fptrunc float %4 to half
  ret half %5
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_log1p_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = fadd double %0, 1.000000e+00
  %4 = fadd double %3, -1.000000e+00
  %5 = fsub double %4, %3
  %6 = fadd double %5, 1.000000e+00
  %7 = fsub double %0, %4
  %8 = fadd double %7, %6
  %9 = insertelement <2 x double> poison, double %8, i64 0
  %10 = insertelement <2 x double> %9, double %3, i64 1
  %11 = tail call spir_func double @__ocmlpriv_lnep_f64(<2 x double> noundef %10, i32 noundef 0) #38
  %12 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %14, label %23

14:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %0, ptr %2, align 8, !tbaa !19
  %15 = addrspacecast ptr %2 to ptr addrspace(4)
  %16 = load i128, ptr addrspace(4) %15, align 8, !tbaa !29
  %17 = icmp eq i128 %16, 9218868437227405312
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %18 = select i1 %17, double %0, double %11
  %19 = fcmp olt double %0, -1.000000e+00
  %20 = select i1 %19, double 0x7FF8000000000000, double %18
  %21 = fcmp oeq double %0, -1.000000e+00
  %22 = select i1 %21, double 0xFFF0000000000000, double %20
  br label %23

23:                                               ; preds = %14, %1
  %24 = phi double [ %11, %1 ], [ %22, %14 ]
  ret double %24
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_log1p_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = fadd float %0, 1.000000e+00
  %4 = fadd float %3, -1.000000e+00
  %5 = fsub float %4, %3
  %6 = fadd float %5, 1.000000e+00
  %7 = fsub float %0, %4
  %8 = fadd float %7, %6
  %9 = insertelement <2 x float> poison, float %8, i64 0
  %10 = insertelement <2 x float> %9, float %3, i64 1
  %11 = tail call spir_func float @__ocmlpriv_lnep_f32(<2 x float> noundef %10, i32 noundef 0) #38
  %12 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %14, label %23

14:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %0, ptr %2, align 8, !tbaa !16
  %15 = addrspacecast ptr %2 to ptr addrspace(4)
  %16 = load i64, ptr addrspace(4) %15, align 8, !tbaa !12
  %17 = icmp eq i64 %16, 2139095040
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %18 = select i1 %17, float %0, float %11
  %19 = fcmp olt float %0, -1.000000e+00
  %20 = select i1 %19, float 0x7FF8000000000000, float %18
  %21 = fcmp oeq float %0, -1.000000e+00
  %22 = select i1 %21, float 0xFFF0000000000000, float %20
  br label %23

23:                                               ; preds = %14, %1
  %24 = phi float [ %11, %1 ], [ %22, %14 ]
  %25 = tail call float @llvm.fabs.f32(float %0)
  %26 = fcmp olt float %25, 0x3E70000000000000
  %27 = select i1 %26, float %0, float %24
  ret float %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_log1p_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = fadd float %3, 1.000000e+00
  %5 = tail call float @llvm.log2.f32(float %4)
  %6 = fmul float %5, 0x3FE62E4300000000
  %7 = fptrunc float %6 to half
  %8 = tail call half @llvm.fma.f16(half %2, half 0xH3555, half 0xHB800)
  %9 = fmul half %2, %8
  %10 = tail call half @llvm.fma.f16(half %2, half %9, half %2)
  %11 = tail call half @llvm.fabs.f16(half %2)
  %12 = fcmp olt half %11, 0xH2400
  %13 = select i1 %12, half %10, half %7
  %14 = insertelement <2 x half> poison, half %13, i64 0
  %15 = extractelement <2 x half> %0, i64 1
  %16 = fpext half %15 to float
  %17 = fadd float %16, 1.000000e+00
  %18 = tail call float @llvm.log2.f32(float %17)
  %19 = fmul float %18, 0x3FE62E4300000000
  %20 = fptrunc float %19 to half
  %21 = tail call half @llvm.fma.f16(half %15, half 0xH3555, half 0xHB800)
  %22 = fmul half %15, %21
  %23 = tail call half @llvm.fma.f16(half %15, half %22, half %15)
  %24 = tail call half @llvm.fabs.f16(half %15)
  %25 = fcmp olt half %24, 0xH2400
  %26 = select i1 %25, half %23, half %20
  %27 = insertelement <2 x half> %14, half %26, i64 1
  ret <2 x half> %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_log1p_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = fpext half %0 to float
  %3 = fadd float %2, 1.000000e+00
  %4 = tail call float @llvm.log2.f32(float %3)
  %5 = fmul float %4, 0x3FE62E4300000000
  %6 = fptrunc float %5 to half
  %7 = tail call half @llvm.fma.f16(half %0, half 0xH3555, half 0xHB800)
  %8 = fmul half %7, %0
  %9 = tail call half @llvm.fma.f16(half %0, half %8, half %0)
  %10 = tail call half @llvm.fabs.f16(half %0)
  %11 = fcmp olt half %10, 0xH2400
  %12 = select i1 %11, half %9, half %6
  ret half %12
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_log2_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = fcmp olt double %0, 0x3FE5555555555555
  %4 = zext i1 %3 to i32
  %5 = tail call spir_func double @_Z5ldexpdi(double noundef %0, i32 noundef %4) #38
  %6 = fptrunc double %0 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %7 = addrspacecast ptr %2 to ptr addrspace(4)
  %8 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %6, ptr addrspace(4) noundef %7) #40
  %9 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %10 = sub nsw i32 %9, %4
  %11 = fadd double %5, -1.000000e+00
  %12 = fadd double %5, 1.000000e+00
  %13 = fadd double %12, -1.000000e+00
  %14 = fsub double %5, %13
  %15 = fptrunc double %12 to float
  %16 = call spir_func float @_Z12native_recipf(float noundef %15) #38
  %17 = fpext float %16 to double
  %18 = fneg double %12
  %19 = call double @llvm.fma.f64(double %18, double %17, double 1.000000e+00)
  %20 = call double @llvm.fma.f64(double %19, double %17, double %17)
  %21 = call double @llvm.fma.f64(double %18, double %20, double 1.000000e+00)
  %22 = call double @llvm.fma.f64(double %21, double %20, double %20)
  %23 = fmul double %11, %22
  %24 = fmul double %12, %23
  %25 = fneg double %24
  %26 = call double @llvm.fma.f64(double %23, double %12, double %25)
  %27 = call double @llvm.fma.f64(double %23, double %14, double %26)
  %28 = fadd double %24, %27
  %29 = fsub double %28, %24
  %30 = fsub double %11, %28
  %31 = fsub double %11, %30
  %32 = fsub double %31, %28
  %33 = fsub double %29, %27
  %34 = fadd double %33, %32
  %35 = fadd double %30, %34
  %36 = fmul double %22, %35
  %37 = fadd double %23, %36
  %38 = fsub double %37, %23
  %39 = fsub double %36, %38
  %40 = fmul double %37, %37
  %41 = call double @llvm.fma.f64(double %40, double 0x3FC3AB76BF559E2B, double 0x3FC385386B47B09A)
  %42 = call double @llvm.fma.f64(double %40, double %41, double 0x3FC7474DD7F4DF2E)
  %43 = call double @llvm.fma.f64(double %40, double %42, double 0x3FCC71C016291751)
  %44 = call double @llvm.fma.f64(double %40, double %43, double 0x3FD249249B27ACF1)
  %45 = call double @llvm.fma.f64(double %40, double %44, double 0x3FD99999998EF7B6)
  %46 = call double @llvm.fma.f64(double %40, double %45, double 0x3FE5555555555780)
  %47 = call spir_func double @_Z5ldexpdi(double noundef %37, i32 noundef 1) #38
  %48 = call spir_func double @_Z5ldexpdi(double noundef %39, i32 noundef 1) #38
  %49 = fmul double %37, %40
  %50 = fmul double %49, %46
  %51 = fadd double %47, %50
  %52 = fsub double %51, %47
  %53 = fsub double %50, %52
  %54 = fadd double %48, %53
  %55 = fadd double %51, %54
  %56 = fsub double %55, %51
  %57 = fsub double %54, %56
  %58 = sitofp i32 %10 to double
  %59 = fmul double %55, 0x3FF71547652B82FE
  %60 = fneg double %59
  %61 = call double @llvm.fma.f64(double %55, double 0x3FF71547652B82FE, double %60)
  %62 = call double @llvm.fma.f64(double %57, double 0x3FF71547652B82FE, double %61)
  %63 = call double @llvm.fma.f64(double %55, double 0x3C7777D0FFDA0D24, double %62)
  %64 = fadd double %59, %63
  %65 = fsub double %64, %59
  %66 = fsub double %63, %65
  %67 = fadd double %64, %58
  %68 = fsub double %67, %58
  %69 = fsub double %68, %67
  %70 = fadd double %69, %58
  %71 = fsub double %64, %68
  %72 = fadd double %71, %70
  %73 = fadd double %66, %72
  %74 = fadd double %67, %73
  %75 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %76 = icmp eq i8 %75, 0
  br i1 %76, label %77, label %85

77:                                               ; preds = %1
  %78 = call double @llvm.fabs.f64(double %0)
  %79 = fcmp oeq double %78, 0x7FF0000000000000
  %80 = select i1 %79, double %0, double %74
  %81 = fcmp olt double %0, 0.000000e+00
  %82 = select i1 %81, double 0x7FF8000000000000, double %80
  %83 = fcmp oeq double %0, 0.000000e+00
  %84 = select i1 %83, double 0xFFF0000000000000, double %82
  br label %85

85:                                               ; preds = %77, %1
  %86 = phi double [ %74, %1 ], [ %84, %77 ]
  ret double %86
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func float @__ocml_log2_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = alloca float, align 8
  %3 = alloca float, align 8
  %4 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %8, label %6

6:                                                ; preds = %1
  %7 = tail call float @llvm.log2.f32(float %0)
  br label %37

8:                                                ; preds = %1
  %9 = load i8, ptr addrspace(2) @__oclc_unsafe_math_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %24, label %11

11:                                               ; preds = %8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %0, ptr %3, align 8, !tbaa !16
  %12 = addrspacecast ptr %3 to ptr addrspace(4)
  %13 = load i64, ptr addrspace(4) %12, align 8, !tbaa !12
  %14 = and i64 %13, 2139095040
  %15 = icmp ne i64 %14, 0
  %16 = and i64 %13, 8388607
  %17 = icmp eq i64 %16, 0
  %18 = or i1 %15, %17
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %19 = select i1 %18, float 1.000000e+00, float 0x41F0000000000000
  %20 = fmul float %19, %0
  %21 = tail call float @llvm.log2.f32(float %20)
  %22 = select i1 %18, float 0.000000e+00, float 3.200000e+01
  %23 = fsub float %21, %22
  br label %37

24:                                               ; preds = %8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %0, ptr %2, align 8, !tbaa !16
  %25 = addrspacecast ptr %2 to ptr addrspace(4)
  %26 = load i64, ptr addrspace(4) %25, align 8, !tbaa !12
  %27 = and i64 %26, 2139095040
  %28 = icmp ne i64 %27, 0
  %29 = and i64 %26, 8388607
  %30 = icmp eq i64 %29, 0
  %31 = or i1 %28, %30
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %32 = select i1 %31, float 1.000000e+00, float 0x41F0000000000000
  %33 = fmul float %32, %0
  %34 = tail call float @llvm.log2.f32(float %33)
  %35 = select i1 %31, float 0.000000e+00, float 3.200000e+01
  %36 = fsub float %34, %35
  br label %37

37:                                               ; preds = %6, %24, %11
  %38 = phi float [ %23, %11 ], [ %36, %24 ], [ %7, %6 ]
  ret float %38
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_log2_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call noundef half @llvm.log2.f16(half %2)
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call noundef half @llvm.log2.f16(half %5)
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.log2.f16(half) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_log2_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.log2.f16(half %0)
  ret half %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_log_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call float @llvm.log2.f32(float %3)
  %5 = fmul float %4, 0x3FE62E4300000000
  %6 = fptrunc float %5 to half
  %7 = insertelement <2 x half> poison, half %6, i64 0
  %8 = extractelement <2 x half> %0, i64 1
  %9 = fpext half %8 to float
  %10 = tail call float @llvm.log2.f32(float %9)
  %11 = fmul float %10, 0x3FE62E4300000000
  %12 = fptrunc float %11 to half
  %13 = insertelement <2 x half> %7, half %12, i64 1
  ret <2 x half> %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_log_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = fpext half %0 to float
  %3 = tail call float @llvm.log2.f32(float %2)
  %4 = fmul float %3, 0x3FE62E4300000000
  %5 = fptrunc float %4 to half
  ret half %5
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_logb_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca i32, align 4
  %4 = fptrunc double %0 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %5 = addrspacecast ptr %3 to ptr addrspace(4)
  %6 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %4, ptr addrspace(4) noundef %5) #40
  %7 = load i32, ptr %3, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %8 = add nsw i32 %7, -1
  %9 = sitofp i32 %8 to double
  %10 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %12, label %31

12:                                               ; preds = %1
  %13 = call double @llvm.fabs.f64(double %0)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %13, ptr %2, align 8, !tbaa !19
  %14 = addrspacecast ptr %2 to ptr addrspace(4)
  %15 = load i128, ptr addrspace(4) %14, align 8, !tbaa !29
  %16 = and i128 %15, 9223372036854775807
  %17 = icmp eq i128 %16, 0
  br i1 %17, label %18, label %19

18:                                               ; preds = %12
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  br label %27

19:                                               ; preds = %12
  %20 = and i128 %15, 9218868437227405312
  %21 = icmp ne i128 %20, 0
  %22 = and i128 %15, 4503599627370495
  %23 = icmp eq i128 %22, 0
  %24 = or i1 %21, %23
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %25 = freeze i1 %24
  %26 = select i1 %25, double %13, double %9
  br label %27

27:                                               ; preds = %19, %18
  %28 = phi double [ %9, %18 ], [ %26, %19 ]
  %29 = fcmp oeq double %0, 0.000000e+00
  %30 = select i1 %29, double 0xFFF0000000000000, double %28
  br label %31

31:                                               ; preds = %27, %1
  %32 = phi double [ %9, %1 ], [ %30, %27 ]
  ret double %32
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_logb_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %4 = addrspacecast ptr %3 to ptr addrspace(4)
  %5 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %0, ptr addrspace(4) noundef %4) #40
  %6 = load i32, ptr %3, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %7 = add nsw i32 %6, -1
  %8 = sitofp i32 %7 to float
  %9 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %30

11:                                               ; preds = %1
  %12 = call float @llvm.fabs.f32(float %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %12, ptr %2, align 8, !tbaa !16
  %13 = addrspacecast ptr %2 to ptr addrspace(4)
  %14 = load i64, ptr addrspace(4) %13, align 8, !tbaa !12
  %15 = and i64 %14, 2147483647
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %17, label %18

17:                                               ; preds = %11
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %26

18:                                               ; preds = %11
  %19 = and i64 %14, 2139095040
  %20 = icmp ne i64 %19, 0
  %21 = and i64 %14, 8388607
  %22 = icmp eq i64 %21, 0
  %23 = or i1 %20, %22
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %24 = freeze i1 %23
  %25 = select i1 %24, float %12, float %8
  br label %26

26:                                               ; preds = %18, %17
  %27 = phi float [ %8, %17 ], [ %25, %18 ]
  %28 = fcmp oeq float %0, 0.000000e+00
  %29 = select i1 %28, float 0xFFF0000000000000, float %27
  br label %30

30:                                               ; preds = %26, %1
  %31 = phi float [ %8, %1 ], [ %29, %26 ]
  ret float %31
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_logb_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_logb_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_logb_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_logb_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func i32 @frexp_exp.86(float noundef %2) #40
  %4 = add nsw i32 %3, -1
  %5 = sitofp i32 %4 to half
  %6 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %8, label %16

8:                                                ; preds = %1
  %9 = tail call half @llvm.fabs.f16(half %0)
  %10 = fptoui half %9 to i16
  %11 = tail call spir_func i32 @__builtin_generic_class_f16.87(i16 noundef zeroext %10) #39
  %12 = icmp eq i32 %11, 0
  %13 = select i1 %12, half %9, half %5
  %14 = fcmp oeq half %0, 0xH0000
  %15 = select i1 %14, half 0xHFC00, half %13
  br label %16

16:                                               ; preds = %8, %1
  %17 = phi half [ %5, %1 ], [ %15, %8 ]
  ret half %17
}

; Function Attrs: convergent inlinehint norecurse nounwind
define internal spir_func i32 @frexp_exp.86(float noundef %0) unnamed_addr #33 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %3 = addrspacecast ptr %2 to ptr addrspace(4)
  %4 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %0, ptr addrspace(4) noundef %3) #40
  %5 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret i32 %5
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func i32 @__builtin_generic_class_f16.87(i16 noundef zeroext %0) unnamed_addr #25 {
  %2 = and i16 %0, 32767
  %3 = icmp eq i16 %2, 0
  br i1 %3, label %12, label %4

4:                                                ; preds = %1
  %5 = zext i16 %0 to i32
  %6 = and i32 %5, 31744
  %7 = icmp eq i32 %6, 0
  %8 = and i32 %5, 1023
  %9 = icmp ne i32 %8, 0
  %10 = and i1 %7, %9
  %11 = sext i1 %10 to i32
  br label %12

12:                                               ; preds = %4, %1
  %13 = phi i32 [ -1, %1 ], [ %11, %4 ]
  ret i32 %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_mad_f64(double noundef %0, double noundef %1, double noundef %2) local_unnamed_addr #23 {
  %4 = tail call double @llvm.fma.f64(double %0, double %1, double %2)
  ret double %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x float> @__ocml_mad_2f32(<2 x float> noundef %0, <2 x float> noundef %1, <2 x float> noundef %2) local_unnamed_addr #21 {
  %4 = tail call spir_func <2 x float> @__ocml_fmuladd_2f32(<2 x float> noundef %0, <2 x float> noundef %1, <2 x float> noundef %2) #38
  ret <2 x float> %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_mad_f32(float noundef %0, float noundef %1, float noundef %2) local_unnamed_addr #21 {
  %4 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef %1, float noundef %2) #38
  ret float %4
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_mad_2f16(<2 x half> noundef %0, <2 x half> noundef %1, <2 x half> noundef %2) local_unnamed_addr #31 {
  %4 = tail call spir_func <2 x half> @llvm.fma.v2f16(<2 x half> noundef %0, <2 x half> noundef %1, <2 x half> noundef %2) #38
  ret <2 x half> %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_mad_f16(half noundef %0, half noundef %1, half noundef %2) local_unnamed_addr #23 {
  %4 = tail call half @llvm.fma.f16(half %0, half %1, half %2)
  ret half %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_max_f64(double noundef %0, double noundef %1) local_unnamed_addr #23 {
  %3 = tail call double @llvm.maxnum.f64(double %0, double %1)
  ret double %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_max_f32(float noundef %0, float noundef %1) local_unnamed_addr #23 {
  %3 = tail call float @llvm.maxnum.f32(float %0, float %1)
  ret float %3
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_max_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #31 {
  %3 = tail call spir_func <2 x half> @llvm.maxnum.v2f16(<2 x half> noundef %0, <2 x half> noundef %1) #38
  ret <2 x half> %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_max_f16(half noundef %0, half noundef %1) local_unnamed_addr #23 {
  %3 = tail call half @llvm.maxnum.f16(half %0, half %1)
  ret half %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_maxmag_f64(double noundef %0, double noundef %1) local_unnamed_addr #23 {
  %3 = tail call double @llvm.maxnum.f64(double %0, double %1)
  %4 = tail call double @llvm.fabs.f64(double %0)
  %5 = tail call double @llvm.fabs.f64(double %1)
  %6 = fcmp ogt double %4, %5
  %7 = select i1 %6, double %0, double %3
  %8 = fcmp ogt double %5, %4
  %9 = select i1 %8, double %1, double %7
  ret double %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_maxmag_f32(float noundef %0, float noundef %1) local_unnamed_addr #23 {
  %3 = tail call float @llvm.maxnum.f32(float %0, float %1)
  %4 = tail call float @llvm.fabs.f32(float %0)
  %5 = tail call float @llvm.fabs.f32(float %1)
  %6 = fcmp ogt float %4, %5
  %7 = select i1 %6, float %0, float %3
  %8 = fcmp ogt float %5, %4
  %9 = select i1 %8, float %1, float %7
  ret float %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_maxmag_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #23 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = tail call half @llvm.maxnum.f16(half %3, half %4)
  %6 = tail call half @llvm.fabs.f16(half %3)
  %7 = tail call half @llvm.fabs.f16(half %4)
  %8 = fcmp ogt half %6, %7
  %9 = select i1 %8, half %3, half %5
  %10 = fcmp ogt half %7, %6
  %11 = select i1 %10, half %4, half %9
  %12 = insertelement <2 x half> poison, half %11, i64 0
  %13 = extractelement <2 x half> %0, i64 1
  %14 = extractelement <2 x half> %1, i64 1
  %15 = tail call half @llvm.maxnum.f16(half %13, half %14)
  %16 = tail call half @llvm.fabs.f16(half %13)
  %17 = tail call half @llvm.fabs.f16(half %14)
  %18 = fcmp ogt half %16, %17
  %19 = select i1 %18, half %13, half %15
  %20 = fcmp ogt half %17, %16
  %21 = select i1 %20, half %14, half %19
  %22 = insertelement <2 x half> %12, half %21, i64 1
  ret <2 x half> %22
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_maxmag_f16(half noundef %0, half noundef %1) local_unnamed_addr #23 {
  %3 = tail call half @llvm.maxnum.f16(half %0, half %1)
  %4 = tail call half @llvm.fabs.f16(half %0)
  %5 = tail call half @llvm.fabs.f16(half %1)
  %6 = fcmp ogt half %4, %5
  %7 = select i1 %6, half %0, half %3
  %8 = fcmp ogt half %5, %4
  %9 = select i1 %8, half %1, half %7
  ret half %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_min_f64(double noundef %0, double noundef %1) local_unnamed_addr #23 {
  %3 = tail call double @llvm.minnum.f64(double %0, double %1)
  ret double %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_min_f32(float noundef %0, float noundef %1) local_unnamed_addr #23 {
  %3 = tail call float @llvm.minnum.f32(float %0, float %1)
  ret float %3
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_min_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #31 {
  %3 = tail call spir_func <2 x half> @llvm.minnum.v2f16(<2 x half> noundef %0, <2 x half> noundef %1) #38
  ret <2 x half> %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_min_f16(half noundef %0, half noundef %1) local_unnamed_addr #23 {
  %3 = tail call half @llvm.minnum.f16(half %0, half %1)
  ret half %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_minmag_f64(double noundef %0, double noundef %1) local_unnamed_addr #23 {
  %3 = tail call double @llvm.minnum.f64(double %0, double %1)
  %4 = tail call double @llvm.fabs.f64(double %0)
  %5 = tail call double @llvm.fabs.f64(double %1)
  %6 = fcmp olt double %4, %5
  %7 = select i1 %6, double %0, double %3
  %8 = fcmp olt double %5, %4
  %9 = select i1 %8, double %1, double %7
  ret double %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_minmag_f32(float noundef %0, float noundef %1) local_unnamed_addr #23 {
  %3 = tail call float @llvm.minnum.f32(float %0, float %1)
  %4 = tail call float @llvm.fabs.f32(float %0)
  %5 = tail call float @llvm.fabs.f32(float %1)
  %6 = fcmp olt float %4, %5
  %7 = select i1 %6, float %0, float %3
  %8 = fcmp olt float %5, %4
  %9 = select i1 %8, float %1, float %7
  ret float %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_minmag_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #23 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = tail call half @llvm.minnum.f16(half %3, half %4)
  %6 = tail call half @llvm.fabs.f16(half %3)
  %7 = tail call half @llvm.fabs.f16(half %4)
  %8 = fcmp olt half %6, %7
  %9 = select i1 %8, half %3, half %5
  %10 = fcmp olt half %7, %6
  %11 = select i1 %10, half %4, half %9
  %12 = insertelement <2 x half> poison, half %11, i64 0
  %13 = extractelement <2 x half> %0, i64 1
  %14 = extractelement <2 x half> %1, i64 1
  %15 = tail call half @llvm.minnum.f16(half %13, half %14)
  %16 = tail call half @llvm.fabs.f16(half %13)
  %17 = tail call half @llvm.fabs.f16(half %14)
  %18 = fcmp olt half %16, %17
  %19 = select i1 %18, half %13, half %15
  %20 = fcmp olt half %17, %16
  %21 = select i1 %20, half %14, half %19
  %22 = insertelement <2 x half> %12, half %21, i64 1
  ret <2 x half> %22
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_minmag_f16(half noundef %0, half noundef %1) local_unnamed_addr #23 {
  %3 = tail call half @llvm.minnum.f16(half %0, half %1)
  %4 = tail call half @llvm.fabs.f16(half %0)
  %5 = tail call half @llvm.fabs.f16(half %1)
  %6 = fcmp olt half %4, %5
  %7 = select i1 %6, half %0, half %3
  %8 = fcmp olt half %5, %4
  %9 = select i1 %8, half %1, half %7
  ret half %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func noundef double @__ocml_modf_f64(double noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #29 {
  %3 = tail call double @llvm.trunc.f64(double %0)
  %4 = fsub double %0, %3
  %5 = tail call double @llvm.fabs.f64(double %0)
  %6 = fcmp oeq double %5, 0x7FF0000000000000
  %7 = select i1 %6, double 0.000000e+00, double %4
  store double %3, ptr %1, align 8, !tbaa !19
  %8 = tail call double @llvm.copysign.f64(double %7, double %0)
  ret double %8
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.trunc.f64(double) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func noundef float @__ocml_modf_f32(float noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #29 {
  %3 = tail call float @llvm.trunc.f32(float %0)
  %4 = fsub float %0, %3
  %5 = tail call float @llvm.fabs.f32(float %0)
  %6 = fcmp oeq float %5, 0x7FF0000000000000
  %7 = select i1 %6, float 0.000000e+00, float %4
  store float %3, ptr %1, align 4, !tbaa !16
  %8 = tail call float @llvm.copysign.f32(float %7, float %0)
  ret float %8
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.trunc.f32(float) #2

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func noundef <2 x half> @__ocml_modf_2f16(<2 x half> noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #34 {
  %3 = tail call spir_func <2 x half> @llvm.trunc.v2f16(<2 x half> noundef %0) #38
  %4 = fsub <2 x half> %0, %3
  %5 = extractelement <2 x half> %0, i64 0
  %6 = tail call half @llvm.fabs.f16(half %5)
  %7 = fcmp oeq half %6, 0xH7C00
  %8 = extractelement <2 x half> %4, i64 0
  %9 = select i1 %7, half 0xH0000, half %8
  %10 = insertelement <2 x half> poison, half %9, i64 0
  %11 = extractelement <2 x half> %0, i64 1
  %12 = tail call half @llvm.fabs.f16(half %11)
  %13 = fcmp oeq half %12, 0xH7C00
  %14 = extractelement <2 x half> %4, i64 1
  %15 = select i1 %13, half 0xH0000, half %14
  %16 = insertelement <2 x half> %10, half %15, i64 1
  store <2 x half> %3, ptr %1, align 4, !tbaa !14
  %17 = tail call spir_func <2 x half> @llvm.copysign.v2f16(<2 x half> noundef %16, <2 x half> noundef %0) #38
  ret <2 x half> %17
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x half> @llvm.trunc.v2f16(<2 x half>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func noundef half @__ocml_modf_f16(half noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #32 {
  %3 = tail call half @llvm.trunc.f16(half %0)
  %4 = fsub half %0, %3
  %5 = tail call half @llvm.fabs.f16(half %0)
  %6 = fcmp oeq half %5, 0xH7C00
  %7 = select i1 %6, half 0xH0000, half %4
  store half %3, ptr %1, align 2, !tbaa !57
  %8 = tail call half @llvm.copysign.f16(half %7, half %0)
  ret half %8
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.trunc.f16(half) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func double @__ocml_nan_f64(i64 noundef %0) local_unnamed_addr #23 {
  %2 = and i64 %0, 2251799813685247
  %3 = or disjoint i64 %2, 9221120237041090560
  %4 = bitcast i64 %3 to double
  ret double %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func float @__ocml_nan_f32(i32 noundef %0) local_unnamed_addr #23 {
  %2 = and i32 %0, 1048575
  %3 = or disjoint i32 %2, 2143289344
  %4 = bitcast i32 %3 to float
  ret float %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_nan_2f16(<2 x i16> noundef %0) local_unnamed_addr #23 {
  %2 = and <2 x i16> %0, <i16 511, i16 511>
  %3 = or disjoint <2 x i16> %2, <i16 32256, i16 32256>
  %4 = bitcast <2 x i16> %3 to <2 x half>
  ret <2 x half> %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_nan_f16(i16 noundef zeroext %0) local_unnamed_addr #23 {
  %2 = and i16 %0, 511
  %3 = or disjoint i16 %2, 32256
  %4 = bitcast i16 %3 to half
  ret half %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_native_recip_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = fdiv double 1.000000e+00, %0
  ret double %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_native_sqrt_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.sqrt.f64(double %0)
  ret double %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.sqrt.f64(double) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_native_rsqrt_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.sqrt.f64(double %0)
  %3 = fdiv double 1.000000e+00, %2
  ret double %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_native_sin_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.sin.f64(double %0)
  ret double %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.sin.f64(double) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_native_cos_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.cos.f64(double %0)
  ret double %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.cos.f64(double) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_native_exp_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.exp.f64(double %0)
  ret double %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.exp.f64(double) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_native_exp2_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.exp2.f64(double %0)
  ret double %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.exp2.f64(double) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_native_log_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.log.f64(double %0)
  ret double %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_native_log2_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.log2.f64(double %0)
  ret double %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.log2.f64(double) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_native_log10_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.log10.f64(double %0)
  ret double %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.log10.f64(double) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_native_recip_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = fdiv float 1.000000e+00, %0, !fpmath !15
  ret float %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_native_sqrt_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.sqrt.f32(float %0), !fpmath !18
  ret float %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_native_rsqrt_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.sqrt.f32(float %0), !fpmath !18
  %3 = fdiv float 1.000000e+00, %2, !fpmath !15
  ret float %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_native_sin_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.sin.f32(float %0)
  ret float %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.sin.f32(float) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_native_cos_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.cos.f32(float %0)
  ret float %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.cos.f32(float) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_native_exp_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.exp.f32(float %0)
  ret float %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.exp.f32(float) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_native_exp2_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.exp2.f32(float %0)
  ret float %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_native_exp10_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = fmul float %0, 0x400A934F00000000
  %3 = tail call float @llvm.exp2.f32(float %2)
  ret float %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_native_log_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.log.f32(float %0)
  ret float %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.log.f32(float) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_native_log2_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.log2.f32(float %0)
  ret float %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_native_log10_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.log10.f32(float %0)
  ret float %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.log10.f32(float) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_native_rcp_f16(half noundef %0) local_unnamed_addr #26 {
  %2 = fdiv half 0xH3C00, %0
  ret half %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_native_sqrt_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.sqrt.f16(half %0)
  ret half %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_native_rsqrt_f16(half noundef %0) local_unnamed_addr #26 {
  %2 = tail call half @llvm.sqrt.f16(half %0)
  %3 = fdiv half 0xH3C00, %2
  ret half %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_native_sin_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.sin.f16(half %0)
  ret half %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.sin.f16(half) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_native_cos_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.cos.f16(half %0)
  ret half %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.cos.f16(half) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_native_exp_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.exp.f16(half %0)
  ret half %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.exp.f16(half) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_native_exp2_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.exp2.f16(half %0)
  ret half %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_native_log_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.log.f16(half %0)
  ret half %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.log.f16(half) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_native_log2_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.log2.f16(half %0)
  ret half %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_native_log10_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.log10.f16(half %0)
  ret half %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.log10.f16(half) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_ncdf_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fcmp ogt double %2, 0x40434D4EDCE2B7D6
  %4 = tail call double @llvm.copysign.f64(double 0x40434D4EDCE2B7D6, double %0)
  %5 = select i1 %3, double %4, double %0
  %6 = fmul double %5, 0xBFE6A09E667F3BCD
  %7 = fneg double %6
  %8 = tail call double @llvm.fma.f64(double %5, double 0xBFE6A09E667F3BCD, double %7)
  %9 = tail call double @llvm.fma.f64(double %5, double 0x3C8BDD3413B26456, double %8)
  %10 = fadd double %6, %9
  %11 = fsub double %10, %6
  %12 = fsub double %9, %11
  %13 = tail call spir_func double @__ocml_erfc_f64(double noundef %10) #38
  %14 = fmul double %10, -2.000000e+00
  %15 = fmul double %14, %13
  %16 = fcmp oge double %5, -1.000000e+00
  %17 = select i1 %16, double 0.000000e+00, double %15
  %18 = tail call double @llvm.fma.f64(double %12, double %17, double %13)
  %19 = fmul double %18, 5.000000e-01
  ret double %19
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_ncdf_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = fcmp ogt float %2, 0x402C572280000000
  %4 = tail call float @llvm.copysign.f32(float 0x402C572280000000, float %0)
  %5 = select i1 %3, float %4, float %0
  %6 = fmul float %5, 0xBFE6A09E60000000
  %7 = fneg float %6
  %8 = tail call float @llvm.fma.f32(float %5, float 0xBFE6A09E60000000, float %7)
  %9 = tail call float @llvm.fma.f32(float %5, float 0xBE49FCEF40000000, float %8)
  %10 = fadd float %6, %9
  %11 = fsub float %10, %6
  %12 = fsub float %9, %11
  %13 = tail call spir_func float @__ocml_erfc_f32(float noundef %10) #38
  %14 = fmul float %10, -2.000000e+00
  %15 = fmul float %14, %13
  %16 = fcmp oge float %5, -1.000000e+00
  %17 = select i1 %16, float 0.000000e+00, float %15
  %18 = tail call float @llvm.fma.f32(float %12, float %17, float %13)
  %19 = fmul float %18, 5.000000e-01
  ret float %19
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_ncdf_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_ncdf_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_ncdf_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_ncdf_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_ncdf_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_ncdfinv_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = fadd double %0, %0
  %3 = tail call spir_func double @__ocml_erfcinv_f64(double noundef %2) #38
  %4 = fmul double %3, 0xBFF6A09E667F3BCD
  ret double %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_ncdfinv_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = fadd float %0, %0
  %3 = tail call spir_func float @__ocml_erfcinv_f32(float noundef %2) #38
  %4 = fmul float %3, 0xBFF6A09E60000000
  ret float %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_ncdfinv_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_ncdfinv_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_ncdfinv_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_ncdfinv_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_ncdfinv_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_nearbyint_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.rint.f64(double %0)
  ret double %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_nearbyint_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.rint.f32(float %0)
  ret float %2
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_nearbyint_2f16(<2 x half> noundef %0) local_unnamed_addr #31 {
  %2 = tail call spir_func <2 x half> @llvm.rint.v2f16(<2 x half> noundef %0) #38
  ret <2 x half> %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x half> @llvm.rint.v2f16(<2 x half>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_nearbyint_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.rint.f16(half %0)
  ret half %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func double @__ocml_nextafter_f64(double noundef %0, double noundef %1) local_unnamed_addr #23 {
  %3 = bitcast double %0 to i64
  %4 = sub i64 -9223372036854775808, %3
  %5 = icmp slt i64 %3, 0
  %6 = select i1 %5, i64 %4, i64 %3
  %7 = bitcast double %1 to i64
  %8 = sub i64 -9223372036854775808, %7
  %9 = icmp slt i64 %7, 0
  %10 = select i1 %9, i64 %8, i64 %7
  %11 = icmp slt i64 %6, %10
  %12 = select i1 %11, i64 1, i64 -1
  %13 = add nsw i64 %12, %6
  %14 = sub i64 -9223372036854775808, %13
  %15 = icmp slt i64 %13, 0
  %16 = select i1 %15, i64 %14, i64 %13
  %17 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %18 = icmp eq i8 %17, 0
  %19 = fcmp uno double %0, 0.000000e+00
  %20 = select i1 %19, i64 %3, i64 %16
  %21 = fcmp uno double %1, 0.000000e+00
  %22 = select i1 %21, i64 %7, i64 %20
  %23 = select i1 %18, i64 %22, i64 %16
  %24 = tail call double @llvm.fabs.f64(double %0)
  %25 = tail call double @llvm.fabs.f64(double %1)
  %26 = bitcast double %24 to i64
  %27 = bitcast double %25 to i64
  %28 = or i64 %27, %26
  %29 = icmp eq i64 %28, 0
  %30 = icmp eq i64 %3, %7
  %31 = or i1 %30, %29
  %32 = select i1 %31, i64 %7, i64 %23
  %33 = bitcast i64 %32 to double
  ret double %33
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func float @__ocml_nextafter_f32(float noundef %0, float noundef %1) local_unnamed_addr #23 {
  %3 = bitcast float %0 to i32
  %4 = sub nsw i32 -2147483648, %3
  %5 = icmp slt i32 %3, 0
  %6 = select i1 %5, i32 %4, i32 %3
  %7 = bitcast float %1 to i32
  %8 = sub nsw i32 -2147483648, %7
  %9 = icmp slt i32 %7, 0
  %10 = select i1 %9, i32 %8, i32 %7
  %11 = icmp slt i32 %6, %10
  %12 = select i1 %11, i32 1, i32 -1
  %13 = add nsw i32 %12, %6
  %14 = sub nsw i32 -2147483648, %13
  %15 = icmp slt i32 %13, 0
  %16 = select i1 %15, i32 %14, i32 %13
  %17 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %18 = icmp eq i8 %17, 0
  %19 = fcmp uno float %0, 0.000000e+00
  %20 = select i1 %19, i32 %3, i32 %16
  %21 = fcmp uno float %1, 0.000000e+00
  %22 = select i1 %21, i32 %7, i32 %20
  %23 = select i1 %18, i32 %22, i32 %16
  %24 = tail call float @llvm.fabs.f32(float %0)
  %25 = tail call float @llvm.fabs.f32(float %1)
  %26 = bitcast float %24 to i32
  %27 = bitcast float %25 to i32
  %28 = or i32 %27, %26
  %29 = icmp eq i32 %28, 0
  %30 = icmp eq i32 %3, %7
  %31 = or i1 %30, %29
  %32 = select i1 %31, i32 %7, i32 %23
  %33 = bitcast i32 %32 to float
  ret float %33
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_nextafter_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #23 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = bitcast half %3 to i16
  %6 = sub i16 -32768, %5
  %7 = icmp slt i16 %5, 0
  %8 = select i1 %7, i16 %6, i16 %5
  %9 = bitcast half %4 to i16
  %10 = sub i16 -32768, %9
  %11 = icmp slt i16 %9, 0
  %12 = select i1 %11, i16 %10, i16 %9
  %13 = icmp slt i16 %8, %12
  %14 = select i1 %13, i16 1, i16 -1
  %15 = add i16 %14, %8
  %16 = sub i16 -32768, %15
  %17 = icmp slt i16 %15, 0
  %18 = select i1 %17, i16 %16, i16 %15
  %19 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %20 = icmp eq i8 %19, 0
  %21 = fcmp uno half %3, 0xH0000
  %22 = select i1 %21, i16 %5, i16 %18
  %23 = fcmp uno half %4, 0xH0000
  %24 = select i1 %23, i16 %9, i16 %22
  %25 = select i1 %20, i16 %24, i16 %18
  %26 = tail call half @llvm.fabs.f16(half %3)
  %27 = tail call half @llvm.fabs.f16(half %4)
  %28 = bitcast half %26 to i16
  %29 = bitcast half %27 to i16
  %30 = or i16 %29, %28
  %31 = icmp eq i16 %30, 0
  %32 = icmp eq i16 %5, %9
  %33 = or i1 %32, %31
  %34 = select i1 %33, i16 %9, i16 %25
  %35 = insertelement <2 x i16> poison, i16 %34, i64 0
  %36 = extractelement <2 x half> %0, i64 1
  %37 = extractelement <2 x half> %1, i64 1
  %38 = bitcast half %36 to i16
  %39 = sub i16 -32768, %38
  %40 = icmp slt i16 %38, 0
  %41 = select i1 %40, i16 %39, i16 %38
  %42 = bitcast half %37 to i16
  %43 = sub i16 -32768, %42
  %44 = icmp slt i16 %42, 0
  %45 = select i1 %44, i16 %43, i16 %42
  %46 = icmp slt i16 %41, %45
  %47 = select i1 %46, i16 1, i16 -1
  %48 = add i16 %47, %41
  %49 = sub i16 -32768, %48
  %50 = icmp slt i16 %48, 0
  %51 = select i1 %50, i16 %49, i16 %48
  %52 = fcmp uno half %36, 0xH0000
  %53 = select i1 %52, i16 %38, i16 %51
  %54 = fcmp uno half %37, 0xH0000
  %55 = select i1 %54, i16 %42, i16 %53
  %56 = select i1 %20, i16 %55, i16 %51
  %57 = tail call half @llvm.fabs.f16(half %36)
  %58 = tail call half @llvm.fabs.f16(half %37)
  %59 = bitcast half %57 to i16
  %60 = bitcast half %58 to i16
  %61 = or i16 %60, %59
  %62 = icmp eq i16 %61, 0
  %63 = icmp eq i16 %38, %42
  %64 = or i1 %63, %62
  %65 = select i1 %64, i16 %42, i16 %56
  %66 = insertelement <2 x i16> %35, i16 %65, i64 1
  %67 = bitcast <2 x i16> %66 to <2 x half>
  ret <2 x half> %67
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_nextafter_f16(half noundef %0, half noundef %1) local_unnamed_addr #23 {
  %3 = bitcast half %0 to i16
  %4 = sub i16 -32768, %3
  %5 = icmp slt i16 %3, 0
  %6 = select i1 %5, i16 %4, i16 %3
  %7 = bitcast half %1 to i16
  %8 = sub i16 -32768, %7
  %9 = icmp slt i16 %7, 0
  %10 = select i1 %9, i16 %8, i16 %7
  %11 = icmp slt i16 %6, %10
  %12 = select i1 %11, i16 1, i16 -1
  %13 = add i16 %12, %6
  %14 = sub i16 -32768, %13
  %15 = icmp slt i16 %13, 0
  %16 = select i1 %15, i16 %14, i16 %13
  %17 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %18 = icmp eq i8 %17, 0
  %19 = fcmp uno half %0, 0xH0000
  %20 = select i1 %19, i16 %3, i16 %16
  %21 = fcmp uno half %1, 0xH0000
  %22 = select i1 %21, i16 %7, i16 %20
  %23 = select i1 %18, i16 %22, i16 %16
  %24 = tail call half @llvm.fabs.f16(half %0)
  %25 = tail call half @llvm.fabs.f16(half %1)
  %26 = bitcast half %24 to i16
  %27 = bitcast half %25 to i16
  %28 = or i16 %27, %26
  %29 = icmp eq i16 %28, 0
  %30 = icmp eq i16 %3, %7
  %31 = or i1 %30, %29
  %32 = select i1 %31, i16 %7, i16 %23
  %33 = bitcast i16 %32 to half
  ret half %33
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_pow_f64(double noundef %0, double noundef %1) local_unnamed_addr #21 {
  %3 = tail call double @llvm.fabs.f64(double %0)
  %4 = tail call spir_func <2 x double> @__ocmlpriv_epln_f64(double noundef %3) #38
  %5 = extractelement <2 x double> %4, i64 1
  %6 = fmul double %5, %1
  %7 = fneg double %6
  %8 = tail call double @llvm.fma.f64(double %1, double %5, double %7)
  %9 = extractelement <2 x double> %4, i64 0
  %10 = tail call double @llvm.fma.f64(double %1, double %9, double %8)
  %11 = fadd double %6, %10
  %12 = fsub double %11, %6
  %13 = fsub double %10, %12
  %14 = tail call double @llvm.fabs.f64(double %6)
  %15 = fcmp oeq double %14, 0x7FF0000000000000
  %16 = select i1 %15, double %6, double %11
  %17 = tail call double @llvm.fabs.f64(double %16)
  %18 = fcmp oeq double %17, 0x7FF0000000000000
  %19 = select i1 %18, double 0.000000e+00, double %13
  %20 = insertelement <2 x double> poison, double %19, i64 0
  %21 = insertelement <2 x double> %20, double %16, i64 1
  %22 = tail call spir_func double @__ocmlpriv_expep_f64(<2 x double> noundef %21) #38
  %23 = tail call double @llvm.fabs.f64(double %1)
  %24 = tail call double @llvm.trunc.f64(double %23)
  %25 = fcmp oeq double %23, %24
  %26 = fmul double %24, 5.000000e-01
  %27 = fptosi double %26 to i64
  %28 = sitofp i64 %27 to double
  %29 = fsub double %26, %28
  %30 = bitcast double %26 to i64
  %31 = icmp eq i64 %30, 9218868437227405312
  %32 = select i1 %31, double 0.000000e+00, double %29
  %33 = fcmp une double %32, 0.000000e+00
  %34 = and i1 %25, %33
  %35 = fcmp olt double %0, 0.000000e+00
  %36 = and i1 %35, %34
  %37 = select i1 %36, double -0.000000e+00, double 0.000000e+00
  %38 = tail call double @llvm.copysign.f64(double %22, double %37)
  %39 = fcmp uge double %0, 0.000000e+00
  %40 = or i1 %39, %25
  %41 = select i1 %40, double %38, double 0x7FF8000000000000
  %42 = fcmp oeq double %23, 0x7FF0000000000000
  br i1 %42, label %43, label %53

43:                                               ; preds = %2
  %44 = fcmp oeq double %3, 1.000000e+00
  br i1 %44, label %53, label %45

45:                                               ; preds = %43
  %46 = fadd double %3, -1.000000e+00
  %47 = bitcast double %1 to <2 x i32>
  %48 = bitcast double %46 to <2 x i32>
  %49 = xor <2 x i32> %48, %47
  %50 = extractelement <2 x i32> %49, i64 1
  %51 = icmp sgt i32 %50, -1
  %52 = select i1 %51, double 0x7FF0000000000000, double 0.000000e+00
  br label %53

53:                                               ; preds = %45, %43, %2
  %54 = phi double [ %41, %2 ], [ %52, %45 ], [ 1.000000e+00, %43 ]
  %55 = fcmp oeq double %3, 0x7FF0000000000000
  %56 = fcmp oeq double %0, 0.000000e+00
  %57 = or i1 %56, %55
  br i1 %57, label %58, label %64

58:                                               ; preds = %53
  %59 = fcmp olt double %1, 0.000000e+00
  %60 = xor i1 %56, %59
  %61 = select i1 %60, double 0.000000e+00, double 0x7FF0000000000000
  %62 = select i1 %34, double %0, double 0.000000e+00
  %63 = tail call double @llvm.copysign.f64(double %61, double %62)
  br label %64

64:                                               ; preds = %53, %58
  %65 = phi double [ %63, %58 ], [ %54, %53 ]
  %66 = fcmp uno double %0, %1
  %67 = select i1 %66, double 0x7FF8000000000000, double %65
  %68 = fcmp oeq double %0, 1.000000e+00
  %69 = fcmp oeq double %1, 0.000000e+00
  %70 = or i1 %68, %69
  %71 = select i1 %70, double 1.000000e+00, double %67
  ret double %71
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_pow_f32(float noundef %0, float noundef %1) local_unnamed_addr #21 {
  %3 = tail call float @llvm.fabs.f32(float %0)
  %4 = load i8, ptr addrspace(2) @__oclc_unsafe_math_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %27, label %6

6:                                                ; preds = %2
  %7 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %13, label %9

9:                                                ; preds = %6
  %10 = tail call float @llvm.log2.f32(float %3)
  %11 = fmul float %10, %1
  %12 = tail call float @llvm.exp2.f32(float %11)
  br label %87

13:                                               ; preds = %6
  %14 = fcmp olt float %3, 0x3810000000000000
  %15 = select i1 %14, float 0x4170000000000000, float 1.000000e+00
  %16 = fmul float %3, %15
  %17 = tail call float @llvm.log2.f32(float %16)
  %18 = select i1 %14, float 2.400000e+01, float 0.000000e+00
  %19 = fsub float %17, %18
  %20 = fmul float %19, %1
  %21 = fcmp olt float %20, -1.260000e+02
  %22 = select i1 %21, float 2.400000e+01, float 0.000000e+00
  %23 = fadd float %20, %22
  %24 = tail call float @llvm.exp2.f32(float %23)
  %25 = select i1 %21, float 0x3E70000000000000, float 1.000000e+00
  %26 = fmul float %25, %24
  br label %87

27:                                               ; preds = %2
  %28 = tail call spir_func <2 x float> @__ocmlpriv_epln_f32(float noundef %3) #38
  %29 = extractelement <2 x float> %28, i64 1
  %30 = fmul float %29, %1
  %31 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %32 = freeze i32 %31
  %33 = icmp sgt i32 %32, 8999
  br i1 %33, label %34, label %39

34:                                               ; preds = %27
  %35 = fneg float %30
  %36 = tail call float @llvm.fma.f32(float %1, float %29, float %35)
  %37 = insertelement <2 x float> poison, float %36, i64 0
  %38 = insertelement <2 x float> %37, float %30, i64 1
  br label %61

39:                                               ; preds = %27
  switch i32 %32, label %40 [
    i32 8001, label %54
    i32 7001, label %54
  ]

40:                                               ; preds = %39
  %41 = bitcast float %1 to i32
  %42 = and i32 %41, -4096
  %43 = bitcast i32 %42 to float
  %44 = fsub float %1, %43
  %45 = bitcast float %29 to i32
  %46 = and i32 %45, -4096
  %47 = bitcast i32 %46 to float
  %48 = fsub float %29, %47
  %49 = fneg float %30
  %50 = tail call float @llvm.fmuladd.f32(float %43, float %47, float %49)
  %51 = tail call float @llvm.fmuladd.f32(float %43, float %48, float %50)
  %52 = tail call float @llvm.fmuladd.f32(float %44, float %47, float %51)
  %53 = tail call float @llvm.fmuladd.f32(float %44, float %48, float %52)
  br label %57

54:                                               ; preds = %39, %39
  %55 = fneg float %30
  %56 = tail call float @llvm.fma.f32(float %1, float %29, float %55)
  br label %57

57:                                               ; preds = %54, %40
  %58 = phi float [ %56, %54 ], [ %53, %40 ]
  %59 = insertelement <2 x float> poison, float %58, i64 0
  %60 = insertelement <2 x float> %59, float %30, i64 1
  switch i32 %32, label %67 [
    i32 8001, label %61
    i32 7001, label %61
  ]

61:                                               ; preds = %57, %57, %34
  %62 = phi <2 x float> [ %60, %57 ], [ %60, %57 ], [ %38, %34 ]
  %63 = phi float [ %58, %57 ], [ %58, %57 ], [ %36, %34 ]
  %64 = extractelement <2 x float> %28, i64 0
  %65 = tail call float @llvm.fma.f32(float %1, float %64, float %63)
  %66 = insertelement <2 x float> %62, float %65, i64 0
  br label %71

67:                                               ; preds = %57
  %68 = extractelement <2 x float> %28, i64 0
  %69 = tail call float @llvm.fmuladd.f32(float %1, float %68, float %58)
  %70 = insertelement <2 x float> %60, float %69, i64 0
  br label %71

71:                                               ; preds = %61, %67
  %72 = phi <2 x float> [ %66, %61 ], [ %70, %67 ]
  %73 = extractelement <2 x float> %72, i64 1
  %74 = extractelement <2 x float> %72, i64 0
  %75 = fadd float %73, %74
  %76 = fsub float %75, %73
  %77 = fsub float %74, %76
  %78 = tail call float @llvm.fabs.f32(float %73)
  %79 = fcmp oeq float %78, 0x7FF0000000000000
  %80 = select i1 %79, float %73, float %75
  %81 = tail call float @llvm.fabs.f32(float %80)
  %82 = fcmp oeq float %81, 0x7FF0000000000000
  %83 = select i1 %82, float 0.000000e+00, float %77
  %84 = insertelement <2 x float> poison, float %83, i64 0
  %85 = insertelement <2 x float> %84, float %80, i64 1
  %86 = tail call spir_func float @__ocmlpriv_expep_f32(<2 x float> noundef %85) #38
  br label %87

87:                                               ; preds = %9, %13, %71
  %88 = phi float [ %12, %9 ], [ %26, %13 ], [ %86, %71 ]
  %89 = tail call float @llvm.fabs.f32(float %1)
  %90 = tail call float @llvm.trunc.f32(float %89)
  %91 = fcmp oeq float %89, %90
  %92 = fmul float %90, 5.000000e-01
  %93 = fptosi float %92 to i32
  %94 = sitofp i32 %93 to float
  %95 = fsub float %92, %94
  %96 = bitcast float %92 to i32
  %97 = icmp eq i32 %96, 2139095040
  %98 = select i1 %97, float 0.000000e+00, float %95
  %99 = fcmp une float %98, 0.000000e+00
  %100 = and i1 %91, %99
  %101 = fcmp olt float %0, 0.000000e+00
  %102 = and i1 %101, %100
  %103 = select i1 %102, float -0.000000e+00, float 0.000000e+00
  %104 = tail call float @llvm.copysign.f32(float %88, float %103)
  %105 = fcmp uge float %0, 0.000000e+00
  %106 = or i1 %105, %91
  %107 = select i1 %106, float %104, float 0x7FF8000000000000
  %108 = fcmp oeq float %89, 0x7FF0000000000000
  br i1 %108, label %109, label %118

109:                                              ; preds = %87
  %110 = fcmp oeq float %3, 1.000000e+00
  br i1 %110, label %118, label %111

111:                                              ; preds = %109
  %112 = fadd float %3, -1.000000e+00
  %113 = bitcast float %1 to i32
  %114 = bitcast float %112 to i32
  %115 = xor i32 %114, %113
  %116 = icmp sgt i32 %115, -1
  %117 = select i1 %116, float 0x7FF0000000000000, float 0.000000e+00
  br label %118

118:                                              ; preds = %111, %109, %87
  %119 = phi float [ %107, %87 ], [ %117, %111 ], [ 1.000000e+00, %109 ]
  %120 = fcmp oeq float %3, 0x7FF0000000000000
  %121 = fcmp oeq float %0, 0.000000e+00
  %122 = or i1 %121, %120
  br i1 %122, label %123, label %129

123:                                              ; preds = %118
  %124 = fcmp olt float %1, 0.000000e+00
  %125 = xor i1 %121, %124
  %126 = select i1 %125, float 0.000000e+00, float 0x7FF0000000000000
  %127 = select i1 %100, float %0, float 0.000000e+00
  %128 = tail call float @llvm.copysign.f32(float %126, float %127)
  br label %129

129:                                              ; preds = %118, %123
  %130 = phi float [ %128, %123 ], [ %119, %118 ]
  %131 = fcmp uno float %0, %1
  %132 = select i1 %131, float 0x7FF8000000000000, float %130
  %133 = fcmp oeq float %0, 1.000000e+00
  %134 = fcmp oeq float %1, 0.000000e+00
  %135 = or i1 %133, %134
  %136 = select i1 %135, float 1.000000e+00, float %132
  ret float %136
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_pow_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #23 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = tail call spir_func half @__ocml_pow_f16(half noundef %3, half noundef %4) #42
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = extractelement <2 x half> %1, i64 1
  %9 = tail call spir_func half @__ocml_pow_f16(half noundef %7, half noundef %8) #42
  %10 = insertelement <2 x half> %6, half %9, i64 1
  ret <2 x half> %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_pow_f16(half noundef %0, half noundef %1) local_unnamed_addr #26 {
  %3 = tail call half @llvm.fabs.f16(half %0)
  %4 = fpext half %1 to float
  %5 = fpext half %3 to float
  %6 = tail call float @llvm.log2.f32(float %5)
  %7 = fmul float %6, %4
  %8 = tail call float @llvm.exp2.f32(float %7)
  %9 = tail call half @llvm.fabs.f16(half %1)
  %10 = tail call half @llvm.trunc.f16(half %9)
  %11 = fcmp oeq half %9, %10
  %12 = zext i1 %11 to i32
  %13 = fmul half %10, 0xH3800
  %14 = tail call spir_func float @__builtin_generic_frac_f16.88(half noundef %13) #39
  %15 = fcmp oeq float %14, 0.000000e+00
  %16 = and i1 %11, %15
  %17 = zext i1 %16 to i32
  %18 = add nuw nsw i32 %17, %12
  %19 = fptrunc float %8 to half
  %20 = xor i1 %11, %16
  %21 = zext i1 %20 to i32
  %22 = fcmp olt half %0, 0xH0000
  %23 = and i1 %22, %20
  %24 = select i1 %23, half 0xH8000, half 0xH0000
  %25 = tail call half @llvm.copysign.f16(half %19, half %24)
  %26 = fcmp oeq half %0, 0xH0000
  %27 = fptoui half %1 to i16
  %28 = tail call spir_func i32 @__builtin_generic_class_f16.89(i16 noundef zeroext %27, i32 noundef 960) #39, !range !56
  %29 = icmp ne i32 %28, 0
  %30 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %32, label %120

32:                                               ; preds = %2
  %33 = tail call spir_func i32 @__builtin_generic_class_f16.89(i16 noundef zeroext %27, i32 noundef 512) #39, !range !56
  %34 = tail call spir_func i32 @__builtin_generic_class_f16.89(i16 noundef zeroext %27, i32 noundef 4) #39, !range !56
  %35 = fptoui half %9 to i16
  %36 = tail call spir_func i32 @__builtin_generic_class_f16.89(i16 noundef zeroext %35, i32 noundef 512) #39, !range !56
  %37 = fptoui half %0 to i16
  %38 = tail call spir_func i32 @__builtin_generic_class_f16.89(i16 noundef zeroext %37, i32 noundef 512) #39, !range !56
  %39 = tail call spir_func i32 @__builtin_generic_class_f16.89(i16 noundef zeroext %37, i32 noundef 4) #39, !range !56
  %40 = tail call spir_func i32 @__builtin_generic_class_f16.89(i16 noundef zeroext %37, i32 noundef 960) #39, !range !56
  %41 = icmp ne i32 %33, 0
  %42 = icmp ne i32 %34, 0
  %43 = fcmp uno half %1, 0xH0000
  %44 = icmp ne i32 %36, 0
  %45 = icmp ne i32 %38, 0
  %46 = icmp ne i32 %39, 0
  %47 = fcmp uno half %0, 0xH0000
  %48 = fcmp ogt half %3, 0xH3C00
  %49 = fcmp olt half %3, 0xH3C00
  %50 = or i32 %40, %18
  %51 = icmp eq i32 %50, 0
  %52 = select i1 %51, half 0xH7E00, half %25
  %53 = zext i1 %49 to i32
  %54 = zext i1 %42 to i32
  %55 = and i32 %54, %53
  %56 = icmp eq i32 %55, 0
  %57 = select i1 %56, half %52, half 0xH7C00
  %58 = zext i1 %48 to i32
  %59 = and i32 %54, %58
  %60 = zext i1 %41 to i32
  %61 = and i32 %60, %53
  %62 = or i32 %59, %61
  %63 = icmp eq i32 %62, 0
  %64 = select i1 %63, half %57, half 0xH0000
  %65 = and i32 %60, %58
  %66 = icmp eq i32 %65, 0
  %67 = select i1 %66, half %64, half 0xH7C00
  %68 = tail call half @llvm.copysign.f16(half 0xH7C00, half %0)
  %69 = zext i1 %26 to i32
  %70 = xor i1 %29, true
  %71 = zext i1 %70 to i32
  %72 = and i32 %71, %69
  %73 = and i32 %72, %21
  %74 = icmp eq i32 %73, 0
  %75 = select i1 %74, half %67, half %68
  %76 = icmp ne i32 %18, 1
  %77 = zext i1 %76 to i32
  %78 = and i32 %72, %77
  %79 = icmp eq i32 %78, 0
  %80 = select i1 %79, half %75, half 0xH7C00
  %81 = tail call half @llvm.copysign.f16(half 0xH0000, half %0)
  %82 = zext i1 %29 to i32
  %83 = and i32 %82, %69
  %84 = and i32 %83, %21
  %85 = icmp eq i32 %84, 0
  %86 = select i1 %85, half %80, half %81
  %87 = and i32 %83, %77
  %88 = icmp eq i32 %87, 0
  %89 = select i1 %88, half %86, half 0xH0000
  %90 = and i32 %54, %69
  %91 = icmp eq i32 %90, 0
  %92 = select i1 %91, half %89, half 0xH7C00
  %93 = fcmp oeq half %0, 0xHBC00
  %94 = and i1 %93, %44
  %95 = select i1 %94, half 0xH3C00, half %92
  %96 = zext i1 %46 to i32
  %97 = and i32 %96, %71
  %98 = and i32 %97, %21
  %99 = icmp eq i32 %98, 0
  %100 = select i1 %99, half %95, half 0xH8000
  %101 = and i32 %97, %77
  %102 = icmp eq i32 %101, 0
  %103 = select i1 %102, half %100, half 0xH0000
  %104 = and i32 %96, %82
  %105 = and i32 %104, %21
  %106 = icmp eq i32 %105, 0
  %107 = select i1 %106, half %103, half 0xHFC00
  %108 = and i32 %104, %77
  %109 = icmp eq i32 %108, 0
  %110 = select i1 %109, half %107, half 0xH7C00
  %111 = zext i1 %45 to i32
  %112 = and i32 %111, %71
  %113 = icmp eq i32 %112, 0
  %114 = select i1 %113, half %110, half 0xH0000
  %115 = and i32 %111, %82
  %116 = icmp eq i32 %115, 0
  %117 = select i1 %116, half %114, half 0xH7C00
  %118 = select i1 %47, half %0, half %117
  %119 = select i1 %43, half %1, half %118
  br label %142

120:                                              ; preds = %2
  %121 = tail call half @llvm.copysign.f16(half 0xH7C00, half %0)
  %122 = xor i1 %29, true
  %123 = and i1 %26, %122
  %124 = zext i1 %123 to i32
  %125 = and i32 %124, %21
  %126 = icmp eq i32 %125, 0
  %127 = select i1 %126, half %25, half %121
  %128 = icmp ne i32 %18, 1
  %129 = zext i1 %128 to i32
  %130 = and i32 %129, %124
  %131 = icmp eq i32 %130, 0
  %132 = select i1 %131, half %127, half 0xH7C00
  %133 = tail call half @llvm.copysign.f16(half 0xH0000, half %0)
  %134 = and i1 %26, %29
  %135 = zext i1 %134 to i32
  %136 = and i32 %135, %21
  %137 = icmp eq i32 %136, 0
  %138 = select i1 %137, half %132, half %133
  %139 = and i32 %129, %135
  %140 = icmp eq i32 %139, 0
  %141 = select i1 %140, half %138, half 0xH0000
  br label %142

142:                                              ; preds = %120, %32
  %143 = phi half [ %141, %120 ], [ %119, %32 ]
  %144 = fcmp oeq half %1, 0xH0000
  %145 = fcmp oeq half %0, 0xH3C00
  %146 = or i1 %145, %144
  %147 = select i1 %146, half 0xH3C00, half %143
  ret half %147
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func float @__builtin_generic_frac_f16.88(half noundef %0) unnamed_addr #25 {
  %2 = fptosi half %0 to i16
  %3 = sitofp i16 %2 to half
  %4 = fsub half %0, %3
  %5 = tail call half @llvm.fabs.f16(half %0)
  %6 = bitcast half %5 to i16
  %7 = icmp eq i16 %6, 31744
  %8 = fpext half %4 to float
  %9 = select i1 %7, float 0.000000e+00, float %8
  ret float %9
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16.89(i16 noundef zeroext %0, i32 noundef %1) unnamed_addr #25 {
  %3 = and i32 %1, 512
  %4 = icmp ne i32 %3, 0
  %5 = icmp eq i16 %0, 31744
  %6 = and i1 %5, %4
  br i1 %6, label %35, label %7

7:                                                ; preds = %2
  %8 = and i32 %1, 4
  %9 = icmp ne i32 %8, 0
  %10 = icmp eq i16 %0, -1024
  %11 = and i1 %10, %9
  br i1 %11, label %35, label %12

12:                                               ; preds = %7
  %13 = and i32 %1, 3
  %14 = icmp eq i32 %13, 0
  %15 = and i16 %0, 32256
  %16 = icmp eq i16 %15, 0
  %17 = or i1 %16, %14
  br i1 %17, label %18, label %35

18:                                               ; preds = %12
  %19 = and i32 %1, 96
  %20 = icmp ne i32 %19, 0
  %21 = and i16 %0, 32767
  %22 = icmp eq i16 %21, 0
  %23 = and i1 %22, %20
  br i1 %23, label %35, label %24

24:                                               ; preds = %18
  %25 = and i32 %1, 144
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %34, label %27

27:                                               ; preds = %24
  %28 = zext i16 %0 to i32
  %29 = and i32 %28, 31744
  %30 = icmp ne i32 %29, 0
  %31 = and i32 %28, 1023
  %32 = icmp eq i32 %31, 0
  %33 = or i1 %30, %32
  br i1 %33, label %34, label %35

34:                                               ; preds = %27, %24
  br label %35

35:                                               ; preds = %27, %18, %12, %7, %2, %34
  %36 = phi i32 [ 0, %34 ], [ -1, %2 ], [ -1, %7 ], [ -1, %12 ], [ -1, %18 ], [ -1, %27 ]
  ret i32 %36
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_pown_f64(double noundef %0, i32 noundef %1) local_unnamed_addr #21 {
  %3 = sitofp i32 %1 to double
  %4 = tail call double @llvm.fabs.f64(double %0)
  %5 = tail call spir_func <2 x double> @__ocmlpriv_epln_f64(double noundef %4) #38
  %6 = extractelement <2 x double> %5, i64 1
  %7 = fmul double %6, %3
  %8 = fneg double %7
  %9 = tail call double @llvm.fma.f64(double %3, double %6, double %8)
  %10 = extractelement <2 x double> %5, i64 0
  %11 = tail call double @llvm.fma.f64(double %3, double %10, double %9)
  %12 = fadd double %7, %11
  %13 = fsub double %12, %7
  %14 = fsub double %11, %13
  %15 = tail call double @llvm.fabs.f64(double %7)
  %16 = fcmp oeq double %15, 0x7FF0000000000000
  %17 = select i1 %16, double %7, double %12
  %18 = tail call double @llvm.fabs.f64(double %17)
  %19 = fcmp oeq double %18, 0x7FF0000000000000
  %20 = select i1 %19, double 0.000000e+00, double %14
  %21 = insertelement <2 x double> poison, double %20, i64 0
  %22 = insertelement <2 x double> %21, double %17, i64 1
  %23 = tail call spir_func double @__ocmlpriv_expep_f64(<2 x double> noundef %22) #38
  %24 = fcmp uge double %0, 0.000000e+00
  %25 = and i32 %1, 1
  %26 = icmp eq i32 %25, 0
  %27 = or i1 %24, %26
  %28 = select i1 %27, double 0.000000e+00, double -0.000000e+00
  %29 = tail call double @llvm.copysign.f64(double %23, double %28)
  %30 = fcmp oeq double %4, 0x7FF0000000000000
  %31 = fcmp oeq double %0, 0.000000e+00
  %32 = or i1 %31, %30
  br i1 %32, label %33, label %39

33:                                               ; preds = %2
  %34 = icmp sgt i32 %1, -1
  %35 = xor i1 %31, %34
  %36 = select i1 %35, double 0x7FF0000000000000, double 0.000000e+00
  %37 = select i1 %26, double 0.000000e+00, double %0
  %38 = tail call double @llvm.copysign.f64(double %36, double %37)
  br label %39

39:                                               ; preds = %2, %33
  %40 = phi double [ %38, %33 ], [ %29, %2 ]
  %41 = fcmp uno double %0, 0.000000e+00
  %42 = select i1 %41, double 0x7FF8000000000000, double %40
  %43 = icmp eq i32 %1, 0
  %44 = select i1 %43, double 1.000000e+00, double %42
  ret double %44
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_pown_f32(float noundef %0, i32 noundef %1) local_unnamed_addr #21 {
  %3 = tail call float @llvm.fabs.f32(float %0)
  %4 = load i8, ptr addrspace(2) @__oclc_unsafe_math_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %28, label %6

6:                                                ; preds = %2
  %7 = sitofp i32 %1 to float
  %8 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %14, label %10

10:                                               ; preds = %6
  %11 = tail call float @llvm.log2.f32(float %3)
  %12 = fmul float %11, %7
  %13 = tail call float @llvm.exp2.f32(float %12)
  br label %99

14:                                               ; preds = %6
  %15 = fcmp olt float %3, 0x3810000000000000
  %16 = select i1 %15, float 0x4170000000000000, float 1.000000e+00
  %17 = fmul float %3, %16
  %18 = tail call float @llvm.log2.f32(float %17)
  %19 = select i1 %15, float 2.400000e+01, float 0.000000e+00
  %20 = fsub float %18, %19
  %21 = fmul float %20, %7
  %22 = fcmp olt float %21, -1.260000e+02
  %23 = select i1 %22, float 2.400000e+01, float 0.000000e+00
  %24 = fadd float %21, %23
  %25 = tail call float @llvm.exp2.f32(float %24)
  %26 = select i1 %22, float 0x3E70000000000000, float 1.000000e+00
  %27 = fmul float %26, %25
  br label %99

28:                                               ; preds = %2
  %29 = and i32 %1, -65536
  %30 = sitofp i32 %29 to float
  %31 = and i32 %1, 65535
  %32 = sitofp i32 %31 to float
  %33 = fadd float %30, %32
  %34 = fsub float %30, %33
  %35 = fadd float %34, %32
  %36 = tail call spir_func <2 x float> @__ocmlpriv_epln_f32(float noundef %3) #38
  %37 = extractelement <2 x float> %36, i64 1
  %38 = fmul float %33, %37
  %39 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %40 = freeze i32 %39
  %41 = icmp sgt i32 %40, 8999
  br i1 %41, label %42, label %47

42:                                               ; preds = %28
  %43 = fneg float %38
  %44 = tail call float @llvm.fma.f32(float %33, float %37, float %43)
  %45 = insertelement <2 x float> poison, float %44, i64 0
  %46 = insertelement <2 x float> %45, float %38, i64 1
  br label %69

47:                                               ; preds = %28
  switch i32 %40, label %48 [
    i32 8001, label %62
    i32 7001, label %62
  ]

48:                                               ; preds = %47
  %49 = bitcast float %33 to i32
  %50 = and i32 %49, -4096
  %51 = bitcast i32 %50 to float
  %52 = fsub float %33, %51
  %53 = bitcast float %37 to i32
  %54 = and i32 %53, -4096
  %55 = bitcast i32 %54 to float
  %56 = fsub float %37, %55
  %57 = fneg float %38
  %58 = tail call float @llvm.fmuladd.f32(float %51, float %55, float %57)
  %59 = tail call float @llvm.fmuladd.f32(float %51, float %56, float %58)
  %60 = tail call float @llvm.fmuladd.f32(float %52, float %55, float %59)
  %61 = tail call float @llvm.fmuladd.f32(float %52, float %56, float %60)
  br label %65

62:                                               ; preds = %47, %47
  %63 = fneg float %38
  %64 = tail call float @llvm.fma.f32(float %33, float %37, float %63)
  br label %65

65:                                               ; preds = %62, %48
  %66 = phi float [ %64, %62 ], [ %61, %48 ]
  %67 = insertelement <2 x float> poison, float %66, i64 0
  %68 = insertelement <2 x float> %67, float %38, i64 1
  switch i32 %40, label %77 [
    i32 8001, label %69
    i32 7001, label %69
  ]

69:                                               ; preds = %65, %65, %42
  %70 = phi <2 x float> [ %68, %65 ], [ %68, %65 ], [ %46, %42 ]
  %71 = phi float [ %66, %65 ], [ %66, %65 ], [ %44, %42 ]
  %72 = extractelement <2 x float> %36, i64 0
  %73 = fmul float %35, %37
  %74 = tail call float @llvm.fma.f32(float %33, float %72, float %73)
  %75 = fadd float %74, %71
  %76 = insertelement <2 x float> %70, float %75, i64 0
  br label %83

77:                                               ; preds = %65
  %78 = extractelement <2 x float> %36, i64 0
  %79 = fmul float %35, %37
  %80 = tail call float @llvm.fmuladd.f32(float %33, float %78, float %79)
  %81 = fadd float %80, %66
  %82 = insertelement <2 x float> %68, float %81, i64 0
  br label %83

83:                                               ; preds = %69, %77
  %84 = phi <2 x float> [ %76, %69 ], [ %82, %77 ]
  %85 = extractelement <2 x float> %84, i64 1
  %86 = extractelement <2 x float> %84, i64 0
  %87 = fadd float %85, %86
  %88 = fsub float %87, %85
  %89 = fsub float %86, %88
  %90 = tail call float @llvm.fabs.f32(float %85)
  %91 = fcmp oeq float %90, 0x7FF0000000000000
  %92 = select i1 %91, float %85, float %87
  %93 = tail call float @llvm.fabs.f32(float %92)
  %94 = fcmp oeq float %93, 0x7FF0000000000000
  %95 = select i1 %94, float 0.000000e+00, float %89
  %96 = insertelement <2 x float> poison, float %95, i64 0
  %97 = insertelement <2 x float> %96, float %92, i64 1
  %98 = tail call spir_func float @__ocmlpriv_expep_f32(<2 x float> noundef %97) #38
  br label %99

99:                                               ; preds = %10, %14, %83
  %100 = phi float [ %98, %83 ], [ %13, %10 ], [ %27, %14 ]
  %101 = fcmp uge float %0, 0.000000e+00
  %102 = and i32 %1, 1
  %103 = icmp eq i32 %102, 0
  %104 = or i1 %101, %103
  %105 = select i1 %104, float 0.000000e+00, float -0.000000e+00
  %106 = tail call float @llvm.copysign.f32(float %100, float %105)
  %107 = fcmp oeq float %3, 0x7FF0000000000000
  %108 = fcmp oeq float %0, 0.000000e+00
  %109 = or i1 %108, %107
  br i1 %109, label %110, label %116

110:                                              ; preds = %99
  %111 = icmp sgt i32 %1, -1
  %112 = xor i1 %108, %111
  %113 = select i1 %112, float 0x7FF0000000000000, float 0.000000e+00
  %114 = select i1 %103, float 0.000000e+00, float %0
  %115 = tail call float @llvm.copysign.f32(float %113, float %114)
  br label %116

116:                                              ; preds = %99, %110
  %117 = phi float [ %115, %110 ], [ %106, %99 ]
  %118 = fcmp uno float %0, 0.000000e+00
  %119 = select i1 %118, float 0x7FF8000000000000, float %117
  %120 = icmp eq i32 %1, 0
  %121 = select i1 %120, float 1.000000e+00, float %119
  ret float %121
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_pown_2f16(<2 x half> noundef %0, <2 x i32> noundef %1) local_unnamed_addr #23 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x i32> %1, i64 0
  %5 = tail call spir_func half @__ocml_pown_f16(half noundef %3, i32 noundef %4) #44
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = extractelement <2 x i32> %1, i64 1
  %9 = tail call spir_func half @__ocml_pown_f16(half noundef %7, i32 noundef %8) #44
  %10 = insertelement <2 x half> %6, half %9, i64 1
  ret <2 x half> %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_pown_f16(half noundef %0, i32 noundef %1) local_unnamed_addr #26 {
  %3 = tail call half @llvm.fabs.f16(half %0)
  %4 = sitofp i32 %1 to float
  %5 = fpext half %3 to float
  %6 = tail call float @llvm.log2.f32(float %5)
  %7 = fmul float %6, %4
  %8 = tail call float @llvm.exp2.f32(float %7)
  %9 = fptrunc float %8 to half
  %10 = fcmp uge half %0, 0xH0000
  %11 = and i32 %1, 1
  %12 = icmp eq i32 %11, 0
  %13 = or i1 %10, %12
  %14 = select i1 %13, half 0xH0000, half 0xH8000
  %15 = tail call half @llvm.copysign.f16(half %9, half %14)
  %16 = fcmp oeq half %0, 0xH0000
  %17 = icmp sgt i32 %1, -1
  %18 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %20, label %71

20:                                               ; preds = %2
  %21 = fptoui half %0 to i16
  %22 = tail call spir_func i32 @__builtin_generic_class_f16.90(i16 noundef zeroext %21, i32 noundef 512) #39, !range !56
  %23 = tail call spir_func i32 @__builtin_generic_class_f16.90(i16 noundef zeroext %21, i32 noundef 4) #39, !range !56
  %24 = fcmp uno half %0, 0xH0000
  %25 = icmp ne i32 %22, 0
  %26 = icmp ne i32 %23, 0
  %27 = tail call half @llvm.copysign.f16(half 0xH7C00, half %0)
  %28 = zext i1 %16 to i32
  %29 = xor i1 %17, true
  %30 = zext i1 %29 to i32
  %31 = and i32 %30, %28
  %32 = and i32 %31, %11
  %33 = icmp eq i32 %32, 0
  %34 = select i1 %33, half %15, half %27
  %35 = xor i32 %11, 1
  %36 = and i32 %31, %35
  %37 = icmp eq i32 %36, 0
  %38 = select i1 %37, half %34, half 0xH7C00
  %39 = zext i1 %17 to i32
  %40 = and i32 %39, %28
  %41 = and i32 %40, %35
  %42 = icmp eq i32 %41, 0
  %43 = select i1 %42, half %38, half 0xH0000
  %44 = tail call half @llvm.copysign.f16(half 0xH0000, half %0)
  %45 = and i32 %40, %11
  %46 = icmp eq i32 %45, 0
  %47 = select i1 %46, half %43, half %44
  %48 = zext i1 %26 to i32
  %49 = and i32 %48, %30
  %50 = and i32 %49, %11
  %51 = icmp eq i32 %50, 0
  %52 = select i1 %51, half %47, half 0xH8000
  %53 = and i32 %49, %35
  %54 = icmp eq i32 %53, 0
  %55 = select i1 %54, half %52, half 0xH0000
  %56 = and i32 %48, %39
  %57 = and i32 %56, %11
  %58 = icmp eq i32 %57, 0
  %59 = select i1 %58, half %55, half 0xHFC00
  %60 = and i32 %56, %35
  %61 = icmp eq i32 %60, 0
  %62 = select i1 %61, half %59, half 0xH7C00
  %63 = zext i1 %25 to i32
  %64 = and i32 %63, %30
  %65 = icmp eq i32 %64, 0
  %66 = select i1 %65, half %62, half 0xH0000
  %67 = and i32 %63, %39
  %68 = icmp eq i32 %67, 0
  %69 = select i1 %68, half %66, half 0xH7C00
  %70 = select i1 %24, half %0, half %69
  br label %82

71:                                               ; preds = %2
  %72 = tail call half @llvm.copysign.f16(half 0xH0000, half %0)
  %73 = and i1 %16, %17
  %74 = zext i1 %73 to i32
  %75 = and i32 %74, %1
  %76 = icmp eq i32 %75, 0
  %77 = select i1 %76, half %15, half %72
  %78 = xor i32 %1, -1
  %79 = and i32 %74, %78
  %80 = icmp eq i32 %79, 0
  %81 = select i1 %80, half %77, half 0xH0000
  br label %82

82:                                               ; preds = %71, %20
  %83 = phi half [ %81, %71 ], [ %70, %20 ]
  %84 = icmp eq i32 %1, 0
  %85 = select i1 %84, half 0xH3C00, half %83
  ret half %85
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16.90(i16 noundef zeroext %0, i32 noundef %1) unnamed_addr #25 {
  %3 = and i32 %1, 512
  %4 = icmp ne i32 %3, 0
  %5 = icmp eq i16 %0, 31744
  %6 = and i1 %5, %4
  br i1 %6, label %35, label %7

7:                                                ; preds = %2
  %8 = and i32 %1, 4
  %9 = icmp ne i32 %8, 0
  %10 = icmp eq i16 %0, -1024
  %11 = and i1 %10, %9
  br i1 %11, label %35, label %12

12:                                               ; preds = %7
  %13 = and i32 %1, 3
  %14 = icmp eq i32 %13, 0
  %15 = and i16 %0, 32256
  %16 = icmp eq i16 %15, 0
  %17 = or i1 %16, %14
  br i1 %17, label %18, label %35

18:                                               ; preds = %12
  %19 = and i32 %1, 96
  %20 = icmp ne i32 %19, 0
  %21 = and i16 %0, 32767
  %22 = icmp eq i16 %21, 0
  %23 = and i1 %22, %20
  br i1 %23, label %35, label %24

24:                                               ; preds = %18
  %25 = and i32 %1, 144
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %34, label %27

27:                                               ; preds = %24
  %28 = zext i16 %0 to i32
  %29 = and i32 %28, 31744
  %30 = icmp ne i32 %29, 0
  %31 = and i32 %28, 1023
  %32 = icmp eq i32 %31, 0
  %33 = or i1 %30, %32
  br i1 %33, label %34, label %35

34:                                               ; preds = %27, %24
  br label %35

35:                                               ; preds = %27, %18, %12, %7, %2, %34
  %36 = phi i32 [ 0, %34 ], [ -1, %2 ], [ -1, %7 ], [ -1, %12 ], [ -1, %18 ], [ -1, %27 ]
  ret i32 %36
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_powr_f64(double noundef %0, double noundef %1) local_unnamed_addr #21 {
  %3 = tail call double @llvm.fabs.f64(double %0)
  %4 = tail call spir_func <2 x double> @__ocmlpriv_epln_f64(double noundef %3) #38
  %5 = extractelement <2 x double> %4, i64 1
  %6 = fmul double %5, %1
  %7 = fneg double %6
  %8 = tail call double @llvm.fma.f64(double %1, double %5, double %7)
  %9 = extractelement <2 x double> %4, i64 0
  %10 = tail call double @llvm.fma.f64(double %1, double %9, double %8)
  %11 = fadd double %6, %10
  %12 = fsub double %11, %6
  %13 = fsub double %10, %12
  %14 = tail call double @llvm.fabs.f64(double %6)
  %15 = fcmp oeq double %14, 0x7FF0000000000000
  %16 = select i1 %15, double %6, double %11
  %17 = tail call double @llvm.fabs.f64(double %16)
  %18 = fcmp oeq double %17, 0x7FF0000000000000
  %19 = select i1 %18, double 0.000000e+00, double %13
  %20 = insertelement <2 x double> poison, double %19, i64 0
  %21 = insertelement <2 x double> %20, double %16, i64 1
  %22 = tail call spir_func double @__ocmlpriv_expep_f64(<2 x double> noundef %21) #38
  %23 = tail call double @llvm.fabs.f64(double %1)
  %24 = tail call double @llvm.trunc.f64(double %23)
  %25 = fcmp oeq double %23, %24
  %26 = fmul double %24, 5.000000e-01
  %27 = fptosi double %26 to i64
  %28 = sitofp i64 %27 to double
  %29 = fsub double %26, %28
  %30 = bitcast double %26 to i64
  %31 = icmp eq i64 %30, 9218868437227405312
  %32 = select i1 %31, double 0.000000e+00, double %29
  %33 = fcmp une double %32, 0.000000e+00
  %34 = and i1 %25, %33
  %35 = fcmp olt double %0, 0.000000e+00
  %36 = and i1 %35, %34
  %37 = select i1 %36, double -0.000000e+00, double 0.000000e+00
  %38 = tail call double @llvm.copysign.f64(double %22, double %37)
  %39 = fcmp olt double %1, 0.000000e+00
  %40 = select i1 %39, double 0x7FF0000000000000, double 0.000000e+00
  %41 = select i1 %39, double 0.000000e+00, double 0x7FF0000000000000
  %42 = fcmp oeq double %0, 0.000000e+00
  %43 = select i1 %42, double %40, double %38
  %44 = fcmp oeq double %3, 0x7FF0000000000000
  %45 = select i1 %44, double %41, double %43
  %46 = fcmp oeq double %23, 0x7FF0000000000000
  %47 = fcmp olt double %3, 1.000000e+00
  %48 = select i1 %47, double %40, double %41
  %49 = select i1 %46, double %48, double %45
  %50 = fcmp oeq double %1, 0.000000e+00
  %51 = or i1 %42, %44
  %52 = select i1 %51, double 0x7FF8000000000000, double 1.000000e+00
  %53 = select i1 %50, double %52, double %49
  %54 = fcmp oeq double %0, 1.000000e+00
  %55 = select i1 %46, double 0x7FF8000000000000, double 1.000000e+00
  %56 = select i1 %54, double %55, double %53
  %57 = fcmp ult double %0, 0.000000e+00
  %58 = fcmp uno double %1, 0.000000e+00
  %59 = or i1 %57, %58
  %60 = select i1 %59, double 0x7FF8000000000000, double %56
  ret double %60
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_powr_f32(float noundef %0, float noundef %1) local_unnamed_addr #21 {
  %3 = tail call float @llvm.fabs.f32(float %0)
  %4 = load i8, ptr addrspace(2) @__oclc_unsafe_math_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %27, label %6

6:                                                ; preds = %2
  %7 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %13, label %9

9:                                                ; preds = %6
  %10 = tail call float @llvm.log2.f32(float %3)
  %11 = fmul float %10, %1
  %12 = tail call float @llvm.exp2.f32(float %11)
  br label %87

13:                                               ; preds = %6
  %14 = fcmp olt float %3, 0x3810000000000000
  %15 = select i1 %14, float 0x4170000000000000, float 1.000000e+00
  %16 = fmul float %3, %15
  %17 = tail call float @llvm.log2.f32(float %16)
  %18 = select i1 %14, float 2.400000e+01, float 0.000000e+00
  %19 = fsub float %17, %18
  %20 = fmul float %19, %1
  %21 = fcmp olt float %20, -1.260000e+02
  %22 = select i1 %21, float 2.400000e+01, float 0.000000e+00
  %23 = fadd float %20, %22
  %24 = tail call float @llvm.exp2.f32(float %23)
  %25 = select i1 %21, float 0x3E70000000000000, float 1.000000e+00
  %26 = fmul float %25, %24
  br label %87

27:                                               ; preds = %2
  %28 = tail call spir_func <2 x float> @__ocmlpriv_epln_f32(float noundef %3) #38
  %29 = extractelement <2 x float> %28, i64 1
  %30 = fmul float %29, %1
  %31 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %32 = freeze i32 %31
  %33 = icmp sgt i32 %32, 8999
  br i1 %33, label %34, label %39

34:                                               ; preds = %27
  %35 = fneg float %30
  %36 = tail call float @llvm.fma.f32(float %1, float %29, float %35)
  %37 = insertelement <2 x float> poison, float %36, i64 0
  %38 = insertelement <2 x float> %37, float %30, i64 1
  br label %61

39:                                               ; preds = %27
  switch i32 %32, label %40 [
    i32 8001, label %54
    i32 7001, label %54
  ]

40:                                               ; preds = %39
  %41 = bitcast float %1 to i32
  %42 = and i32 %41, -4096
  %43 = bitcast i32 %42 to float
  %44 = fsub float %1, %43
  %45 = bitcast float %29 to i32
  %46 = and i32 %45, -4096
  %47 = bitcast i32 %46 to float
  %48 = fsub float %29, %47
  %49 = fneg float %30
  %50 = tail call float @llvm.fmuladd.f32(float %43, float %47, float %49)
  %51 = tail call float @llvm.fmuladd.f32(float %43, float %48, float %50)
  %52 = tail call float @llvm.fmuladd.f32(float %44, float %47, float %51)
  %53 = tail call float @llvm.fmuladd.f32(float %44, float %48, float %52)
  br label %57

54:                                               ; preds = %39, %39
  %55 = fneg float %30
  %56 = tail call float @llvm.fma.f32(float %1, float %29, float %55)
  br label %57

57:                                               ; preds = %54, %40
  %58 = phi float [ %56, %54 ], [ %53, %40 ]
  %59 = insertelement <2 x float> poison, float %58, i64 0
  %60 = insertelement <2 x float> %59, float %30, i64 1
  switch i32 %32, label %67 [
    i32 8001, label %61
    i32 7001, label %61
  ]

61:                                               ; preds = %57, %57, %34
  %62 = phi <2 x float> [ %60, %57 ], [ %60, %57 ], [ %38, %34 ]
  %63 = phi float [ %58, %57 ], [ %58, %57 ], [ %36, %34 ]
  %64 = extractelement <2 x float> %28, i64 0
  %65 = tail call float @llvm.fma.f32(float %1, float %64, float %63)
  %66 = insertelement <2 x float> %62, float %65, i64 0
  br label %71

67:                                               ; preds = %57
  %68 = extractelement <2 x float> %28, i64 0
  %69 = tail call float @llvm.fmuladd.f32(float %1, float %68, float %58)
  %70 = insertelement <2 x float> %60, float %69, i64 0
  br label %71

71:                                               ; preds = %61, %67
  %72 = phi <2 x float> [ %66, %61 ], [ %70, %67 ]
  %73 = extractelement <2 x float> %72, i64 1
  %74 = extractelement <2 x float> %72, i64 0
  %75 = fadd float %73, %74
  %76 = fsub float %75, %73
  %77 = fsub float %74, %76
  %78 = tail call float @llvm.fabs.f32(float %73)
  %79 = fcmp oeq float %78, 0x7FF0000000000000
  %80 = select i1 %79, float %73, float %75
  %81 = tail call float @llvm.fabs.f32(float %80)
  %82 = fcmp oeq float %81, 0x7FF0000000000000
  %83 = select i1 %82, float 0.000000e+00, float %77
  %84 = insertelement <2 x float> poison, float %83, i64 0
  %85 = insertelement <2 x float> %84, float %80, i64 1
  %86 = tail call spir_func float @__ocmlpriv_expep_f32(<2 x float> noundef %85) #38
  br label %87

87:                                               ; preds = %9, %13, %71
  %88 = phi float [ %12, %9 ], [ %26, %13 ], [ %86, %71 ]
  %89 = tail call float @llvm.fabs.f32(float %1)
  %90 = tail call float @llvm.trunc.f32(float %89)
  %91 = fcmp oeq float %89, %90
  %92 = fmul float %90, 5.000000e-01
  %93 = fptosi float %92 to i32
  %94 = sitofp i32 %93 to float
  %95 = fsub float %92, %94
  %96 = bitcast float %92 to i32
  %97 = icmp eq i32 %96, 2139095040
  %98 = select i1 %97, float 0.000000e+00, float %95
  %99 = fcmp une float %98, 0.000000e+00
  %100 = and i1 %91, %99
  %101 = fcmp olt float %0, 0.000000e+00
  %102 = and i1 %101, %100
  %103 = select i1 %102, float -0.000000e+00, float 0.000000e+00
  %104 = tail call float @llvm.copysign.f32(float %88, float %103)
  %105 = fcmp olt float %1, 0.000000e+00
  %106 = select i1 %105, float 0x7FF0000000000000, float 0.000000e+00
  %107 = select i1 %105, float 0.000000e+00, float 0x7FF0000000000000
  %108 = fcmp oeq float %0, 0.000000e+00
  %109 = select i1 %108, float %106, float %104
  %110 = fcmp oeq float %3, 0x7FF0000000000000
  %111 = select i1 %110, float %107, float %109
  %112 = fcmp oeq float %89, 0x7FF0000000000000
  %113 = fcmp olt float %3, 1.000000e+00
  %114 = select i1 %113, float %106, float %107
  %115 = select i1 %112, float %114, float %111
  %116 = fcmp oeq float %1, 0.000000e+00
  %117 = or i1 %108, %110
  %118 = select i1 %117, float 0x7FF8000000000000, float 1.000000e+00
  %119 = select i1 %116, float %118, float %115
  %120 = fcmp oeq float %0, 1.000000e+00
  %121 = select i1 %112, float 0x7FF8000000000000, float 1.000000e+00
  %122 = select i1 %120, float %121, float %119
  %123 = fcmp ult float %0, 0.000000e+00
  %124 = fcmp uno float %1, 0.000000e+00
  %125 = or i1 %123, %124
  %126 = select i1 %125, float 0x7FF8000000000000, float %122
  ret float %126
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_powr_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #23 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = tail call spir_func half @__ocml_powr_f16(half noundef %3, half noundef %4) #42
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = extractelement <2 x half> %1, i64 1
  %9 = tail call spir_func half @__ocml_powr_f16(half noundef %7, half noundef %8) #42
  %10 = insertelement <2 x half> %6, half %9, i64 1
  ret <2 x half> %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_powr_f16(half noundef %0, half noundef %1) local_unnamed_addr #26 {
  %3 = tail call half @llvm.fabs.f16(half %0)
  %4 = fpext half %1 to float
  %5 = fpext half %3 to float
  %6 = tail call float @llvm.log2.f32(float %5)
  %7 = fmul float %6, %4
  %8 = tail call float @llvm.exp2.f32(float %7)
  %9 = tail call half @llvm.fabs.f16(half %1)
  %10 = tail call half @llvm.trunc.f16(half %9)
  %11 = fcmp oeq half %9, %10
  %12 = fmul half %10, 0xH3800
  %13 = tail call spir_func float @__builtin_generic_frac_f16.91(half noundef %12) #39
  %14 = fcmp une float %13, 0.000000e+00
  %15 = fptrunc float %8 to half
  %16 = and i1 %11, %14
  %17 = fcmp olt half %0, 0xH0000
  %18 = and i1 %17, %16
  %19 = select i1 %18, half 0xH8000, half 0xH0000
  %20 = tail call half @llvm.copysign.f16(half %15, half %19)
  %21 = fcmp oeq half %0, 0xH0000
  %22 = fcmp oeq half %3, 0xH3C00
  %23 = fcmp oeq half %1, 0xH0000
  %24 = fptoui half %1 to i16
  %25 = tail call spir_func i32 @__builtin_generic_class_f16.92(i16 noundef zeroext %24, i32 noundef 960) #39, !range !56
  %26 = icmp ne i32 %25, 0
  %27 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %29, label %102

29:                                               ; preds = %2
  %30 = tail call spir_func i32 @__builtin_generic_class_f16.92(i16 noundef zeroext %24, i32 noundef 384) #39, !range !56
  %31 = tail call spir_func i32 @__builtin_generic_class_f16.92(i16 noundef zeroext %24, i32 noundef 512) #39, !range !56
  %32 = tail call spir_func i32 @__builtin_generic_class_f16.92(i16 noundef zeroext %24, i32 noundef 4) #39, !range !56
  %33 = fptoui half %9 to i16
  %34 = tail call spir_func i32 @__builtin_generic_class_f16.92(i16 noundef zeroext %33, i32 noundef 512) #39, !range !56
  %35 = fptoui half %0 to i16
  %36 = tail call spir_func i32 @__builtin_generic_class_f16.92(i16 noundef zeroext %35, i32 noundef 960) #39, !range !56
  %37 = tail call spir_func i32 @__builtin_generic_class_f16.92(i16 noundef zeroext %35, i32 noundef 512) #39, !range !56
  %38 = tail call spir_func i32 @__builtin_generic_class_f16.92(i16 noundef zeroext %35, i32 noundef 384) #39, !range !56
  %39 = icmp ne i32 %30, 0
  %40 = icmp ne i32 %31, 0
  %41 = icmp ne i32 %32, 0
  %42 = fcmp uno half %1, 0xH0000
  %43 = icmp ne i32 %34, 0
  %44 = icmp eq i32 %36, 0
  %45 = fcmp uno half %0, 0xH0000
  %46 = icmp ne i32 %37, 0
  %47 = icmp ne i32 %38, 0
  %48 = fcmp ogt half %3, 0xH3C00
  %49 = fcmp olt half %3, 0xH3C00
  %50 = fcmp une half %0, 0xH0000
  %51 = zext i1 %49 to i32
  %52 = zext i1 %41 to i32
  %53 = and i32 %52, %51
  %54 = icmp eq i32 %53, 0
  %55 = select i1 %54, half %20, half 0xH7C00
  %56 = zext i1 %40 to i32
  %57 = and i32 %56, %51
  %58 = icmp eq i32 %57, 0
  %59 = select i1 %58, half %55, half 0xH0000
  %60 = and i1 %22, %39
  %61 = select i1 %60, half 0xH3C00, half %59
  %62 = and i1 %22, %43
  %63 = select i1 %62, half 0xH7E00, half %61
  %64 = zext i1 %48 to i32
  %65 = and i32 %52, %64
  %66 = icmp eq i32 %65, 0
  %67 = select i1 %66, half %63, half 0xH0000
  %68 = and i32 %56, %64
  %69 = icmp eq i32 %68, 0
  %70 = select i1 %69, half %67, half 0xH7C00
  %71 = zext i1 %23 to i32
  %72 = and i1 %23, %47
  %73 = select i1 %72, half 0xH3C00, half %70
  %74 = zext i1 %46 to i32
  %75 = xor i1 %26, true
  %76 = zext i1 %75 to i32
  %77 = and i32 %74, %76
  %78 = icmp eq i32 %77, 0
  %79 = select i1 %78, half %73, half 0xH0000
  %80 = zext i1 %26 to i32
  %81 = or i32 %56, %80
  %82 = and i32 %81, %74
  %83 = icmp eq i32 %82, 0
  %84 = select i1 %83, half %79, half 0xH7C00
  %85 = and i32 %74, %71
  %86 = icmp eq i32 %85, 0
  %87 = select i1 %86, half %84, half 0xH7E00
  %88 = zext i1 %21 to i32
  %89 = and i32 %76, %88
  %90 = icmp eq i32 %89, 0
  %91 = select i1 %90, half %87, half 0xH7C00
  %92 = and i32 %80, %88
  %93 = icmp eq i32 %92, 0
  %94 = select i1 %93, half %91, half 0xH0000
  %95 = and i32 %71, %88
  %96 = icmp eq i32 %95, 0
  %97 = select i1 %96, half %94, half 0xH7E00
  %98 = and i1 %50, %44
  %99 = select i1 %98, half 0xH7E00, half %97
  %100 = select i1 %45, half %0, half %99
  %101 = select i1 %42, half %1, half %100
  br label %107

102:                                              ; preds = %2
  %103 = or i1 %23, %22
  %104 = select i1 %103, half 0xH3C00, half %20
  %105 = and i1 %21, %26
  %106 = select i1 %105, half 0xH0000, half %104
  br label %107

107:                                              ; preds = %102, %29
  %108 = phi half [ %106, %102 ], [ %101, %29 ]
  ret half %108
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func float @__builtin_generic_frac_f16.91(half noundef %0) unnamed_addr #25 {
  %2 = fptosi half %0 to i16
  %3 = sitofp i16 %2 to half
  %4 = fsub half %0, %3
  %5 = tail call half @llvm.fabs.f16(half %0)
  %6 = bitcast half %5 to i16
  %7 = icmp eq i16 %6, 31744
  %8 = fpext half %4 to float
  %9 = select i1 %7, float 0.000000e+00, float %8
  ret float %9
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16.92(i16 noundef zeroext %0, i32 noundef %1) unnamed_addr #25 {
  %3 = and i32 %1, 512
  %4 = icmp ne i32 %3, 0
  %5 = icmp eq i16 %0, 31744
  %6 = and i1 %5, %4
  br i1 %6, label %35, label %7

7:                                                ; preds = %2
  %8 = and i32 %1, 4
  %9 = icmp ne i32 %8, 0
  %10 = icmp eq i16 %0, -1024
  %11 = and i1 %10, %9
  br i1 %11, label %35, label %12

12:                                               ; preds = %7
  %13 = and i32 %1, 3
  %14 = icmp eq i32 %13, 0
  %15 = and i16 %0, 32256
  %16 = icmp eq i16 %15, 0
  %17 = or i1 %16, %14
  br i1 %17, label %18, label %35

18:                                               ; preds = %12
  %19 = and i32 %1, 96
  %20 = icmp ne i32 %19, 0
  %21 = and i16 %0, 32767
  %22 = icmp eq i16 %21, 0
  %23 = and i1 %22, %20
  br i1 %23, label %35, label %24

24:                                               ; preds = %18
  %25 = and i32 %1, 144
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %34, label %27

27:                                               ; preds = %24
  %28 = zext i16 %0 to i32
  %29 = and i32 %28, 31744
  %30 = icmp ne i32 %29, 0
  %31 = and i32 %28, 1023
  %32 = icmp eq i32 %31, 0
  %33 = or i1 %30, %32
  br i1 %33, label %34, label %35

34:                                               ; preds = %27, %24
  br label %35

35:                                               ; preds = %27, %18, %12, %7, %2, %34
  %36 = phi i32 [ 0, %34 ], [ -1, %2 ], [ -1, %7 ], [ -1, %12 ], [ -1, %18 ], [ -1, %27 ]
  ret i32 %36
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_rcbrt_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca i32, align 4
  %3 = tail call double @llvm.fabs.f64(double %0)
  %4 = fptrunc double %3 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %5 = addrspacecast ptr %2 to ptr addrspace(4)
  %6 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %4, ptr addrspace(4) noundef %5) #40
  %7 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  %8 = sitofp i32 %7 to float
  %9 = fmul float %8, 0x3FD5555560000000
  %10 = call float @llvm.rint.f32(float %9)
  %11 = fptosi float %10 to i32
  %12 = mul nsw i32 %11, -3
  %13 = call spir_func double @_Z5ldexpdi(double noundef %3, i32 noundef %12) #38
  %14 = fptrunc double %13 to float
  %15 = call float @llvm.log2.f32(float %14)
  %16 = fmul float %15, 0xBFD5555560000000
  %17 = call float @llvm.exp2.f32(float %16)
  %18 = fpext float %17 to double
  %19 = fmul double %18, %18
  %20 = fmul double %19, %18
  %21 = fneg double %13
  %22 = call double @llvm.fma.f64(double %21, double %20, double 1.000000e+00)
  %23 = call double @llvm.fma.f64(double %22, double 0x3FCC71C71C71C8B2, double 0x3FD5555555555685)
  %24 = fmul double %22, %23
  %25 = call double @llvm.fma.f64(double %18, double %24, double %18)
  %26 = sub nsw i32 0, %11
  %27 = call spir_func double @_Z5ldexpdi(double noundef %25, i32 noundef %26) #38
  %28 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %30, label %36

30:                                               ; preds = %1
  %31 = call spir_func i32 @_Z5isinfd(double noundef %13) #38
  %32 = icmp eq i32 %31, 0
  %33 = select i1 %32, double %27, double 0.000000e+00
  %34 = fcmp oeq double %0, 0.000000e+00
  %35 = select i1 %34, double 0x7FF0000000000000, double %33
  br label %36

36:                                               ; preds = %30, %1
  %37 = phi double [ %27, %1 ], [ %35, %30 ]
  %38 = call double @llvm.copysign.f64(double %37, double %0)
  ret double %38
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func i32 @_Z5isinfd(double noundef) local_unnamed_addr #22

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_rcbrt_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca float, align 8
  %4 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %5 = icmp eq i8 %4, 0
  %6 = select i1 %5, float %0, float 0.000000e+00
  %7 = tail call float @llvm.fabs.f32(float %6)
  br i1 %5, label %8, label %18

8:                                                ; preds = %1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %0, ptr %3, align 8, !tbaa !16
  %9 = addrspacecast ptr %3 to ptr addrspace(4)
  %10 = load i64, ptr addrspace(4) %9, align 8, !tbaa !12
  %11 = and i64 %10, 2139095040
  %12 = icmp ne i64 %11, 0
  %13 = and i64 %10, 8388607
  %14 = icmp eq i64 %13, 0
  %15 = or i1 %12, %14
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br i1 %15, label %18, label %16

16:                                               ; preds = %8
  %17 = tail call spir_func float @_Z5ldexpfi(float noundef %7, i32 noundef 24) #38
  br label %18

18:                                               ; preds = %16, %8, %1
  %19 = phi float [ %7, %1 ], [ %17, %16 ], [ %7, %8 ]
  %20 = tail call float @llvm.log2.f32(float %19)
  %21 = fmul float %20, 0xBFD5555560000000
  %22 = tail call float @llvm.exp2.f32(float %21)
  %23 = fmul float %22, %22
  %24 = fneg float %22
  %25 = fmul float %19, %24
  %26 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %23, float noundef %25, float noundef 1.000000e+00) #38
  %27 = fmul float %22, 0x3FD5555560000000
  %28 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %26, float noundef %27, float noundef %22) #38
  br i1 %5, label %29, label %39

29:                                               ; preds = %18
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %0, ptr %2, align 8, !tbaa !16
  %30 = addrspacecast ptr %2 to ptr addrspace(4)
  %31 = load i64, ptr addrspace(4) %30, align 8, !tbaa !12
  %32 = and i64 %31, 2139095040
  %33 = icmp ne i64 %32, 0
  %34 = and i64 %31, 8388607
  %35 = icmp eq i64 %34, 0
  %36 = or i1 %33, %35
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br i1 %36, label %39, label %37

37:                                               ; preds = %29
  %38 = tail call spir_func float @_Z5ldexpfi(float noundef %28, i32 noundef 8) #38
  br label %39

39:                                               ; preds = %37, %29, %18
  %40 = phi float [ %28, %18 ], [ %38, %37 ], [ %28, %29 ]
  %41 = tail call spir_func float @_Z12native_recipf(float noundef %6) #38
  %42 = tail call spir_func i32 @_Z5isnanf(float noundef %6) #38
  %43 = icmp ne i32 %42, 0
  %44 = fcmp oeq float %6, 0.000000e+00
  %45 = or i1 %44, %43
  br i1 %45, label %50, label %46

46:                                               ; preds = %39
  %47 = tail call spir_func i32 @_Z5isinff(float noundef %6) #38
  %48 = icmp eq i32 %47, 0
  %49 = select i1 %48, float %40, float %41
  br label %50

50:                                               ; preds = %46, %39
  %51 = phi float [ %41, %39 ], [ %49, %46 ]
  %52 = tail call float @llvm.copysign.f32(float %51, float %6)
  ret float %52
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func i32 @_Z5isnanf(float noundef) local_unnamed_addr #22

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func i32 @_Z5isinff(float noundef) local_unnamed_addr #22

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_rcbrt_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_rcbrt_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_rcbrt_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_rcbrt_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = tail call half @llvm.fabs.f16(half %0)
  %3 = fpext half %2 to float
  %4 = tail call float @llvm.log2.f32(float %3)
  %5 = fmul float %4, 0xBFD5555560000000
  %6 = tail call float @llvm.exp2.f32(float %5)
  %7 = fpext half %0 to float
  %8 = tail call spir_func float @_Z10half_recipf(float noundef %7) #38
  %9 = fptoui half %0 to i16
  %10 = tail call spir_func i32 @__builtin_generic_class_f16.93(i16 noundef zeroext %9) #39
  %11 = icmp eq i32 %10, 0
  %12 = select i1 %11, float %6, float %8
  %13 = fptrunc float %12 to half
  %14 = tail call half @llvm.copysign.f16(half %13, half %0)
  ret half %14
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16.93(i16 noundef zeroext %0) unnamed_addr #25 {
  switch i16 %0, label %2 [
    i16 31744, label %9
    i16 -1024, label %9
  ]

2:                                                ; preds = %1
  %3 = and i16 %0, 32256
  %4 = icmp ne i16 %3, 0
  %5 = and i16 %0, 511
  %6 = icmp eq i16 %5, 0
  %7 = or i1 %4, %6
  %8 = sext i1 %7 to i32
  br label %9

9:                                                ; preds = %2, %1, %1
  %10 = phi i32 [ -1, %1 ], [ -1, %1 ], [ %8, %2 ]
  ret i32 %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_remainder_f64(double noundef %0, double noundef %1) local_unnamed_addr #21 {
  %3 = alloca double, align 8
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = tail call double @llvm.fabs.f64(double %0)
  %7 = tail call double @llvm.fabs.f64(double %1)
  %8 = fcmp ogt double %6, %7
  br i1 %8, label %9, label %66

9:                                                ; preds = %2
  %10 = fptrunc double %6 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %11 = addrspacecast ptr %5 to ptr addrspace(4)
  %12 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %10, ptr addrspace(4) noundef %11) #40
  %13 = load i32, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %14 = call spir_func double @_Z5ldexpdi(double noundef %6, i32 noundef 26) #38
  %15 = fptrunc double %7 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %16 = addrspacecast ptr %4 to ptr addrspace(4)
  %17 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %15, ptr addrspace(4) noundef %16) #40
  %18 = load i32, ptr %4, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  %19 = add nsw i32 %18, -1
  %20 = call spir_func double @_Z5ldexpdi(double noundef %7, i32 noundef 1) #38
  %21 = sub i32 %13, %18
  %22 = fdiv double 1.000000e+00, %20
  %23 = icmp sgt i32 %21, 26
  br i1 %23, label %24, label %37

24:                                               ; preds = %9, %24
  %25 = phi double [ %34, %24 ], [ %14, %9 ]
  %26 = phi i32 [ %35, %24 ], [ %21, %9 ]
  %27 = fmul double %22, %25
  %28 = call double @llvm.rint.f64(double %27)
  %29 = fneg double %28
  %30 = call double @llvm.fma.f64(double %29, double %20, double %25)
  %31 = fcmp olt double %30, 0.000000e+00
  %32 = select i1 %31, double %20, double -0.000000e+00
  %33 = fadd double %30, %32
  %34 = call spir_func double @_Z5ldexpdi(double noundef %33, i32 noundef 26) #38
  %35 = add nsw i32 %26, -26
  %36 = icmp ugt i32 %26, 52
  br i1 %36, label %24, label %37

37:                                               ; preds = %24, %9
  %38 = phi i32 [ %21, %9 ], [ %35, %24 ]
  %39 = phi double [ %14, %9 ], [ %34, %24 ]
  %40 = add nsw i32 %38, -25
  %41 = call spir_func double @_Z5ldexpdi(double noundef %39, i32 noundef %40) #38
  %42 = fmul double %22, %41
  %43 = call double @llvm.rint.f64(double %42)
  %44 = fneg double %43
  %45 = call double @llvm.fma.f64(double %44, double %20, double %41)
  %46 = fcmp olt double %45, 0.000000e+00
  %47 = select i1 %46, double %20, double -0.000000e+00
  %48 = fadd double %45, %47
  %49 = fptosi double %43 to i32
  %50 = fmul double %48, 2.000000e+00
  %51 = fcmp ogt double %50, %20
  %52 = and i32 %49, 1
  %53 = icmp ne i32 %52, 0
  %54 = xor i1 %46, %53
  %55 = fcmp oeq double %50, %20
  %56 = and i1 %54, %55
  %57 = or i1 %51, %56
  %58 = select i1 %57, double %20, double 0.000000e+00
  %59 = fsub double %48, %58
  %60 = call spir_func double @_Z5ldexpdi(double noundef %59, i32 noundef %19) #38
  %61 = bitcast double %0 to i64
  %62 = and i64 %61, -9223372036854775808
  %63 = bitcast double %60 to i64
  %64 = xor i64 %62, %63
  %65 = bitcast i64 %64 to double
  br label %87

66:                                               ; preds = %2
  %67 = fcmp olt double %7, 0x7FE0000000000000
  %68 = fmul double %6, 2.000000e+00
  %69 = fcmp ogt double %68, %7
  %70 = and i1 %67, %69
  %71 = fmul double %7, 5.000000e-01
  %72 = fcmp ogt double %6, %71
  %73 = or i1 %70, %72
  %74 = bitcast double %0 to <2 x i32>
  %75 = bitcast double %1 to <2 x i32>
  %76 = xor <2 x i32> %75, %74
  %77 = extractelement <2 x i32> %76, i64 1
  %78 = ashr i32 %77, 30
  %79 = or i32 %78, 1
  %80 = sitofp i32 %79 to double
  %81 = fneg double %80
  %82 = tail call double @llvm.fma.f64(double %1, double %81, double %0)
  %83 = select i1 %73, double %82, double %0
  %84 = fcmp oeq double %6, %7
  %85 = tail call double @llvm.copysign.f64(double 0.000000e+00, double %0)
  %86 = select i1 %84, double %85, double %83
  br label %87

87:                                               ; preds = %66, %37
  %88 = phi double [ %65, %37 ], [ %86, %66 ]
  %89 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %90 = icmp eq i8 %89, 0
  br i1 %90, label %91, label %109

91:                                               ; preds = %87
  %92 = fcmp uno double %1, 0.000000e+00
  br i1 %92, label %109, label %93

93:                                               ; preds = %91
  %94 = fcmp oeq double %1, 0.000000e+00
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %0, ptr %3, align 8, !tbaa !19
  %95 = addrspacecast ptr %3 to ptr addrspace(4)
  %96 = load i128, ptr addrspace(4) %95, align 8, !tbaa !29
  %97 = and i128 %96, 9223372036854775807
  %98 = icmp eq i128 %97, 0
  br i1 %98, label %105, label %99

99:                                               ; preds = %93
  %100 = and i128 %96, 9218868437227405312
  %101 = icmp ne i128 %100, 0
  %102 = and i128 %96, 4503599627370495
  %103 = icmp eq i128 %102, 0
  %104 = or i1 %101, %103
  br label %105

105:                                              ; preds = %93, %99
  %106 = phi i1 [ false, %93 ], [ %104, %99 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  %107 = or i1 %94, %106
  %108 = select i1 %107, double 0x7FF8000000000000, double %88
  br label %109

109:                                              ; preds = %91, %105, %87
  %110 = phi double [ %88, %87 ], [ 0x7FF8000000000000, %91 ], [ %108, %105 ]
  ret double %110
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_remainder_f32(float noundef %0, float noundef %1) local_unnamed_addr #21 {
  %3 = alloca float, align 8
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %7 = icmp eq i8 %6, 0
  %8 = select i1 %7, float %1, float 0.000000e+00
  %9 = select i1 %7, float %0, float 0.000000e+00
  %10 = tail call float @llvm.fabs.f32(float %9)
  %11 = tail call float @llvm.fabs.f32(float %8)
  %12 = fcmp ogt float %10, %11
  br i1 %12, label %13, label %66

13:                                               ; preds = %2
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %14 = addrspacecast ptr %5 to ptr addrspace(4)
  %15 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %10, ptr addrspace(4) noundef %14) #40
  %16 = load i32, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %17 = call spir_func float @_Z5ldexpfi(float noundef %10, i32 noundef 12) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %18 = addrspacecast ptr %4 to ptr addrspace(4)
  %19 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %11, ptr addrspace(4) noundef %18) #40
  %20 = load i32, ptr %4, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  %21 = add nsw i32 %20, -1
  %22 = call spir_func float @_Z5ldexpfi(float noundef %11, i32 noundef 1) #38
  %23 = sub i32 %16, %20
  %24 = call spir_func float @_Z12native_recipf(float noundef %22) #38
  %25 = icmp sgt i32 %23, 12
  br i1 %25, label %26, label %38

26:                                               ; preds = %13, %26
  %27 = phi float [ %35, %26 ], [ %17, %13 ]
  %28 = phi i32 [ %36, %26 ], [ %23, %13 ]
  %29 = fmul float %24, %27
  %30 = call float @llvm.rint.f32(float %29)
  %31 = call spir_func float @fnma.94(float noundef %30, float noundef %22, float noundef %27) #38
  %32 = fcmp olt float %31, 0.000000e+00
  %33 = select i1 %32, float %22, float -0.000000e+00
  %34 = fadd float %31, %33
  %35 = call spir_func float @_Z5ldexpfi(float noundef %34, i32 noundef 12) #38
  %36 = add nsw i32 %28, -12
  %37 = icmp ugt i32 %28, 24
  br i1 %37, label %26, label %38

38:                                               ; preds = %26, %13
  %39 = phi i32 [ %23, %13 ], [ %36, %26 ]
  %40 = phi float [ %17, %13 ], [ %35, %26 ]
  %41 = add nsw i32 %39, -11
  %42 = call spir_func float @_Z5ldexpfi(float noundef %40, i32 noundef %41) #38
  %43 = fmul float %24, %42
  %44 = call float @llvm.rint.f32(float %43)
  %45 = call spir_func float @fnma.94(float noundef %44, float noundef %22, float noundef %42) #38
  %46 = fcmp olt float %45, 0.000000e+00
  %47 = select i1 %46, float %22, float -0.000000e+00
  %48 = fadd float %45, %47
  %49 = fptosi float %44 to i32
  %50 = fmul float %48, 2.000000e+00
  %51 = fcmp ogt float %50, %22
  %52 = and i32 %49, 1
  %53 = icmp ne i32 %52, 0
  %54 = xor i1 %46, %53
  %55 = fcmp oeq float %50, %22
  %56 = and i1 %54, %55
  %57 = or i1 %51, %56
  %58 = select i1 %57, float %22, float 0.000000e+00
  %59 = fsub float %48, %58
  %60 = call spir_func float @_Z5ldexpfi(float noundef %59, i32 noundef %21) #38
  %61 = bitcast float %9 to i32
  %62 = and i32 %61, -2147483648
  %63 = bitcast float %60 to i32
  %64 = xor i32 %62, %63
  %65 = bitcast i32 %64 to float
  br label %86

66:                                               ; preds = %2
  %67 = fcmp olt float %11, 0x47E0000000000000
  %68 = fmul float %10, 2.000000e+00
  %69 = fcmp ogt float %68, %11
  %70 = and i1 %67, %69
  %71 = fmul float %11, 5.000000e-01
  %72 = fcmp ogt float %10, %71
  %73 = or i1 %72, %70
  %74 = bitcast float %9 to i32
  %75 = bitcast float %8 to i32
  %76 = xor i32 %74, %75
  %77 = ashr i32 %76, 30
  %78 = or i32 %77, 1
  %79 = sitofp i32 %78 to float
  %80 = fneg float %79
  %81 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %8, float noundef %80, float noundef %9) #38
  %82 = select i1 %73, float %81, float %9
  %83 = fcmp oeq float %10, %11
  %84 = tail call float @llvm.copysign.f32(float 0.000000e+00, float %9)
  %85 = select i1 %83, float %84, float %82
  br label %86

86:                                               ; preds = %66, %38
  %87 = phi float [ %65, %38 ], [ %85, %66 ]
  %88 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %89 = icmp eq i8 %88, 0
  br i1 %89, label %90, label %108

90:                                               ; preds = %86
  %91 = fcmp uno float %8, 0.000000e+00
  br i1 %91, label %108, label %92

92:                                               ; preds = %90
  %93 = fcmp oeq float %8, 0.000000e+00
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %9, ptr %3, align 8, !tbaa !16
  %94 = addrspacecast ptr %3 to ptr addrspace(4)
  %95 = load i64, ptr addrspace(4) %94, align 8, !tbaa !12
  %96 = and i64 %95, 2147483647
  %97 = icmp eq i64 %96, 0
  br i1 %97, label %104, label %98

98:                                               ; preds = %92
  %99 = and i64 %95, 2139095040
  %100 = icmp ne i64 %99, 0
  %101 = and i64 %95, 8388607
  %102 = icmp eq i64 %101, 0
  %103 = or i1 %100, %102
  br label %104

104:                                              ; preds = %92, %98
  %105 = phi i1 [ false, %92 ], [ %103, %98 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %106 = or i1 %93, %105
  %107 = select i1 %106, float 0x7FF8000000000000, float %87
  br label %108

108:                                              ; preds = %90, %104, %86
  %109 = phi float [ %87, %86 ], [ 0x7FF8000000000000, %90 ], [ %107, %104 ]
  ret float %109
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define internal spir_func float @fnma.94(float noundef %0, float noundef %1, float noundef %2) unnamed_addr #21 {
  %4 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %5 = freeze i32 %4
  %6 = icmp sgt i32 %5, 8999
  br i1 %6, label %8, label %7

7:                                                ; preds = %3
  switch i32 %5, label %11 [
    i32 8001, label %8
    i32 7001, label %8
  ]

8:                                                ; preds = %7, %7, %3
  %9 = fneg float %0
  %10 = tail call float @llvm.fma.f32(float %9, float %1, float %2)
  br label %31

11:                                               ; preds = %7
  %12 = bitcast float %0 to i32
  %13 = and i32 %12, -4096
  %14 = bitcast i32 %13 to float
  %15 = fsub float %0, %14
  %16 = bitcast float %1 to i32
  %17 = and i32 %16, -4096
  %18 = bitcast i32 %17 to float
  %19 = fsub float %1, %18
  %20 = fmul float %0, %1
  %21 = fneg float %20
  %22 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %18, float noundef %21) #38
  %23 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %19, float noundef %22) #38
  %24 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %15, float noundef %18, float noundef %23) #38
  %25 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %15, float noundef %19, float noundef %24) #38
  %26 = fsub float %2, %20
  %27 = fsub float %2, %26
  %28 = fsub float %27, %20
  %29 = fsub float %28, %25
  %30 = fadd float %26, %29
  br label %31

31:                                               ; preds = %11, %8
  %32 = phi float [ %10, %8 ], [ %30, %11 ]
  ret float %32
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_remainder_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #21 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = tail call spir_func half @__ocml_remainder_f16(half noundef %3, half noundef %4) #38
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = extractelement <2 x half> %1, i64 1
  %9 = tail call spir_func half @__ocml_remainder_f16(half noundef %7, half noundef %8) #38
  %10 = insertelement <2 x half> %6, half %9, i64 1
  ret <2 x half> %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_remainder_f16(half noundef %0, half noundef %1) local_unnamed_addr #24 {
  %3 = tail call half @llvm.fabs.f16(half %0)
  %4 = fpext half %3 to float
  %5 = tail call half @llvm.fabs.f16(half %1)
  %6 = fpext half %5 to float
  %7 = fcmp ogt half %3, %5
  br i1 %7, label %8, label %60

8:                                                ; preds = %2
  %9 = tail call spir_func i32 @frexp_exp.95(float noundef %4) #40
  %10 = tail call spir_func float @_Z5ldexpfi(float noundef %4, i32 noundef 11) #38
  %11 = tail call spir_func i32 @frexp_exp.95(float noundef %6) #40
  %12 = add nsw i32 %11, -1
  %13 = tail call spir_func float @_Z5ldexpfi(float noundef %6, i32 noundef 1) #38
  %14 = sub i32 %9, %11
  %15 = tail call spir_func float @_Z12native_recipf(float noundef %13) #38
  %16 = icmp sgt i32 %14, 11
  br i1 %16, label %17, label %30

17:                                               ; preds = %8, %17
  %18 = phi float [ %27, %17 ], [ %10, %8 ]
  %19 = phi i32 [ %28, %17 ], [ %14, %8 ]
  %20 = fmul float %15, %18
  %21 = tail call float @llvm.rint.f32(float %20)
  %22 = fneg float %21
  %23 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %22, float noundef %13, float noundef %18) #38
  %24 = fcmp olt float %23, 0.000000e+00
  %25 = select i1 %24, float %13, float -0.000000e+00
  %26 = fadd float %23, %25
  %27 = tail call spir_func float @_Z5ldexpfi(float noundef %26, i32 noundef 11) #38
  %28 = add nsw i32 %19, -11
  %29 = icmp ugt i32 %19, 22
  br i1 %29, label %17, label %30

30:                                               ; preds = %17, %8
  %31 = phi i32 [ %14, %8 ], [ %28, %17 ]
  %32 = phi float [ %10, %8 ], [ %27, %17 ]
  %33 = add nsw i32 %31, -10
  %34 = tail call spir_func float @_Z5ldexpfi(float noundef %32, i32 noundef %33) #38
  %35 = fmul float %15, %34
  %36 = tail call float @llvm.rint.f32(float %35)
  %37 = fneg float %36
  %38 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %37, float noundef %13, float noundef %34) #38
  %39 = fcmp olt float %38, 0.000000e+00
  %40 = select i1 %39, float %13, float -0.000000e+00
  %41 = fadd float %38, %40
  %42 = fptosi float %36 to i32
  %43 = fmul float %41, 2.000000e+00
  %44 = fcmp ogt float %43, %13
  %45 = and i32 %42, 1
  %46 = icmp ne i32 %45, 0
  %47 = xor i1 %39, %46
  %48 = fcmp oeq float %43, %13
  %49 = and i1 %47, %48
  %50 = or i1 %44, %49
  %51 = select i1 %50, float %13, float 0.000000e+00
  %52 = fsub float %41, %51
  %53 = tail call spir_func float @_Z5ldexpfi(float noundef %52, i32 noundef %12) #38
  %54 = fptrunc float %53 to half
  %55 = bitcast half %54 to i16
  %56 = bitcast half %0 to i16
  %57 = and i16 %56, -32768
  %58 = xor i16 %57, %55
  %59 = bitcast i16 %58 to half
  br label %74

60:                                               ; preds = %2
  %61 = fmul float %6, 5.000000e-01
  %62 = fcmp olt float %61, %4
  %63 = bitcast half %0 to i16
  %64 = bitcast half %1 to i16
  %65 = xor i16 %64, %63
  %66 = icmp sgt i16 %65, -1
  %67 = select i1 %66, half 0xH3C00, half 0xHBC00
  %68 = fneg half %67
  %69 = tail call half @llvm.fma.f16(half %1, half %68, half %0)
  %70 = select i1 %62, half %69, half %0
  %71 = fcmp oeq half %3, %5
  %72 = tail call half @llvm.copysign.f16(half 0xH0000, half %0)
  %73 = select i1 %71, half %72, half %70
  br label %74

74:                                               ; preds = %60, %30
  %75 = phi half [ %59, %30 ], [ %73, %60 ]
  %76 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %77 = icmp eq i8 %76, 0
  br i1 %77, label %78, label %87

78:                                               ; preds = %74
  %79 = fcmp uno half %1, 0xH0000
  br i1 %79, label %87, label %80

80:                                               ; preds = %78
  %81 = fcmp oeq half %1, 0xH0000
  %82 = fptoui half %0 to i16
  %83 = tail call spir_func i32 @__builtin_generic_class_f16.96(i16 noundef zeroext %82) #39
  %84 = icmp eq i32 %83, 0
  %85 = or i1 %81, %84
  %86 = select i1 %85, half 0xH7E00, half %75
  br label %87

87:                                               ; preds = %78, %80, %74
  %88 = phi half [ %75, %74 ], [ 0xH7E00, %78 ], [ %86, %80 ]
  ret half %88
}

; Function Attrs: convergent inlinehint norecurse nounwind
define internal spir_func i32 @frexp_exp.95(float noundef %0) unnamed_addr #33 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %3 = addrspacecast ptr %2 to ptr addrspace(4)
  %4 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %0, ptr addrspace(4) noundef %3) #40
  %5 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret i32 %5
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func i32 @__builtin_generic_class_f16.96(i16 noundef zeroext %0) unnamed_addr #25 {
  %2 = and i16 %0, 32767
  %3 = icmp eq i16 %2, 0
  br i1 %3, label %12, label %4

4:                                                ; preds = %1
  %5 = zext i16 %0 to i32
  %6 = and i32 %5, 31744
  %7 = icmp eq i32 %6, 0
  %8 = and i32 %5, 1023
  %9 = icmp ne i32 %8, 0
  %10 = and i1 %7, %9
  %11 = sext i1 %10 to i32
  br label %12

12:                                               ; preds = %4, %1
  %13 = phi i32 [ -1, %1 ], [ %11, %4 ]
  ret i32 %13
}

; Function Attrs: convergent norecurse nounwind
define protected spir_func double @__ocml_remquo_f64(double noundef %0, double noundef %1, ptr nocapture noundef writeonly %2) local_unnamed_addr #35 {
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = tail call double @llvm.fabs.f64(double %0)
  %8 = tail call double @llvm.fabs.f64(double %1)
  %9 = fcmp ogt double %7, %8
  br i1 %9, label %10, label %89

10:                                               ; preds = %3
  %11 = fptrunc double %7 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6) #39
  %12 = addrspacecast ptr %6 to ptr addrspace(4)
  %13 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %11, ptr addrspace(4) noundef %12) #40
  %14 = load i32, ptr %6, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6) #39
  %15 = call spir_func double @_Z5ldexpdi(double noundef %7, i32 noundef 26) #38
  %16 = fptrunc double %8 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %17 = addrspacecast ptr %5 to ptr addrspace(4)
  %18 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %16, ptr addrspace(4) noundef %17) #40
  %19 = load i32, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %20 = add nsw i32 %19, -1
  %21 = call spir_func double @_Z5ldexpdi(double noundef %8, i32 noundef 1) #38
  %22 = sub i32 %14, %19
  %23 = fdiv double 1.000000e+00, %21
  %24 = icmp sgt i32 %22, 26
  br i1 %24, label %25, label %44

25:                                               ; preds = %10, %25
  %26 = phi double [ %41, %25 ], [ %15, %10 ]
  %27 = phi i32 [ %42, %25 ], [ %22, %10 ]
  %28 = phi i32 [ %40, %25 ], [ 0, %10 ]
  %29 = fmul double %23, %26
  %30 = call double @llvm.rint.f64(double %29)
  %31 = fneg double %30
  %32 = call double @llvm.fma.f64(double %31, double %21, double %26)
  %33 = fcmp olt double %32, 0.000000e+00
  %34 = sext i1 %33 to i32
  %35 = select i1 %33, double %21, double -0.000000e+00
  %36 = fadd double %32, %35
  %37 = fptosi double %30 to i32
  %38 = add i32 %34, %37
  %39 = shl i32 %28, 26
  %40 = or i32 %38, %39
  %41 = call spir_func double @_Z5ldexpdi(double noundef %36, i32 noundef 26) #38
  %42 = add nsw i32 %27, -26
  %43 = icmp ugt i32 %27, 52
  br i1 %43, label %25, label %44

44:                                               ; preds = %25, %10
  %45 = phi i32 [ 0, %10 ], [ %40, %25 ]
  %46 = phi i32 [ %22, %10 ], [ %42, %25 ]
  %47 = phi double [ %15, %10 ], [ %41, %25 ]
  %48 = add nsw i32 %46, -25
  %49 = call spir_func double @_Z5ldexpdi(double noundef %47, i32 noundef %48) #38
  %50 = fmul double %23, %49
  %51 = call double @llvm.rint.f64(double %50)
  %52 = fneg double %51
  %53 = call double @llvm.fma.f64(double %52, double %21, double %49)
  %54 = fcmp olt double %53, 0.000000e+00
  %55 = sext i1 %54 to i32
  %56 = select i1 %54, double %21, double -0.000000e+00
  %57 = fadd double %53, %56
  %58 = fptosi double %51 to i32
  %59 = add i32 %55, %58
  %60 = add nsw i32 %46, 1
  %61 = and i32 %60, 31
  %62 = shl i32 %45, %61
  %63 = or i32 %59, %62
  %64 = fmul double %57, 2.000000e+00
  %65 = fcmp ogt double %64, %21
  %66 = zext i1 %65 to i32
  %67 = fcmp oeq double %64, %21
  %68 = and i32 %63, 1
  %69 = select i1 %67, i32 %68, i32 0
  %70 = or i32 %69, %66
  %71 = icmp eq i32 %70, 0
  %72 = select i1 %71, double 0.000000e+00, double %21
  %73 = fsub double %57, %72
  %74 = add nsw i32 %70, %63
  %75 = bitcast double %0 to <2 x i32>
  %76 = bitcast double %1 to <2 x i32>
  %77 = xor <2 x i32> %76, %75
  %78 = extractelement <2 x i32> %77, i64 1
  %79 = ashr i32 %78, 31
  %80 = and i32 %74, 127
  %81 = xor i32 %80, %79
  %82 = sub nsw i32 %81, %79
  %83 = call spir_func double @_Z5ldexpdi(double noundef %73, i32 noundef %20) #38
  %84 = bitcast double %0 to i64
  %85 = and i64 %84, -9223372036854775808
  %86 = bitcast double %83 to i64
  %87 = xor i64 %85, %86
  %88 = bitcast i64 %87 to double
  br label %112

89:                                               ; preds = %3
  %90 = fcmp olt double %8, 0x7FE0000000000000
  %91 = fmul double %7, 2.000000e+00
  %92 = fcmp ogt double %91, %8
  %93 = and i1 %90, %92
  %94 = fmul double %8, 5.000000e-01
  %95 = fcmp ogt double %7, %94
  %96 = or i1 %93, %95
  %97 = bitcast double %0 to <2 x i32>
  %98 = bitcast double %1 to <2 x i32>
  %99 = xor <2 x i32> %98, %97
  %100 = extractelement <2 x i32> %99, i64 1
  %101 = ashr i32 %100, 30
  %102 = or i32 %101, 1
  %103 = sitofp i32 %102 to double
  %104 = fneg double %103
  %105 = tail call double @llvm.fma.f64(double %1, double %104, double %0)
  %106 = select i1 %96, double %105, double %0
  %107 = fcmp oeq double %7, %8
  %108 = tail call double @llvm.copysign.f64(double 0.000000e+00, double %0)
  %109 = select i1 %107, double %108, double %106
  %110 = or i1 %107, %96
  %111 = select i1 %110, i32 %102, i32 0
  br label %112

112:                                              ; preds = %89, %44
  %113 = phi i32 [ %82, %44 ], [ %111, %89 ]
  %114 = phi double [ %88, %44 ], [ %109, %89 ]
  %115 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %116 = icmp eq i8 %115, 0
  br i1 %116, label %117, label %137

117:                                              ; preds = %112
  %118 = fcmp oeq double %1, 0.000000e+00
  %119 = select i1 %118, double 0x7FF8000000000000, double %114
  %120 = select i1 %118, i32 0, i32 %113
  %121 = fcmp uno double %1, 0.000000e+00
  br i1 %121, label %137, label %122

122:                                              ; preds = %117
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  store double %0, ptr %4, align 8, !tbaa !19
  %123 = addrspacecast ptr %4 to ptr addrspace(4)
  %124 = load i128, ptr addrspace(4) %123, align 8, !tbaa !29
  %125 = and i128 %124, 9223372036854775807
  %126 = icmp eq i128 %125, 0
  br i1 %126, label %127, label %128

127:                                              ; preds = %122
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  br label %137

128:                                              ; preds = %122
  %129 = and i128 %124, 9218868437227405312
  %130 = icmp eq i128 %129, 0
  %131 = and i128 %124, 4503599627370495
  %132 = icmp ne i128 %131, 0
  %133 = and i1 %130, %132
  %134 = freeze i1 %133
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %135 = select i1 %134, i32 %120, i32 0
  %136 = select i1 %134, double %119, double 0x7FF8000000000000
  br label %137

137:                                              ; preds = %128, %127, %117, %112
  %138 = phi i32 [ %113, %112 ], [ 0, %117 ], [ %120, %127 ], [ %135, %128 ]
  %139 = phi double [ %114, %112 ], [ 0x7FF8000000000000, %117 ], [ %119, %127 ], [ %136, %128 ]
  store i32 %138, ptr %2, align 4, !tbaa !4
  ret double %139
}

; Function Attrs: convergent norecurse nounwind
define protected spir_func float @__ocml_remquo_f32(float noundef %0, float noundef %1, ptr nocapture noundef writeonly %2) local_unnamed_addr #35 {
  %4 = alloca float, align 8
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %8 = icmp eq i8 %7, 0
  %9 = select i1 %8, float %1, float 0.000000e+00
  %10 = select i1 %8, float %0, float 0.000000e+00
  %11 = tail call float @llvm.fabs.f32(float %10)
  %12 = tail call float @llvm.fabs.f32(float %9)
  %13 = fcmp ogt float %11, %12
  br i1 %13, label %14, label %87

14:                                               ; preds = %3
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6) #39
  %15 = addrspacecast ptr %6 to ptr addrspace(4)
  %16 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %11, ptr addrspace(4) noundef %15) #40
  %17 = load i32, ptr %6, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6) #39
  %18 = call spir_func float @_Z5ldexpfi(float noundef %11, i32 noundef 12) #38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %19 = addrspacecast ptr %5 to ptr addrspace(4)
  %20 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %12, ptr addrspace(4) noundef %19) #40
  %21 = load i32, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %22 = add nsw i32 %21, -1
  %23 = call spir_func float @_Z5ldexpfi(float noundef %12, i32 noundef 1) #38
  %24 = sub i32 %17, %21
  %25 = call spir_func float @_Z12native_recipf(float noundef %23) #38
  %26 = icmp sgt i32 %24, 12
  br i1 %26, label %27, label %45

27:                                               ; preds = %14, %27
  %28 = phi float [ %42, %27 ], [ %18, %14 ]
  %29 = phi i32 [ %43, %27 ], [ %24, %14 ]
  %30 = phi i32 [ %41, %27 ], [ 0, %14 ]
  %31 = fmul float %25, %28
  %32 = call float @llvm.rint.f32(float %31)
  %33 = call spir_func float @fnma.97(float noundef %32, float noundef %23, float noundef %28) #38
  %34 = fcmp olt float %33, 0.000000e+00
  %35 = sext i1 %34 to i32
  %36 = select i1 %34, float %23, float -0.000000e+00
  %37 = fadd float %33, %36
  %38 = fptosi float %32 to i32
  %39 = add i32 %35, %38
  %40 = shl i32 %30, 12
  %41 = or i32 %39, %40
  %42 = call spir_func float @_Z5ldexpfi(float noundef %37, i32 noundef 12) #38
  %43 = add nsw i32 %29, -12
  %44 = icmp ugt i32 %29, 24
  br i1 %44, label %27, label %45

45:                                               ; preds = %27, %14
  %46 = phi i32 [ 0, %14 ], [ %41, %27 ]
  %47 = phi i32 [ %24, %14 ], [ %43, %27 ]
  %48 = phi float [ %18, %14 ], [ %42, %27 ]
  %49 = add nsw i32 %47, -11
  %50 = call spir_func float @_Z5ldexpfi(float noundef %48, i32 noundef %49) #38
  %51 = fmul float %25, %50
  %52 = call float @llvm.rint.f32(float %51)
  %53 = call spir_func float @fnma.97(float noundef %52, float noundef %23, float noundef %50) #38
  %54 = fcmp olt float %53, 0.000000e+00
  %55 = sext i1 %54 to i32
  %56 = select i1 %54, float %23, float -0.000000e+00
  %57 = fadd float %53, %56
  %58 = fptosi float %52 to i32
  %59 = add i32 %55, %58
  %60 = add nsw i32 %47, 1
  %61 = and i32 %60, 31
  %62 = shl i32 %46, %61
  %63 = or i32 %59, %62
  %64 = fmul float %57, 2.000000e+00
  %65 = fcmp ogt float %64, %23
  %66 = zext i1 %65 to i32
  %67 = fcmp oeq float %64, %23
  %68 = and i32 %63, 1
  %69 = select i1 %67, i32 %68, i32 0
  %70 = or i32 %69, %66
  %71 = icmp eq i32 %70, 0
  %72 = select i1 %71, float 0.000000e+00, float %23
  %73 = fsub float %57, %72
  %74 = add nsw i32 %70, %63
  %75 = bitcast float %10 to i32
  %76 = bitcast float %9 to i32
  %77 = xor i32 %75, %76
  %78 = ashr i32 %77, 31
  %79 = and i32 %74, 127
  %80 = xor i32 %79, %78
  %81 = sub nsw i32 %80, %78
  %82 = call spir_func float @_Z5ldexpfi(float noundef %73, i32 noundef %22) #38
  %83 = and i32 %75, -2147483648
  %84 = bitcast float %82 to i32
  %85 = xor i32 %83, %84
  %86 = bitcast i32 %85 to float
  br label %109

87:                                               ; preds = %3
  %88 = fcmp olt float %12, 0x47E0000000000000
  %89 = fmul float %11, 2.000000e+00
  %90 = fcmp ogt float %89, %12
  %91 = and i1 %88, %90
  %92 = fmul float %12, 5.000000e-01
  %93 = fcmp ogt float %11, %92
  %94 = or i1 %93, %91
  %95 = bitcast float %10 to i32
  %96 = bitcast float %9 to i32
  %97 = xor i32 %95, %96
  %98 = ashr i32 %97, 30
  %99 = or i32 %98, 1
  %100 = sitofp i32 %99 to float
  %101 = fneg float %100
  %102 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %9, float noundef %101, float noundef %10) #38
  %103 = select i1 %94, float %102, float %10
  %104 = fcmp oeq float %11, %12
  %105 = tail call float @llvm.copysign.f32(float 0.000000e+00, float %10)
  %106 = select i1 %104, float %105, float %103
  %107 = or i1 %104, %94
  %108 = select i1 %107, i32 %99, i32 0
  br label %109

109:                                              ; preds = %87, %45
  %110 = phi i32 [ %81, %45 ], [ %108, %87 ]
  %111 = phi float [ %86, %45 ], [ %106, %87 ]
  %112 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %113 = icmp eq i8 %112, 0
  br i1 %113, label %114, label %134

114:                                              ; preds = %109
  %115 = fcmp oeq float %9, 0.000000e+00
  %116 = select i1 %115, float 0x7FF8000000000000, float %111
  %117 = select i1 %115, i32 0, i32 %110
  %118 = fcmp uno float %9, 0.000000e+00
  br i1 %118, label %134, label %119

119:                                              ; preds = %114
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  store float %10, ptr %4, align 8, !tbaa !16
  %120 = addrspacecast ptr %4 to ptr addrspace(4)
  %121 = load i64, ptr addrspace(4) %120, align 8, !tbaa !12
  %122 = and i64 %121, 2147483647
  %123 = icmp eq i64 %122, 0
  br i1 %123, label %124, label %125

124:                                              ; preds = %119
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  br label %134

125:                                              ; preds = %119
  %126 = and i64 %121, 2139095040
  %127 = icmp eq i64 %126, 0
  %128 = and i64 %121, 8388607
  %129 = icmp ne i64 %128, 0
  %130 = and i1 %127, %129
  %131 = freeze i1 %130
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  %132 = select i1 %131, i32 %117, i32 0
  %133 = select i1 %131, float %116, float 0x7FF8000000000000
  br label %134

134:                                              ; preds = %125, %124, %114, %109
  %135 = phi i32 [ %110, %109 ], [ 0, %114 ], [ %117, %124 ], [ %132, %125 ]
  %136 = phi float [ %111, %109 ], [ 0x7FF8000000000000, %114 ], [ %116, %124 ], [ %133, %125 ]
  store i32 %135, ptr %2, align 4, !tbaa !4
  ret float %136
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define internal spir_func float @fnma.97(float noundef %0, float noundef %1, float noundef %2) unnamed_addr #21 {
  %4 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %5 = freeze i32 %4
  %6 = icmp sgt i32 %5, 8999
  br i1 %6, label %8, label %7

7:                                                ; preds = %3
  switch i32 %5, label %11 [
    i32 8001, label %8
    i32 7001, label %8
  ]

8:                                                ; preds = %7, %7, %3
  %9 = fneg float %0
  %10 = tail call float @llvm.fma.f32(float %9, float %1, float %2)
  br label %31

11:                                               ; preds = %7
  %12 = bitcast float %0 to i32
  %13 = and i32 %12, -4096
  %14 = bitcast i32 %13 to float
  %15 = fsub float %0, %14
  %16 = bitcast float %1 to i32
  %17 = and i32 %16, -4096
  %18 = bitcast i32 %17 to float
  %19 = fsub float %1, %18
  %20 = fmul float %0, %1
  %21 = fneg float %20
  %22 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %18, float noundef %21) #38
  %23 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %19, float noundef %22) #38
  %24 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %15, float noundef %18, float noundef %23) #38
  %25 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %15, float noundef %19, float noundef %24) #38
  %26 = fsub float %2, %20
  %27 = fsub float %2, %26
  %28 = fsub float %27, %20
  %29 = fsub float %28, %25
  %30 = fadd float %26, %29
  br label %31

31:                                               ; preds = %11, %8
  %32 = phi float [ %10, %8 ], [ %30, %11 ]
  ret float %32
}

; Function Attrs: convergent norecurse nounwind
define protected spir_func <2 x half> @__ocml_remquo_2f16(<2 x half> noundef %0, <2 x half> noundef %1, ptr nocapture noundef writeonly %2) local_unnamed_addr #35 {
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %6 = extractelement <2 x half> %0, i64 0
  %7 = extractelement <2 x half> %1, i64 0
  %8 = call spir_func half @__ocml_remquo_f16(half noundef %6, half noundef %7, ptr noundef nonnull %4) #40
  %9 = insertelement <2 x half> poison, half %8, i64 0
  %10 = extractelement <2 x half> %0, i64 1
  %11 = extractelement <2 x half> %1, i64 1
  %12 = call spir_func half @__ocml_remquo_f16(half noundef %10, half noundef %11, ptr noundef nonnull %5) #40
  %13 = insertelement <2 x half> %9, half %12, i64 1
  %14 = load i32, ptr %4, align 4, !tbaa !4
  %15 = insertelement <2 x i32> poison, i32 %14, i64 0
  %16 = load i32, ptr %5, align 4, !tbaa !4
  %17 = insertelement <2 x i32> %15, i32 %16, i64 1
  store <2 x i32> %17, ptr %2, align 8, !tbaa !14
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  ret <2 x half> %13
}

; Function Attrs: convergent norecurse nounwind
define protected spir_func half @__ocml_remquo_f16(half noundef %0, half noundef %1, ptr nocapture noundef writeonly %2) local_unnamed_addr #36 {
  %4 = tail call half @llvm.fabs.f16(half %0)
  %5 = fpext half %4 to float
  %6 = tail call half @llvm.fabs.f16(half %1)
  %7 = fpext half %6 to float
  %8 = fcmp ogt half %4, %6
  br i1 %8, label %9, label %82

9:                                                ; preds = %3
  %10 = tail call spir_func i32 @frexp_exp.98(float noundef %5) #40
  %11 = tail call spir_func float @_Z5ldexpfi(float noundef %5, i32 noundef 11) #38
  %12 = tail call spir_func i32 @frexp_exp.98(float noundef %7) #40
  %13 = add nsw i32 %12, -1
  %14 = tail call spir_func float @_Z5ldexpfi(float noundef %7, i32 noundef 1) #38
  %15 = sub i32 %10, %12
  %16 = tail call spir_func float @_Z12native_recipf(float noundef %14) #38
  %17 = icmp sgt i32 %15, 11
  br i1 %17, label %18, label %37

18:                                               ; preds = %9, %18
  %19 = phi float [ %34, %18 ], [ %11, %9 ]
  %20 = phi i32 [ %35, %18 ], [ %15, %9 ]
  %21 = phi i32 [ %33, %18 ], [ 0, %9 ]
  %22 = fmul float %16, %19
  %23 = tail call float @llvm.rint.f32(float %22)
  %24 = fneg float %23
  %25 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %24, float noundef %14, float noundef %19) #38
  %26 = fcmp olt float %25, 0.000000e+00
  %27 = sext i1 %26 to i32
  %28 = select i1 %26, float %14, float -0.000000e+00
  %29 = fadd float %25, %28
  %30 = fptosi float %23 to i32
  %31 = add i32 %27, %30
  %32 = shl i32 %21, 11
  %33 = or i32 %31, %32
  %34 = tail call spir_func float @_Z5ldexpfi(float noundef %29, i32 noundef 11) #38
  %35 = add nsw i32 %20, -11
  %36 = icmp ugt i32 %20, 22
  br i1 %36, label %18, label %37

37:                                               ; preds = %18, %9
  %38 = phi i32 [ 0, %9 ], [ %33, %18 ]
  %39 = phi i32 [ %15, %9 ], [ %35, %18 ]
  %40 = phi float [ %11, %9 ], [ %34, %18 ]
  %41 = add nsw i32 %39, -10
  %42 = tail call spir_func float @_Z5ldexpfi(float noundef %40, i32 noundef %41) #38
  %43 = fmul float %16, %42
  %44 = tail call float @llvm.rint.f32(float %43)
  %45 = fneg float %44
  %46 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %45, float noundef %14, float noundef %42) #38
  %47 = fcmp olt float %46, 0.000000e+00
  %48 = sext i1 %47 to i32
  %49 = select i1 %47, float %14, float -0.000000e+00
  %50 = fadd float %46, %49
  %51 = fptosi float %44 to i32
  %52 = add i32 %48, %51
  %53 = add nsw i32 %39, 1
  %54 = and i32 %53, 31
  %55 = shl i32 %38, %54
  %56 = or i32 %52, %55
  %57 = fmul float %50, 2.000000e+00
  %58 = fcmp ogt float %57, %14
  %59 = zext i1 %58 to i32
  %60 = fcmp oeq float %57, %14
  %61 = and i32 %56, 1
  %62 = select i1 %60, i32 %61, i32 0
  %63 = or i32 %62, %59
  %64 = icmp eq i32 %63, 0
  %65 = select i1 %64, float 0.000000e+00, float %14
  %66 = fsub float %50, %65
  %67 = add nsw i32 %63, %56
  %68 = bitcast half %0 to i16
  %69 = bitcast half %1 to i16
  %70 = xor i16 %69, %68
  %71 = ashr i16 %70, 15
  %72 = sext i16 %71 to i32
  %73 = and i32 %67, 127
  %74 = xor i32 %73, %72
  %75 = sub nsw i32 %74, %72
  %76 = tail call spir_func float @_Z5ldexpfi(float noundef %66, i32 noundef %13) #38
  %77 = fptrunc float %76 to half
  %78 = bitcast half %77 to i16
  %79 = and i16 %68, -32768
  %80 = xor i16 %79, %78
  %81 = bitcast i16 %80 to half
  br label %99

82:                                               ; preds = %3
  %83 = fmul float %7, 5.000000e-01
  %84 = fcmp olt float %83, %5
  %85 = bitcast half %0 to i16
  %86 = bitcast half %1 to i16
  %87 = xor i16 %86, %85
  %88 = icmp sgt i16 %87, -1
  %89 = select i1 %88, i32 1, i32 -1
  %90 = sitofp i32 %89 to half
  %91 = fneg half %90
  %92 = tail call half @llvm.fma.f16(half %1, half %91, half %0)
  %93 = select i1 %84, half %92, half %0
  %94 = fcmp oeq half %4, %6
  %95 = tail call half @llvm.copysign.f16(half 0xH0000, half %0)
  %96 = select i1 %94, half %95, half %93
  %97 = or i1 %94, %84
  %98 = select i1 %97, i32 %89, i32 0
  br label %99

99:                                               ; preds = %82, %37
  %100 = phi i32 [ %75, %37 ], [ %98, %82 ]
  %101 = phi half [ %81, %37 ], [ %96, %82 ]
  %102 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %103 = icmp eq i8 %102, 0
  br i1 %103, label %104, label %115

104:                                              ; preds = %99
  %105 = fcmp uno half %1, 0xH0000
  br i1 %105, label %115, label %106

106:                                              ; preds = %104
  %107 = fcmp oeq half %1, 0xH0000
  %108 = fptoui half %0 to i16
  %109 = tail call spir_func i32 @__builtin_generic_class_f16.99(i16 noundef zeroext %108) #39
  %110 = freeze i32 %109
  %111 = icmp eq i32 %110, 0
  %112 = or i1 %111, %107
  %113 = select i1 %112, i32 0, i32 %100
  %114 = select i1 %112, half 0xH7E00, half %101
  br label %115

115:                                              ; preds = %106, %104, %99
  %116 = phi i32 [ %100, %99 ], [ 0, %104 ], [ %113, %106 ]
  %117 = phi half [ %101, %99 ], [ 0xH7E00, %104 ], [ %114, %106 ]
  store i32 %116, ptr %2, align 4, !tbaa !4
  ret half %117
}

; Function Attrs: convergent inlinehint norecurse nounwind
define internal spir_func i32 @frexp_exp.98(float noundef %0) unnamed_addr #33 {
  %2 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %3 = addrspacecast ptr %2 to ptr addrspace(4)
  %4 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %0, ptr addrspace(4) noundef %3) #40
  %5 = load i32, ptr %2, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret i32 %5
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func i32 @__builtin_generic_class_f16.99(i16 noundef zeroext %0) unnamed_addr #25 {
  %2 = and i16 %0, 32767
  %3 = icmp eq i16 %2, 0
  br i1 %3, label %12, label %4

4:                                                ; preds = %1
  %5 = zext i16 %0 to i32
  %6 = and i32 %5, 31744
  %7 = icmp eq i32 %6, 0
  %8 = and i32 %5, 1023
  %9 = icmp ne i32 %8, 0
  %10 = and i1 %7, %9
  %11 = sext i1 %10 to i32
  br label %12

12:                                               ; preds = %4, %1
  %13 = phi i32 [ -1, %1 ], [ %11, %4 ]
  ret i32 %13
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_rhypot_f64(double noundef %0, double noundef %1) local_unnamed_addr #21 {
  %3 = alloca i32, align 4
  %4 = tail call double @llvm.fabs.f64(double %0)
  %5 = tail call double @llvm.fabs.f64(double %1)
  %6 = tail call double @llvm.maxnum.f64(double %4, double %5)
  %7 = fptrunc double %6 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %8 = addrspacecast ptr %3 to ptr addrspace(4)
  %9 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %7, ptr addrspace(4) noundef %8) #40
  %10 = load i32, ptr %3, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %11 = sub nsw i32 0, %10
  %12 = call spir_func double @_Z5ldexpdi(double noundef %4, i32 noundef %11) #38
  %13 = call spir_func double @_Z5ldexpdi(double noundef %5, i32 noundef %11) #38
  %14 = fmul double %13, %13
  %15 = call double @llvm.fma.f64(double %12, double %12, double %14)
  %16 = fptrunc double %15 to float
  %17 = call spir_func float @_Z12native_rsqrtf(float noundef %16) #38
  %18 = fpext float %17 to double
  %19 = fneg double %15
  %20 = fmul double %19, %18
  %21 = call double @llvm.fma.f64(double %20, double %18, double 1.000000e+00)
  %22 = fmul double %21, %18
  %23 = call double @llvm.fma.f64(double %21, double 3.750000e-01, double 5.000000e-01)
  %24 = call double @llvm.fma.f64(double %22, double %23, double %18)
  %25 = call spir_func double @_Z5ldexpdi(double noundef %24, i32 noundef %11) #38
  %26 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %28, label %37

28:                                               ; preds = %2
  %29 = fcmp oeq double %6, 0.000000e+00
  %30 = select i1 %29, double 0x7FF0000000000000, double %25
  %31 = fcmp uno double %0, %1
  %32 = select i1 %31, double 0x7FF8000000000000, double %30
  %33 = fcmp oeq double %4, 0x7FF0000000000000
  %34 = fcmp oeq double %5, 0x7FF0000000000000
  %35 = or i1 %33, %34
  %36 = select i1 %35, double 0.000000e+00, double %32
  br label %37

37:                                               ; preds = %28, %2
  %38 = phi double [ %25, %2 ], [ %36, %28 ]
  ret double %38
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_rhypot_f32(float noundef %0, float noundef %1) local_unnamed_addr #21 {
  %3 = alloca i32, align 4
  %4 = tail call float @llvm.fabs.f32(float %0)
  %5 = tail call float @llvm.fabs.f32(float %1)
  %6 = bitcast float %4 to i32
  %7 = bitcast float %5 to i32
  %8 = tail call i32 @llvm.umax.i32(i32 %6, i32 %7)
  %9 = bitcast i32 %8 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %10 = addrspacecast ptr %3 to ptr addrspace(4)
  %11 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %9, ptr addrspace(4) noundef %10) #40
  %12 = load i32, ptr %3, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %13 = sub nsw i32 0, %12
  %14 = call spir_func float @_Z5ldexpfi(float noundef %4, i32 noundef %13) #38
  %15 = call spir_func float @_Z5ldexpfi(float noundef %5, i32 noundef %13) #38
  %16 = fmul float %15, %15
  %17 = call spir_func float @__ocml_fmuladd_f32(float noundef %14, float noundef %14, float noundef %16) #38
  %18 = call spir_func float @_Z12native_rsqrtf(float noundef %17) #38
  %19 = call spir_func float @_Z5ldexpfi(float noundef %18, i32 noundef %13) #38
  %20 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %21 = icmp eq i8 %20, 0
  %22 = fcmp oeq float %4, 0x7FF0000000000000
  %23 = fcmp oeq float %5, 0x7FF0000000000000
  %24 = or i1 %22, %23
  %25 = and i1 %24, %21
  %26 = select i1 %25, float 0.000000e+00, float %19
  ret float %26
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_rhypot_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #21 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = fpext half %3 to float
  %6 = fpext half %4 to float
  %7 = fmul float %6, %6
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef %5, float noundef %7) #38
  %9 = tail call spir_func float @_Z12native_rsqrtf(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %13, label %20

13:                                               ; preds = %2
  %14 = tail call half @llvm.fabs.f16(half %3)
  %15 = fcmp oeq half %14, 0xH7C00
  %16 = tail call half @llvm.fabs.f16(half %4)
  %17 = fcmp oeq half %16, 0xH7C00
  %18 = or i1 %15, %17
  %19 = select i1 %18, half 0xH0000, half %10
  br label %20

20:                                               ; preds = %2, %13
  %21 = phi half [ %10, %2 ], [ %19, %13 ]
  %22 = extractelement <2 x half> %0, i64 1
  %23 = extractelement <2 x half> %1, i64 1
  %24 = fpext half %22 to float
  %25 = fpext half %23 to float
  %26 = fmul float %25, %25
  %27 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %24, float noundef %24, float noundef %26) #38
  %28 = tail call spir_func float @_Z12native_rsqrtf(float noundef %27) #38
  %29 = fptrunc float %28 to half
  br i1 %12, label %30, label %37

30:                                               ; preds = %20
  %31 = tail call half @llvm.fabs.f16(half %22)
  %32 = fcmp oeq half %31, 0xH7C00
  %33 = tail call half @llvm.fabs.f16(half %23)
  %34 = fcmp oeq half %33, 0xH7C00
  %35 = or i1 %32, %34
  %36 = select i1 %35, half 0xH0000, half %29
  br label %37

37:                                               ; preds = %20, %30
  %38 = phi half [ %29, %20 ], [ %36, %30 ]
  %39 = insertelement <2 x half> poison, half %21, i64 0
  %40 = insertelement <2 x half> %39, half %38, i64 1
  ret <2 x half> %40
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_rhypot_f16(half noundef %0, half noundef %1) local_unnamed_addr #21 {
  %3 = fpext half %0 to float
  %4 = fpext half %1 to float
  %5 = fmul float %4, %4
  %6 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %3, float noundef %5) #38
  %7 = tail call spir_func float @_Z12native_rsqrtf(float noundef %6) #38
  %8 = fptrunc float %7 to half
  %9 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %18

11:                                               ; preds = %2
  %12 = tail call half @llvm.fabs.f16(half %0)
  %13 = fcmp oeq half %12, 0xH7C00
  %14 = tail call half @llvm.fabs.f16(half %1)
  %15 = fcmp oeq half %14, 0xH7C00
  %16 = or i1 %13, %15
  %17 = select i1 %16, half 0xH0000, half %8
  br label %18

18:                                               ; preds = %11, %2
  %19 = phi half [ %8, %2 ], [ %17, %11 ]
  ret half %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_rint_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.rint.f64(double %0)
  ret double %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_rint_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.rint.f32(float %0)
  ret float %2
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_rint_2f16(<2 x half> noundef %0) local_unnamed_addr #31 {
  %2 = tail call spir_func <2 x half> @llvm.rint.v2f16(<2 x half> noundef %0) #38
  ret <2 x half> %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_rint_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.rint.f16(half %0)
  ret half %2
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_rlen3_f64(double noundef %0, double noundef %1, double noundef %2) local_unnamed_addr #21 {
  %4 = alloca i32, align 4
  %5 = tail call double @llvm.fabs.f64(double %0)
  %6 = tail call double @llvm.fabs.f64(double %1)
  %7 = tail call double @llvm.fabs.f64(double %2)
  %8 = tail call double @llvm.maxnum.f64(double %5, double %6)
  %9 = tail call double @llvm.minnum.f64(double %5, double %6)
  %10 = tail call double @llvm.maxnum.f64(double %8, double %7)
  %11 = tail call double @llvm.minnum.f64(double %8, double %7)
  %12 = tail call double @llvm.maxnum.f64(double %9, double %11)
  %13 = tail call double @llvm.minnum.f64(double %9, double %11)
  %14 = fptrunc double %10 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %15 = addrspacecast ptr %4 to ptr addrspace(4)
  %16 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %14, ptr addrspace(4) noundef %15) #40
  %17 = load i32, ptr %4, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  %18 = sub nsw i32 0, %17
  %19 = call spir_func double @_Z5ldexpdi(double noundef %10, i32 noundef %18) #38
  %20 = call spir_func double @_Z5ldexpdi(double noundef %12, i32 noundef %18) #38
  %21 = call spir_func double @_Z5ldexpdi(double noundef %13, i32 noundef %18) #38
  %22 = fmul double %21, %21
  %23 = call double @llvm.fma.f64(double %20, double %20, double %22)
  %24 = call double @llvm.fma.f64(double %19, double %19, double %23)
  %25 = fptrunc double %24 to float
  %26 = call spir_func float @_Z12native_rsqrtf(float noundef %25) #38
  %27 = fpext float %26 to double
  %28 = fneg double %24
  %29 = fmul double %27, %28
  %30 = call double @llvm.fma.f64(double %29, double %27, double 1.000000e+00)
  %31 = fmul double %30, %27
  %32 = call double @llvm.fma.f64(double %30, double 3.750000e-01, double 5.000000e-01)
  %33 = call double @llvm.fma.f64(double %31, double %32, double %27)
  %34 = call spir_func double @_Z5ldexpdi(double noundef %33, i32 noundef %18) #38
  %35 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %37, label %50

37:                                               ; preds = %3
  %38 = fcmp oeq double %19, 0.000000e+00
  %39 = select i1 %38, double 0x7FF0000000000000, double %34
  %40 = fcmp uno double %0, %1
  %41 = fcmp uno double %2, 0.000000e+00
  %42 = or i1 %40, %41
  %43 = select i1 %42, double 0x7FF8000000000000, double %39
  %44 = fcmp oeq double %5, 0x7FF0000000000000
  %45 = fcmp oeq double %6, 0x7FF0000000000000
  %46 = or i1 %44, %45
  %47 = fcmp oeq double %7, 0x7FF0000000000000
  %48 = or i1 %46, %47
  %49 = select i1 %48, double 0.000000e+00, double %43
  br label %50

50:                                               ; preds = %37, %3
  %51 = phi double [ %34, %3 ], [ %49, %37 ]
  ret double %51
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_rlen3_f32(float noundef %0, float noundef %1, float noundef %2) local_unnamed_addr #21 {
  %4 = alloca i32, align 4
  %5 = tail call float @llvm.fabs.f32(float %0)
  %6 = tail call float @llvm.fabs.f32(float %1)
  %7 = tail call float @llvm.fabs.f32(float %2)
  %8 = bitcast float %5 to i32
  %9 = bitcast float %6 to i32
  %10 = tail call i32 @llvm.umax.i32(i32 %8, i32 %9)
  %11 = tail call i32 @llvm.umin.i32(i32 %8, i32 %9)
  %12 = bitcast float %7 to i32
  %13 = tail call i32 @llvm.umax.i32(i32 %10, i32 %12)
  %14 = bitcast i32 %13 to float
  %15 = tail call i32 @llvm.umin.i32(i32 %10, i32 %12)
  %16 = tail call i32 @llvm.umax.i32(i32 %11, i32 %15)
  %17 = bitcast i32 %16 to float
  %18 = tail call i32 @llvm.umin.i32(i32 %11, i32 %15)
  %19 = bitcast i32 %18 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %20 = addrspacecast ptr %4 to ptr addrspace(4)
  %21 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %14, ptr addrspace(4) noundef %20) #40
  %22 = load i32, ptr %4, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  %23 = sub nsw i32 0, %22
  %24 = call spir_func float @_Z5ldexpfi(float noundef %14, i32 noundef %23) #38
  %25 = call spir_func float @_Z5ldexpfi(float noundef %17, i32 noundef %23) #38
  %26 = call spir_func float @_Z5ldexpfi(float noundef %19, i32 noundef %23) #38
  %27 = fmul float %26, %26
  %28 = call spir_func float @__ocml_fmuladd_f32(float noundef %25, float noundef %25, float noundef %27) #38
  %29 = call spir_func float @__ocml_fmuladd_f32(float noundef %24, float noundef %24, float noundef %28) #38
  %30 = call spir_func float @_Z12native_rsqrtf(float noundef %29) #38
  %31 = call spir_func float @_Z5ldexpfi(float noundef %30, i32 noundef %23) #38
  %32 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %34, label %41

34:                                               ; preds = %3
  %35 = fcmp oeq float %5, 0x7FF0000000000000
  %36 = fcmp oeq float %6, 0x7FF0000000000000
  %37 = or i1 %35, %36
  %38 = fcmp oeq float %7, 0x7FF0000000000000
  %39 = or i1 %37, %38
  %40 = select i1 %39, float 0.000000e+00, float %31
  br label %41

41:                                               ; preds = %34, %3
  %42 = phi float [ %31, %3 ], [ %40, %34 ]
  ret float %42
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_rlen3_f16(half noundef %0, half noundef %1, half noundef %2) local_unnamed_addr #21 {
  %4 = fpext half %0 to float
  %5 = fpext half %1 to float
  %6 = fpext half %2 to float
  %7 = fmul float %6, %6
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef %5, float noundef %7) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %4, float noundef %4, float noundef %8) #38
  %10 = tail call spir_func float @_Z12native_rsqrtf(float noundef %9) #38
  %11 = fptrunc float %10 to half
  %12 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %14, label %24

14:                                               ; preds = %3
  %15 = tail call half @llvm.fabs.f16(half %0)
  %16 = fcmp oeq half %15, 0xH7C00
  %17 = tail call half @llvm.fabs.f16(half %1)
  %18 = fcmp oeq half %17, 0xH7C00
  %19 = or i1 %16, %18
  %20 = tail call half @llvm.fabs.f16(half %2)
  %21 = fcmp oeq half %20, 0xH7C00
  %22 = or i1 %19, %21
  %23 = select i1 %22, half 0xH0000, half %11
  br label %24

24:                                               ; preds = %14, %3
  %25 = phi half [ %11, %3 ], [ %23, %14 ]
  ret half %25
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_rlen4_f64(double noundef %0, double noundef %1, double noundef %2, double noundef %3) local_unnamed_addr #21 {
  %5 = alloca i32, align 4
  %6 = tail call double @llvm.fabs.f64(double %0)
  %7 = tail call double @llvm.fabs.f64(double %1)
  %8 = tail call double @llvm.fabs.f64(double %2)
  %9 = tail call double @llvm.fabs.f64(double %3)
  %10 = tail call double @llvm.maxnum.f64(double %6, double %7)
  %11 = tail call double @llvm.minnum.f64(double %6, double %7)
  %12 = tail call double @llvm.maxnum.f64(double %8, double %9)
  %13 = tail call double @llvm.minnum.f64(double %8, double %9)
  %14 = tail call double @llvm.maxnum.f64(double %10, double %12)
  %15 = tail call double @llvm.minnum.f64(double %10, double %12)
  %16 = tail call double @llvm.maxnum.f64(double %11, double %13)
  %17 = tail call double @llvm.minnum.f64(double %11, double %13)
  %18 = tail call double @llvm.maxnum.f64(double %16, double %15)
  %19 = tail call double @llvm.minnum.f64(double %16, double %15)
  %20 = fptrunc double %14 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %21 = addrspacecast ptr %5 to ptr addrspace(4)
  %22 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %20, ptr addrspace(4) noundef %21) #40
  %23 = load i32, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %24 = sub nsw i32 0, %23
  %25 = call spir_func double @_Z5ldexpdi(double noundef %14, i32 noundef %24) #38
  %26 = call spir_func double @_Z5ldexpdi(double noundef %18, i32 noundef %24) #38
  %27 = call spir_func double @_Z5ldexpdi(double noundef %19, i32 noundef %24) #38
  %28 = call spir_func double @_Z5ldexpdi(double noundef %17, i32 noundef %24) #38
  %29 = fmul double %28, %28
  %30 = call double @llvm.fma.f64(double %27, double %27, double %29)
  %31 = call double @llvm.fma.f64(double %26, double %26, double %30)
  %32 = call double @llvm.fma.f64(double %25, double %25, double %31)
  %33 = fptrunc double %32 to float
  %34 = call spir_func float @_Z12native_rsqrtf(float noundef %33) #38
  %35 = fpext float %34 to double
  %36 = fneg double %32
  %37 = fmul double %35, %36
  %38 = call double @llvm.fma.f64(double %37, double %35, double 1.000000e+00)
  %39 = fmul double %38, %35
  %40 = call double @llvm.fma.f64(double %38, double 3.750000e-01, double 5.000000e-01)
  %41 = call double @llvm.fma.f64(double %39, double %40, double %35)
  %42 = call spir_func double @_Z5ldexpdi(double noundef %41, i32 noundef %24) #38
  %43 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %44 = icmp eq i8 %43, 0
  br i1 %44, label %45, label %60

45:                                               ; preds = %4
  %46 = fcmp oeq double %25, 0.000000e+00
  %47 = select i1 %46, double 0x7FF0000000000000, double %42
  %48 = fcmp uno double %0, %1
  %49 = fcmp uno double %3, %2
  %50 = or i1 %48, %49
  %51 = select i1 %50, double 0x7FF8000000000000, double %47
  %52 = fcmp oeq double %6, 0x7FF0000000000000
  %53 = fcmp oeq double %7, 0x7FF0000000000000
  %54 = or i1 %52, %53
  %55 = fcmp oeq double %8, 0x7FF0000000000000
  %56 = or i1 %54, %55
  %57 = fcmp oeq double %9, 0x7FF0000000000000
  %58 = or i1 %56, %57
  %59 = select i1 %58, double 0.000000e+00, double %51
  br label %60

60:                                               ; preds = %45, %4
  %61 = phi double [ %42, %4 ], [ %59, %45 ]
  ret double %61
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_rlen4_f32(float noundef %0, float noundef %1, float noundef %2, float noundef %3) local_unnamed_addr #21 {
  %5 = alloca i32, align 4
  %6 = tail call float @llvm.fabs.f32(float %0)
  %7 = tail call float @llvm.fabs.f32(float %1)
  %8 = tail call float @llvm.fabs.f32(float %2)
  %9 = tail call float @llvm.fabs.f32(float %3)
  %10 = bitcast float %6 to i32
  %11 = bitcast float %7 to i32
  %12 = tail call i32 @llvm.umax.i32(i32 %10, i32 %11)
  %13 = tail call i32 @llvm.umin.i32(i32 %10, i32 %11)
  %14 = bitcast float %8 to i32
  %15 = bitcast float %9 to i32
  %16 = tail call i32 @llvm.umax.i32(i32 %14, i32 %15)
  %17 = tail call i32 @llvm.umin.i32(i32 %14, i32 %15)
  %18 = tail call i32 @llvm.umax.i32(i32 %12, i32 %16)
  %19 = bitcast i32 %18 to float
  %20 = tail call i32 @llvm.umin.i32(i32 %12, i32 %16)
  %21 = tail call i32 @llvm.umax.i32(i32 %13, i32 %17)
  %22 = tail call i32 @llvm.umin.i32(i32 %13, i32 %17)
  %23 = bitcast i32 %22 to float
  %24 = tail call i32 @llvm.umax.i32(i32 %21, i32 %20)
  %25 = bitcast i32 %24 to float
  %26 = tail call i32 @llvm.umin.i32(i32 %21, i32 %20)
  %27 = bitcast i32 %26 to float
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %28 = addrspacecast ptr %5 to ptr addrspace(4)
  %29 = call spir_func float @_Z5frexpfPU3AS4i(float noundef %19, ptr addrspace(4) noundef %28) #40
  %30 = load i32, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %31 = sub nsw i32 0, %30
  %32 = call spir_func float @_Z5ldexpfi(float noundef %19, i32 noundef %31) #38
  %33 = call spir_func float @_Z5ldexpfi(float noundef %25, i32 noundef %31) #38
  %34 = call spir_func float @_Z5ldexpfi(float noundef %27, i32 noundef %31) #38
  %35 = call spir_func float @_Z5ldexpfi(float noundef %23, i32 noundef %31) #38
  %36 = fmul float %35, %35
  %37 = call spir_func float @__ocml_fmuladd_f32(float noundef %34, float noundef %34, float noundef %36) #38
  %38 = call spir_func float @__ocml_fmuladd_f32(float noundef %33, float noundef %33, float noundef %37) #38
  %39 = call spir_func float @__ocml_fmuladd_f32(float noundef %32, float noundef %32, float noundef %38) #38
  %40 = call spir_func float @_Z12native_rsqrtf(float noundef %39) #38
  %41 = call spir_func float @_Z5ldexpfi(float noundef %40, i32 noundef %31) #38
  %42 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %44, label %53

44:                                               ; preds = %4
  %45 = fcmp oeq float %6, 0x7FF0000000000000
  %46 = fcmp oeq float %7, 0x7FF0000000000000
  %47 = or i1 %45, %46
  %48 = fcmp oeq float %8, 0x7FF0000000000000
  %49 = or i1 %47, %48
  %50 = fcmp oeq float %9, 0x7FF0000000000000
  %51 = or i1 %49, %50
  %52 = select i1 %51, float 0.000000e+00, float %41
  br label %53

53:                                               ; preds = %44, %4
  %54 = phi float [ %41, %4 ], [ %52, %44 ]
  ret float %54
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_rlen4_f16(half noundef %0, half noundef %1, half noundef %2, half noundef %3) local_unnamed_addr #21 {
  %5 = fpext half %0 to float
  %6 = fpext half %1 to float
  %7 = fpext half %2 to float
  %8 = fpext half %3 to float
  %9 = fmul float %8, %8
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %7, float noundef %9) #38
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %6, float noundef %6, float noundef %10) #38
  %12 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef %5, float noundef %11) #38
  %13 = tail call spir_func float @_Z12native_rsqrtf(float noundef %12) #38
  %14 = fptrunc float %13 to half
  %15 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %17, label %30

17:                                               ; preds = %4
  %18 = tail call half @llvm.fabs.f16(half %0)
  %19 = fcmp oeq half %18, 0xH7C00
  %20 = tail call half @llvm.fabs.f16(half %1)
  %21 = fcmp oeq half %20, 0xH7C00
  %22 = or i1 %19, %21
  %23 = tail call half @llvm.fabs.f16(half %2)
  %24 = fcmp oeq half %23, 0xH7C00
  %25 = or i1 %22, %24
  %26 = tail call half @llvm.fabs.f16(half %3)
  %27 = fcmp oeq half %26, 0xH7C00
  %28 = or i1 %25, %27
  %29 = select i1 %28, half 0xH0000, half %14
  br label %30

30:                                               ; preds = %17, %4
  %31 = phi half [ %14, %4 ], [ %29, %17 ]
  ret half %31
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_rootn_f64(double noundef %0, i32 noundef %1) local_unnamed_addr #21 {
  %3 = sitofp i32 %1 to double
  %4 = sitofp i32 %1 to float
  %5 = tail call spir_func float @_Z12native_recipf(float noundef %4) #38
  %6 = fpext float %5 to double
  %7 = fneg double %3
  %8 = tail call double @llvm.fma.f64(double %7, double %6, double 1.000000e+00)
  %9 = tail call double @llvm.fma.f64(double %8, double %6, double %6)
  %10 = tail call double @llvm.fma.f64(double %7, double %9, double 1.000000e+00)
  %11 = tail call double @llvm.fma.f64(double %10, double %9, double %9)
  %12 = fmul double %11, %3
  %13 = fneg double %12
  %14 = tail call double @llvm.fma.f64(double %11, double %3, double %13)
  %15 = fsub double 1.000000e+00, %12
  %16 = fsub double 1.000000e+00, %15
  %17 = fsub double %16, %12
  %18 = fsub double %17, %14
  %19 = fadd double %15, %18
  %20 = fmul double %11, %19
  %21 = fadd double %11, %20
  %22 = fsub double %21, %11
  %23 = fsub double %20, %22
  %24 = tail call double @llvm.fabs.f64(double %0)
  %25 = tail call spir_func <2 x double> @__ocmlpriv_epln_f64(double noundef %24) #38
  %26 = extractelement <2 x double> %25, i64 1
  %27 = fmul double %26, %21
  %28 = fneg double %27
  %29 = tail call double @llvm.fma.f64(double %21, double %26, double %28)
  %30 = extractelement <2 x double> %25, i64 0
  %31 = fmul double %26, %23
  %32 = tail call double @llvm.fma.f64(double %21, double %30, double %31)
  %33 = fadd double %29, %32
  %34 = fadd double %27, %33
  %35 = fsub double %34, %27
  %36 = fsub double %33, %35
  %37 = tail call double @llvm.fabs.f64(double %27)
  %38 = fcmp oeq double %37, 0x7FF0000000000000
  %39 = select i1 %38, double %27, double %34
  %40 = tail call double @llvm.fabs.f64(double %39)
  %41 = fcmp oeq double %40, 0x7FF0000000000000
  %42 = select i1 %41, double 0.000000e+00, double %36
  %43 = insertelement <2 x double> poison, double %42, i64 0
  %44 = insertelement <2 x double> %43, double %39, i64 1
  %45 = tail call spir_func double @__ocmlpriv_expep_f64(<2 x double> noundef %44) #38
  %46 = and i32 %1, 1
  %47 = fcmp olt double %0, 0.000000e+00
  %48 = icmp ne i32 %46, 0
  %49 = and i1 %47, %48
  %50 = select i1 %49, double -0.000000e+00, double 0.000000e+00
  %51 = tail call double @llvm.copysign.f64(double %45, double %50)
  %52 = fcmp oeq double %24, 0x7FF0000000000000
  %53 = fcmp oeq double %0, 0.000000e+00
  %54 = or i1 %53, %52
  br i1 %54, label %55, label %62

55:                                               ; preds = %2
  %56 = icmp eq i32 %46, 0
  %57 = icmp sgt i32 %1, -1
  %58 = xor i1 %53, %57
  %59 = select i1 %58, double 0x7FF0000000000000, double 0.000000e+00
  %60 = select i1 %56, double 0.000000e+00, double %0
  %61 = tail call double @llvm.copysign.f64(double %59, double %60)
  br label %62

62:                                               ; preds = %2, %55
  %63 = phi double [ %61, %55 ], [ %51, %2 ]
  %64 = icmp eq i32 %46, 0
  %65 = and i1 %47, %64
  %66 = icmp eq i32 %1, 0
  %67 = or i1 %66, %65
  %68 = select i1 %67, double 0x7FF8000000000000, double %63
  ret double %68
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_rootn_f32(float noundef %0, i32 noundef %1) local_unnamed_addr #21 {
  %3 = tail call float @llvm.fabs.f32(float %0)
  %4 = load i8, ptr addrspace(2) @__oclc_unsafe_math_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %29, label %6

6:                                                ; preds = %2
  %7 = sitofp i32 %1 to float
  %8 = tail call spir_func float @_Z12native_recipf(float noundef %7) #38
  %9 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %15, label %11

11:                                               ; preds = %6
  %12 = tail call float @llvm.log2.f32(float %3)
  %13 = fmul float %12, %8
  %14 = tail call float @llvm.exp2.f32(float %13)
  br label %209

15:                                               ; preds = %6
  %16 = fcmp olt float %3, 0x3810000000000000
  %17 = select i1 %16, float 0x4170000000000000, float 1.000000e+00
  %18 = fmul float %3, %17
  %19 = tail call float @llvm.log2.f32(float %18)
  %20 = select i1 %16, float 2.400000e+01, float 0.000000e+00
  %21 = fsub float %19, %20
  %22 = fmul float %21, %8
  %23 = fcmp olt float %22, -1.260000e+02
  %24 = select i1 %23, float 2.400000e+01, float 0.000000e+00
  %25 = fadd float %22, %24
  %26 = tail call float @llvm.exp2.f32(float %25)
  %27 = select i1 %23, float 0x3E70000000000000, float 1.000000e+00
  %28 = fmul float %27, %26
  br label %209

29:                                               ; preds = %2
  %30 = and i32 %1, -65536
  %31 = sitofp i32 %30 to float
  %32 = and i32 %1, 65535
  %33 = sitofp i32 %32 to float
  %34 = fadd float %31, %33
  %35 = fsub float %31, %34
  %36 = fadd float %35, %33
  %37 = tail call spir_func float @_Z12native_recipf(float noundef %34) #38
  %38 = fmul float %34, %37
  %39 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %40 = freeze i32 %39
  %41 = icmp sgt i32 %40, 8999
  br i1 %41, label %42, label %47

42:                                               ; preds = %29
  %43 = fneg float %38
  %44 = tail call float @llvm.fma.f32(float %37, float %34, float %43)
  %45 = insertelement <2 x float> poison, float %44, i64 0
  %46 = insertelement <2 x float> %45, float %38, i64 1
  br label %69

47:                                               ; preds = %29
  switch i32 %40, label %48 [
    i32 8001, label %62
    i32 7001, label %62
  ]

48:                                               ; preds = %47
  %49 = bitcast float %37 to i32
  %50 = and i32 %49, -4096
  %51 = bitcast i32 %50 to float
  %52 = fsub float %37, %51
  %53 = bitcast float %34 to i32
  %54 = and i32 %53, -4096
  %55 = bitcast i32 %54 to float
  %56 = fsub float %34, %55
  %57 = fneg float %38
  %58 = tail call float @llvm.fmuladd.f32(float %51, float %55, float %57)
  %59 = tail call float @llvm.fmuladd.f32(float %51, float %56, float %58)
  %60 = tail call float @llvm.fmuladd.f32(float %52, float %55, float %59)
  %61 = tail call float @llvm.fmuladd.f32(float %52, float %56, float %60)
  br label %65

62:                                               ; preds = %47, %47
  %63 = fneg float %38
  %64 = tail call float @llvm.fma.f32(float %37, float %34, float %63)
  br label %65

65:                                               ; preds = %62, %48
  %66 = phi float [ %64, %62 ], [ %61, %48 ]
  %67 = insertelement <2 x float> poison, float %66, i64 0
  %68 = insertelement <2 x float> %67, float %38, i64 1
  switch i32 %40, label %74 [
    i32 8001, label %69
    i32 7001, label %69
  ]

69:                                               ; preds = %65, %65, %42
  %70 = phi <2 x float> [ %68, %65 ], [ %68, %65 ], [ %46, %42 ]
  %71 = phi float [ %66, %65 ], [ %66, %65 ], [ %44, %42 ]
  %72 = tail call float @llvm.fma.f32(float %37, float %36, float %71)
  %73 = insertelement <2 x float> %70, float %72, i64 0
  br label %77

74:                                               ; preds = %65
  %75 = tail call float @llvm.fmuladd.f32(float %37, float %36, float %66)
  %76 = insertelement <2 x float> %68, float %75, i64 0
  br label %77

77:                                               ; preds = %74, %69
  %78 = phi <2 x float> [ %73, %69 ], [ %76, %74 ]
  %79 = extractelement <2 x float> %78, i64 1
  %80 = extractelement <2 x float> %78, i64 0
  %81 = fadd float %79, %80
  %82 = fsub float %81, %79
  %83 = fsub float 1.000000e+00, %81
  %84 = fsub float 1.000000e+00, %83
  %85 = fsub float %84, %81
  %86 = fsub float %82, %80
  %87 = fadd float %86, %85
  %88 = fadd float %83, %87
  %89 = fmul float %37, %88
  %90 = fmul float %34, %89
  br i1 %41, label %91, label %96

91:                                               ; preds = %77
  %92 = fneg float %90
  %93 = tail call float @llvm.fma.f32(float %89, float %34, float %92)
  %94 = insertelement <2 x float> poison, float %93, i64 0
  %95 = insertelement <2 x float> %94, float %90, i64 1
  br label %118

96:                                               ; preds = %77
  switch i32 %40, label %97 [
    i32 8001, label %111
    i32 7001, label %111
  ]

97:                                               ; preds = %96
  %98 = bitcast float %89 to i32
  %99 = and i32 %98, -4096
  %100 = bitcast i32 %99 to float
  %101 = fsub float %89, %100
  %102 = bitcast float %34 to i32
  %103 = and i32 %102, -4096
  %104 = bitcast i32 %103 to float
  %105 = fsub float %34, %104
  %106 = fneg float %90
  %107 = tail call float @llvm.fmuladd.f32(float %100, float %104, float %106)
  %108 = tail call float @llvm.fmuladd.f32(float %100, float %105, float %107)
  %109 = tail call float @llvm.fmuladd.f32(float %101, float %104, float %108)
  %110 = tail call float @llvm.fmuladd.f32(float %101, float %105, float %109)
  br label %114

111:                                              ; preds = %96, %96
  %112 = fneg float %90
  %113 = tail call float @llvm.fma.f32(float %89, float %34, float %112)
  br label %114

114:                                              ; preds = %111, %97
  %115 = phi float [ %113, %111 ], [ %110, %97 ]
  %116 = insertelement <2 x float> poison, float %115, i64 0
  %117 = insertelement <2 x float> %116, float %90, i64 1
  switch i32 %40, label %123 [
    i32 8001, label %118
    i32 7001, label %118
  ]

118:                                              ; preds = %114, %114, %91
  %119 = phi <2 x float> [ %117, %114 ], [ %117, %114 ], [ %95, %91 ]
  %120 = phi float [ %115, %114 ], [ %115, %114 ], [ %93, %91 ]
  %121 = tail call float @llvm.fma.f32(float %89, float %36, float %120)
  %122 = insertelement <2 x float> %119, float %121, i64 0
  br label %126

123:                                              ; preds = %114
  %124 = tail call float @llvm.fmuladd.f32(float %89, float %36, float %115)
  %125 = insertelement <2 x float> %117, float %124, i64 0
  br label %126

126:                                              ; preds = %118, %123
  %127 = phi <2 x float> [ %122, %118 ], [ %125, %123 ]
  %128 = fsub float %83, %88
  %129 = fadd float %87, %128
  %130 = extractelement <2 x float> %127, i64 1
  %131 = extractelement <2 x float> %127, i64 0
  %132 = fadd float %130, %131
  %133 = fsub float %132, %130
  %134 = fsub float %88, %132
  %135 = fsub float %88, %134
  %136 = fsub float %135, %132
  %137 = fadd float %129, %136
  %138 = fsub float %133, %131
  %139 = fadd float %138, %137
  %140 = fadd float %134, %139
  %141 = fmul float %37, %140
  %142 = fadd float %37, %89
  %143 = fsub float %142, %37
  %144 = fsub float %89, %143
  %145 = fadd float %144, %141
  %146 = fadd float %142, %145
  %147 = fsub float %146, %142
  %148 = fsub float %145, %147
  %149 = tail call spir_func <2 x float> @__ocmlpriv_epln_f32(float noundef %3) #38
  %150 = extractelement <2 x float> %149, i64 1
  %151 = fmul float %150, %146
  br i1 %41, label %152, label %157

152:                                              ; preds = %126
  %153 = fneg float %151
  %154 = tail call float @llvm.fma.f32(float %146, float %150, float %153)
  %155 = insertelement <2 x float> poison, float %154, i64 0
  %156 = insertelement <2 x float> %155, float %151, i64 1
  br label %179

157:                                              ; preds = %126
  switch i32 %40, label %158 [
    i32 8001, label %172
    i32 7001, label %172
  ]

158:                                              ; preds = %157
  %159 = bitcast float %146 to i32
  %160 = and i32 %159, -4096
  %161 = bitcast i32 %160 to float
  %162 = fsub float %146, %161
  %163 = bitcast float %150 to i32
  %164 = and i32 %163, -4096
  %165 = bitcast i32 %164 to float
  %166 = fsub float %150, %165
  %167 = fneg float %151
  %168 = tail call float @llvm.fmuladd.f32(float %161, float %165, float %167)
  %169 = tail call float @llvm.fmuladd.f32(float %161, float %166, float %168)
  %170 = tail call float @llvm.fmuladd.f32(float %162, float %165, float %169)
  %171 = tail call float @llvm.fmuladd.f32(float %162, float %166, float %170)
  br label %175

172:                                              ; preds = %157, %157
  %173 = fneg float %151
  %174 = tail call float @llvm.fma.f32(float %146, float %150, float %173)
  br label %175

175:                                              ; preds = %172, %158
  %176 = phi float [ %174, %172 ], [ %171, %158 ]
  %177 = insertelement <2 x float> poison, float %176, i64 0
  %178 = insertelement <2 x float> %177, float %151, i64 1
  switch i32 %40, label %187 [
    i32 8001, label %179
    i32 7001, label %179
  ]

179:                                              ; preds = %175, %175, %152
  %180 = phi <2 x float> [ %178, %175 ], [ %178, %175 ], [ %156, %152 ]
  %181 = phi float [ %176, %175 ], [ %176, %175 ], [ %154, %152 ]
  %182 = extractelement <2 x float> %149, i64 0
  %183 = fmul float %150, %148
  %184 = tail call float @llvm.fma.f32(float %146, float %182, float %183)
  %185 = fadd float %184, %181
  %186 = insertelement <2 x float> %180, float %185, i64 0
  br label %193

187:                                              ; preds = %175
  %188 = extractelement <2 x float> %149, i64 0
  %189 = fmul float %150, %148
  %190 = tail call float @llvm.fmuladd.f32(float %146, float %188, float %189)
  %191 = fadd float %190, %176
  %192 = insertelement <2 x float> %178, float %191, i64 0
  br label %193

193:                                              ; preds = %179, %187
  %194 = phi <2 x float> [ %186, %179 ], [ %192, %187 ]
  %195 = extractelement <2 x float> %194, i64 1
  %196 = extractelement <2 x float> %194, i64 0
  %197 = fadd float %195, %196
  %198 = fsub float %197, %195
  %199 = fsub float %196, %198
  %200 = tail call float @llvm.fabs.f32(float %195)
  %201 = fcmp oeq float %200, 0x7FF0000000000000
  %202 = select i1 %201, float %195, float %197
  %203 = tail call float @llvm.fabs.f32(float %202)
  %204 = fcmp oeq float %203, 0x7FF0000000000000
  %205 = select i1 %204, float 0.000000e+00, float %199
  %206 = insertelement <2 x float> poison, float %205, i64 0
  %207 = insertelement <2 x float> %206, float %202, i64 1
  %208 = tail call spir_func float @__ocmlpriv_expep_f32(<2 x float> noundef %207) #38
  br label %209

209:                                              ; preds = %11, %15, %193
  %210 = phi float [ %208, %193 ], [ %14, %11 ], [ %28, %15 ]
  %211 = and i32 %1, 1
  %212 = fcmp olt float %0, 0.000000e+00
  %213 = icmp ne i32 %211, 0
  %214 = and i1 %212, %213
  %215 = select i1 %214, float -0.000000e+00, float 0.000000e+00
  %216 = tail call float @llvm.copysign.f32(float %210, float %215)
  %217 = fcmp oeq float %3, 0x7FF0000000000000
  %218 = fcmp oeq float %0, 0.000000e+00
  %219 = or i1 %218, %217
  br i1 %219, label %220, label %227

220:                                              ; preds = %209
  %221 = icmp eq i32 %211, 0
  %222 = icmp sgt i32 %1, -1
  %223 = xor i1 %218, %222
  %224 = select i1 %223, float 0x7FF0000000000000, float 0.000000e+00
  %225 = select i1 %221, float 0.000000e+00, float %0
  %226 = tail call float @llvm.copysign.f32(float %224, float %225)
  br label %227

227:                                              ; preds = %209, %220
  %228 = phi float [ %226, %220 ], [ %216, %209 ]
  %229 = icmp eq i32 %211, 0
  %230 = and i1 %212, %229
  %231 = icmp eq i32 %1, 0
  %232 = or i1 %231, %230
  %233 = select i1 %232, float 0x7FF8000000000000, float %228
  ret float %233
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_rootn_2f16(<2 x half> noundef %0, <2 x i32> noundef %1) local_unnamed_addr #21 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x i32> %1, i64 0
  %5 = tail call spir_func half @__ocml_rootn_f16(half noundef %3, i32 noundef %4) #41
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = extractelement <2 x i32> %1, i64 1
  %9 = tail call spir_func half @__ocml_rootn_f16(half noundef %7, i32 noundef %8) #41
  %10 = insertelement <2 x half> %6, half %9, i64 1
  ret <2 x half> %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_rootn_f16(half noundef %0, i32 noundef %1) local_unnamed_addr #24 {
  %3 = tail call half @llvm.fabs.f16(half %0)
  %4 = sitofp i32 %1 to float
  %5 = tail call spir_func float @_Z12native_recipf(float noundef %4) #38
  %6 = fpext half %3 to float
  %7 = tail call float @llvm.log2.f32(float %6)
  %8 = fmul float %7, %5
  %9 = tail call float @llvm.exp2.f32(float %8)
  %10 = fptrunc float %9 to half
  %11 = fcmp uge half %0, 0xH0000
  %12 = and i32 %1, 1
  %13 = icmp eq i32 %12, 0
  %14 = or i1 %11, %13
  %15 = select i1 %14, half 0xH0000, half 0xH8000
  %16 = tail call half @llvm.copysign.f16(half %10, half %15)
  %17 = fcmp oeq half %0, 0xH0000
  %18 = icmp sgt i32 %1, -1
  %19 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %72

21:                                               ; preds = %2
  %22 = fptoui half %0 to i16
  %23 = tail call spir_func i32 @__builtin_generic_class_f16.100(i16 noundef zeroext %22, i32 noundef 960) #39, !range !56
  %24 = tail call spir_func i32 @__builtin_generic_class_f16.100(i16 noundef zeroext %22, i32 noundef 512) #39, !range !56
  %25 = tail call spir_func i32 @__builtin_generic_class_f16.100(i16 noundef zeroext %22, i32 noundef 4) #39, !range !56
  %26 = icmp ne i32 %23, 0
  %27 = fcmp uno half %0, 0xH0000
  %28 = icmp ne i32 %24, 0
  %29 = icmp eq i32 %25, 0
  %30 = xor i32 %12, 1
  %31 = icmp eq i32 %30, 0
  %32 = or i1 %31, %26
  %33 = select i1 %32, half %16, half 0xH7E00
  %34 = tail call half @llvm.copysign.f16(half 0xH7C00, half %0)
  %35 = zext i1 %17 to i32
  %36 = xor i1 %18, true
  %37 = zext i1 %36 to i32
  %38 = and i32 %37, %35
  %39 = and i32 %38, %12
  %40 = icmp eq i32 %39, 0
  %41 = select i1 %40, half %33, half %34
  %42 = and i32 %38, %30
  %43 = icmp eq i32 %42, 0
  %44 = select i1 %43, half %41, half 0xH7C00
  %45 = zext i1 %18 to i32
  %46 = and i32 %45, %35
  %47 = and i32 %46, %30
  %48 = icmp eq i32 %47, 0
  %49 = select i1 %48, half %44, half 0xH0000
  %50 = tail call half @llvm.copysign.f16(half 0xH0000, half %0)
  %51 = and i32 %46, %12
  %52 = icmp eq i32 %51, 0
  %53 = select i1 %52, half %49, half %50
  %54 = and i32 %1, 1
  %55 = select i1 %29, i32 0, i32 %54
  %56 = and i32 %55, %45
  %57 = icmp eq i32 %56, 0
  %58 = select i1 %57, half %53, half 0xHFC00
  %59 = and i32 %55, %37
  %60 = icmp eq i32 %59, 0
  %61 = select i1 %60, half %58, half 0xH8000
  %62 = zext i1 %28 to i32
  %63 = and i32 %62, %37
  %64 = icmp eq i32 %63, 0
  %65 = select i1 %64, half %61, half 0xH0000
  %66 = and i32 %62, %45
  %67 = icmp eq i32 %66, 0
  %68 = select i1 %67, half %65, half 0xH7C00
  %69 = select i1 %27, half %0, half %68
  %70 = icmp eq i32 %1, 0
  %71 = select i1 %70, half 0xH7E00, half %69
  br label %83

72:                                               ; preds = %2
  %73 = tail call half @llvm.copysign.f16(half 0xH0000, half %0)
  %74 = and i1 %17, %18
  %75 = zext i1 %74 to i32
  %76 = and i32 %75, %1
  %77 = icmp eq i32 %76, 0
  %78 = select i1 %77, half %16, half %73
  %79 = xor i32 %1, -1
  %80 = and i32 %75, %79
  %81 = icmp eq i32 %80, 0
  %82 = select i1 %81, half %78, half 0xH0000
  br label %83

83:                                               ; preds = %72, %21
  %84 = phi half [ %82, %72 ], [ %71, %21 ]
  ret half %84
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16.100(i16 noundef zeroext %0, i32 noundef %1) unnamed_addr #25 {
  %3 = and i32 %1, 512
  %4 = icmp ne i32 %3, 0
  %5 = icmp eq i16 %0, 31744
  %6 = and i1 %5, %4
  br i1 %6, label %35, label %7

7:                                                ; preds = %2
  %8 = and i32 %1, 4
  %9 = icmp ne i32 %8, 0
  %10 = icmp eq i16 %0, -1024
  %11 = and i1 %10, %9
  br i1 %11, label %35, label %12

12:                                               ; preds = %7
  %13 = and i32 %1, 3
  %14 = icmp eq i32 %13, 0
  %15 = and i16 %0, 32256
  %16 = icmp eq i16 %15, 0
  %17 = or i1 %16, %14
  br i1 %17, label %18, label %35

18:                                               ; preds = %12
  %19 = and i32 %1, 96
  %20 = icmp ne i32 %19, 0
  %21 = and i16 %0, 32767
  %22 = icmp eq i16 %21, 0
  %23 = and i1 %22, %20
  br i1 %23, label %35, label %24

24:                                               ; preds = %18
  %25 = and i32 %1, 144
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %34, label %27

27:                                               ; preds = %24
  %28 = zext i16 %0 to i32
  %29 = and i32 %28, 31744
  %30 = icmp ne i32 %29, 0
  %31 = and i32 %28, 1023
  %32 = icmp eq i32 %31, 0
  %33 = or i1 %30, %32
  br i1 %33, label %34, label %35

34:                                               ; preds = %27, %24
  br label %35

35:                                               ; preds = %27, %18, %12, %7, %2, %34
  %36 = phi i32 [ 0, %34 ], [ -1, %2 ], [ -1, %7 ], [ -1, %12 ], [ -1, %18 ], [ -1, %27 ]
  ret i32 %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_round_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.round.f64(double %0)
  ret double %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.round.f64(double) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_round_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.round.f32(float %0)
  ret float %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.round.f32(float) #2

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_round_2f16(<2 x half> noundef %0) local_unnamed_addr #31 {
  %2 = tail call spir_func <2 x half> @llvm.round.v2f16(<2 x half> noundef %0) #38
  ret <2 x half> %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <2 x half> @llvm.round.v2f16(<2 x half>) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_round_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.round.f16(half %0)
  ret half %2
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare half @llvm.round.f16(half) #2

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_rsqrt_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %3 = icmp eq i8 %2, 0
  br i1 %3, label %6, label %4

4:                                                ; preds = %1
  %5 = tail call spir_func float @_Z12native_rsqrtf(float noundef %0) #38
  br label %13

6:                                                ; preds = %1
  %7 = fcmp olt float %0, 0x39B0000000000000
  %8 = select i1 %7, float 0x4630000000000000, float 1.000000e+00
  %9 = fmul float %8, %0
  %10 = tail call spir_func float @_Z12native_rsqrtf(float noundef %9) #38
  %11 = select i1 %7, float 0x4310000000000000, float 1.000000e+00
  %12 = fmul float %11, %10
  br label %13

13:                                               ; preds = %6, %4
  %14 = phi float [ %5, %4 ], [ %12, %6 ]
  ret float %14
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_rsqrt_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_rsqrt_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_rsqrt_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_rsqrt_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @_Z10half_rsqrtf(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare spir_func float @_Z10half_rsqrtf(float noundef) local_unnamed_addr #22

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_scalb_f64(double noundef %0, double noundef %1) local_unnamed_addr #21 {
  %3 = alloca double, align 8
  %4 = alloca double, align 8
  %5 = alloca double, align 8
  %6 = tail call double @llvm.maxnum.f64(double %1, double 0xC130000000000000)
  %7 = tail call double @llvm.minnum.f64(double %6, double 0x4130000000000000)
  %8 = tail call double @llvm.rint.f64(double %7)
  %9 = fptosi double %8 to i32
  %10 = tail call spir_func double @__ocml_ldexp_f64(double noundef %0, i32 noundef %9) #38
  %11 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %13, label %32

13:                                               ; preds = %2
  %14 = fcmp uno double %0, %1
  %15 = select i1 %14, double 0x7FF8000000000000, double %10
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5)
  store double %0, ptr %5, align 8, !tbaa !19
  %16 = addrspacecast ptr %5 to ptr addrspace(4)
  %17 = load i128, ptr addrspace(4) %16, align 8, !tbaa !29
  %18 = and i128 %17, 9223372036854775807
  %19 = icmp ne i128 %18, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  store double %1, ptr %4, align 8, !tbaa !19
  %20 = addrspacecast ptr %4 to ptr addrspace(4)
  %21 = load i128, ptr addrspace(4) %20, align 8, !tbaa !29
  %22 = icmp ne i128 %21, 9218868437227405312
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %23 = or i1 %19, %22
  %24 = tail call double @llvm.fabs.f64(double %0)
  %25 = fcmp une double %24, 0x7FF0000000000000
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %1, ptr %3, align 8, !tbaa !19
  %26 = addrspacecast ptr %3 to ptr addrspace(4)
  %27 = load i128, ptr addrspace(4) %26, align 8, !tbaa !29
  %28 = icmp ne i128 %27, 18442240474082181120
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  %29 = select i1 %25, i1 true, i1 %28
  %30 = select i1 %29, i1 %23, i1 false
  %31 = select i1 %30, double %15, double 0x7FF8000000000000
  br label %32

32:                                               ; preds = %13, %2
  %33 = phi double [ %10, %2 ], [ %31, %13 ]
  ret double %33
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_scalb_f32(float noundef %0, float noundef %1) local_unnamed_addr #21 {
  %3 = alloca float, align 8
  %4 = alloca float, align 8
  %5 = fcmp olt float %1, 0xC130000000000000
  %6 = fcmp ogt float %1, 0x4130000000000000
  %7 = select i1 %6, float 0x4130000000000000, float %1
  %8 = select i1 %5, float 0xC130000000000000, float %7
  %9 = tail call float @llvm.rint.f32(float %8)
  %10 = fptosi float %9 to i32
  %11 = tail call spir_func float @__ocml_ldexp_f32(float noundef %0, i32 noundef %10) #38
  %12 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %14, label %28

14:                                               ; preds = %2
  %15 = fcmp uno float %0, %1
  %16 = tail call float @llvm.fabs.f32(float %0)
  %17 = fcmp oeq float %16, 0x7FF0000000000000
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4)
  store float %1, ptr %4, align 8, !tbaa !16
  %18 = addrspacecast ptr %4 to ptr addrspace(4)
  %19 = load i64, ptr addrspace(4) %18, align 8, !tbaa !12
  %20 = icmp eq i64 %19, 2139095040
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %1, ptr %3, align 8, !tbaa !16
  %21 = addrspacecast ptr %3 to ptr addrspace(4)
  %22 = load i64, ptr addrspace(4) %21, align 8, !tbaa !12
  %23 = icmp eq i64 %22, -8388608
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %24 = select i1 %23, i1 true, i1 %20
  %25 = and i1 %17, %24
  %26 = or i1 %15, %25
  %27 = select i1 %26, float 0x7FF8000000000000, float %11
  br label %28

28:                                               ; preds = %14, %2
  %29 = phi float [ %11, %2 ], [ %27, %14 ]
  ret float %29
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_scalb_2f16(<2 x half> noundef %0, <2 x half> noundef %1) local_unnamed_addr #21 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x half> %1, i64 0
  %5 = tail call spir_func half @__ocml_scalb_f16(half noundef %3, half noundef %4) #38
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = extractelement <2 x half> %1, i64 1
  %9 = tail call spir_func half @__ocml_scalb_f16(half noundef %7, half noundef %8) #38
  %10 = insertelement <2 x half> %6, half %9, i64 1
  ret <2 x half> %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_scalb_f16(half noundef %0, half noundef %1) local_unnamed_addr #24 {
  %3 = tail call half @llvm.maxnum.f16(half %1, half 0xHD400)
  %4 = tail call half @llvm.minnum.f16(half %3, half 0xH5400)
  %5 = tail call half @llvm.rint.f16(half %4)
  %6 = fptosi half %5 to i32
  %7 = tail call spir_func half @__ocml_ldexp_f16(half noundef %0, i32 noundef %6) #38
  %8 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %10, label %27

10:                                               ; preds = %2
  %11 = fcmp uno half %0, %1
  %12 = select i1 %11, half 0xH7E00, half %7
  %13 = fptoui half %0 to i16
  %14 = tail call spir_func i32 @__builtin_generic_class_f16.103(i16 noundef zeroext %13, i32 noundef 96) #39, !range !56
  %15 = fptoui half %1 to i16
  %16 = tail call spir_func i32 @__builtin_generic_class_f16.103(i16 noundef zeroext %15, i32 noundef 512) #39, !range !56
  %17 = and i32 %16, %14
  %18 = icmp eq i32 %17, 0
  %19 = tail call half @llvm.fabs.f16(half %0)
  %20 = fcmp une half %19, 0xH7C00
  %21 = tail call spir_func i32 @__builtin_generic_class_f16.103(i16 noundef zeroext %15, i32 noundef 4) #39, !range !56
  %22 = and i32 %21, 1
  %23 = icmp eq i32 %22, 0
  %24 = or i1 %20, %23
  %25 = and i1 %18, %24
  %26 = select i1 %25, half %12, half 0xH7E00
  br label %27

27:                                               ; preds = %10, %2
  %28 = phi half [ %7, %2 ], [ %26, %10 ]
  ret half %28
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16.103(i16 noundef zeroext %0, i32 noundef %1) unnamed_addr #25 {
  %3 = and i32 %1, 512
  %4 = icmp ne i32 %3, 0
  %5 = icmp eq i16 %0, 31744
  %6 = and i1 %5, %4
  br i1 %6, label %35, label %7

7:                                                ; preds = %2
  %8 = and i32 %1, 4
  %9 = icmp ne i32 %8, 0
  %10 = icmp eq i16 %0, -1024
  %11 = and i1 %10, %9
  br i1 %11, label %35, label %12

12:                                               ; preds = %7
  %13 = and i32 %1, 3
  %14 = icmp eq i32 %13, 0
  %15 = and i16 %0, 32256
  %16 = icmp eq i16 %15, 0
  %17 = or i1 %16, %14
  br i1 %17, label %18, label %35

18:                                               ; preds = %12
  %19 = and i32 %1, 96
  %20 = icmp ne i32 %19, 0
  %21 = and i16 %0, 32767
  %22 = icmp eq i16 %21, 0
  %23 = and i1 %22, %20
  br i1 %23, label %35, label %24

24:                                               ; preds = %18
  %25 = and i32 %1, 144
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %34, label %27

27:                                               ; preds = %24
  %28 = zext i16 %0 to i32
  %29 = and i32 %28, 31744
  %30 = icmp ne i32 %29, 0
  %31 = and i32 %28, 1023
  %32 = icmp eq i32 %31, 0
  %33 = or i1 %30, %32
  br i1 %33, label %34, label %35

34:                                               ; preds = %27, %24
  br label %35

35:                                               ; preds = %27, %18, %12, %7, %2, %34
  %36 = phi i32 [ 0, %34 ], [ -1, %2 ], [ -1, %7 ], [ -1, %12 ], [ -1, %18 ], [ -1, %27 ]
  ret i32 %36
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_scalbn_f64(double noundef %0, i32 noundef %1) local_unnamed_addr #21 {
  %3 = tail call spir_func double @__ocml_ldexp_f64(double noundef %0, i32 noundef %1) #38
  ret double %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_scalbn_f32(float noundef %0, i32 noundef %1) local_unnamed_addr #21 {
  %3 = tail call spir_func float @__ocml_ldexp_f32(float noundef %0, i32 noundef %1) #38
  ret float %3
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_scalbn_2f16(<2 x half> noundef %0, <2 x i32> noundef %1) local_unnamed_addr #24 {
  %3 = extractelement <2 x half> %0, i64 0
  %4 = extractelement <2 x i32> %1, i64 0
  %5 = tail call spir_func half @__ocml_ldexp_f16(half noundef %3, i32 noundef %4) #38
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = extractelement <2 x i32> %1, i64 1
  %9 = tail call spir_func half @__ocml_ldexp_f16(half noundef %7, i32 noundef %8) #38
  %10 = insertelement <2 x half> %6, half %9, i64 1
  ret <2 x half> %10
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_scalbn_f16(half noundef %0, i32 noundef %1) local_unnamed_addr #24 {
  %3 = tail call spir_func half @__ocml_ldexp_f16(half noundef %0, i32 noundef %1) #38
  ret half %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef i32 @__ocml_signbit_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = bitcast double %0 to <2 x i32>
  %3 = extractelement <2 x i32> %2, i64 1
  %4 = lshr i32 %3, 31
  ret i32 %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef i32 @__ocml_signbit_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = bitcast float %0 to i32
  %3 = lshr i32 %2, 31
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x i16> @__ocml_signbit_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = bitcast <2 x half> %0 to <2 x i16>
  %3 = extractelement <2 x i16> %2, i64 0
  %4 = ashr i16 %3, 15
  %5 = insertelement <2 x i16> poison, i16 %4, i64 0
  %6 = extractelement <2 x i16> %2, i64 1
  %7 = ashr i16 %6, 15
  %8 = insertelement <2 x i16> %5, i16 %7, i64 1
  ret <2 x i16> %8
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func i32 @__ocml_signbit_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = bitcast half %0 to i16
  %3 = lshr i16 %2, 15
  %4 = zext nneg i16 %3 to i32
  ret i32 %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_sin_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca %struct.redret, align 8
  %4 = alloca %struct.scret, align 8
  %5 = tail call double @llvm.fabs.f64(double %0)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3) #39
  call spir_func void @__ocmlpriv_trigred_f64(ptr dead_on_unwind nonnull writable sret(%struct.redret) align 8 %3, double noundef %5) #43
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #39
  %6 = getelementptr inbounds %struct.redret, ptr %3, i64 0, i32 1
  %7 = load double, ptr %6, align 8, !tbaa !31
  %8 = load double, ptr %3, align 8, !tbaa !33
  call spir_func void @__ocmlpriv_sincosred2_f64(ptr dead_on_unwind nonnull writable sret(%struct.scret) align 8 %4, double noundef %7, double noundef %8) #43
  %9 = getelementptr inbounds %struct.redret, ptr %3, i64 0, i32 2
  %10 = load i32, ptr %9, align 8, !tbaa !34
  %11 = and i32 %10, 1
  %12 = icmp eq i32 %11, 0
  %13 = load double, ptr %4, align 8
  %14 = getelementptr inbounds %struct.scret, ptr %4, i64 0, i32 1
  %15 = load double, ptr %14, align 8
  %16 = select i1 %12, double %13, double %15
  %17 = bitcast double %16 to <2 x i32>
  %18 = icmp sgt i32 %10, 1
  %19 = select i1 %18, i32 -2147483648, i32 0
  %20 = bitcast double %0 to <2 x i32>
  %21 = extractelement <2 x i32> %20, i64 1
  %22 = and i32 %21, -2147483648
  %23 = xor i32 %19, %22
  %24 = extractelement <2 x i32> %17, i64 1
  %25 = xor i32 %23, %24
  %26 = insertelement <2 x i32> %17, i32 %25, i64 1
  %27 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %29, label %43

29:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %5, ptr %2, align 8, !tbaa !19
  %30 = addrspacecast ptr %2 to ptr addrspace(4)
  %31 = load i128, ptr addrspace(4) %30, align 8, !tbaa !29
  %32 = and i128 %31, 9223372036854775807
  %33 = icmp eq i128 %32, 0
  br i1 %33, label %34, label %35

34:                                               ; preds = %29
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  br label %43

35:                                               ; preds = %29
  %36 = and i128 %31, 9218868437227405312
  %37 = icmp ne i128 %36, 0
  %38 = and i128 %31, 4503599627370495
  %39 = icmp eq i128 %38, 0
  %40 = or i1 %37, %39
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %41 = freeze i1 %40
  %42 = select i1 %41, <2 x i32> <i32 0, i32 2146959360>, <2 x i32> %26
  br label %43

43:                                               ; preds = %35, %34, %1
  %44 = phi <2 x i32> [ %26, %1 ], [ %26, %34 ], [ %42, %35 ]
  %45 = bitcast <2 x i32> %44 to double
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3) #39
  ret double %45
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_sin_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca %struct.redret.0, align 4
  %4 = alloca %struct.scret.1, align 4
  %5 = tail call float @llvm.fabs.f32(float %0)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #39
  call spir_func void @__ocmlpriv_trigred_f32(ptr dead_on_unwind nonnull writable sret(%struct.redret.0) align 4 %3, float noundef %5) #43
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #39
  %6 = load float, ptr %3, align 4, !tbaa !38
  call spir_func void @__ocmlpriv_sincosred_f32(ptr dead_on_unwind nonnull writable sret(%struct.scret.1) align 4 %4, float noundef %6) #43
  %7 = getelementptr inbounds %struct.redret.0, ptr %3, i64 0, i32 1
  %8 = load i32, ptr %7, align 4, !tbaa !40
  %9 = and i32 %8, 1
  %10 = icmp eq i32 %9, 0
  %11 = getelementptr inbounds %struct.scret.1, ptr %4, i64 0, i32 1
  %12 = load float, ptr %11, align 4
  %13 = load float, ptr %4, align 4
  %14 = select i1 %10, float %13, float %12
  %15 = bitcast float %14 to i32
  %16 = icmp sgt i32 %8, 1
  %17 = select i1 %16, i32 -2147483648, i32 0
  %18 = bitcast float %0 to i32
  %19 = bitcast float %5 to i32
  %20 = xor i32 %19, %18
  %21 = xor i32 %20, %17
  %22 = xor i32 %21, %15
  %23 = bitcast i32 %22 to float
  %24 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %26, label %40

26:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %5, ptr %2, align 8, !tbaa !16
  %27 = addrspacecast ptr %2 to ptr addrspace(4)
  %28 = load i64, ptr addrspace(4) %27, align 8, !tbaa !12
  %29 = and i64 %28, 2147483647
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %32

31:                                               ; preds = %26
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %40

32:                                               ; preds = %26
  %33 = and i64 %28, 2139095040
  %34 = icmp ne i64 %33, 0
  %35 = and i64 %28, 8388607
  %36 = icmp eq i64 %35, 0
  %37 = or i1 %34, %36
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %38 = freeze i1 %37
  %39 = select i1 %38, float 0x7FF8000000000000, float %23
  br label %40

40:                                               ; preds = %32, %31, %1
  %41 = phi float [ %23, %1 ], [ %23, %31 ], [ %39, %32 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #39
  ret float %41
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_sin_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_sin_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_sin_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_sin_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = alloca %struct.redret.2, align 2
  %3 = alloca %struct.scret.3, align 2
  %4 = tail call half @llvm.fabs.f16(half %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  call spir_func void @__ocmlpriv_trigred_f16(ptr dead_on_unwind nonnull writable sret(%struct.redret.2) align 2 %2, half noundef %4) #43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %5 = load half, ptr %2, align 2, !tbaa !45
  call spir_func void @__ocmlpriv_sincosred_f16(ptr dead_on_unwind nonnull writable sret(%struct.scret.3) align 2 %3, half noundef %5) #43
  %6 = getelementptr inbounds %struct.redret.2, ptr %2, i64 0, i32 1
  %7 = load i16, ptr %6, align 2, !tbaa !51
  %8 = and i16 %7, 1
  %9 = icmp eq i16 %8, 0
  %10 = load half, ptr %3, align 2
  %11 = getelementptr inbounds %struct.scret.3, ptr %3, i64 0, i32 1
  %12 = load half, ptr %11, align 2
  %13 = select i1 %9, half %10, half %12
  %14 = bitcast half %13 to i16
  %15 = icmp sgt i16 %7, 1
  %16 = select i1 %15, i16 -32768, i16 0
  %17 = bitcast half %0 to i16
  %18 = and i16 %17, -32768
  %19 = xor i16 %16, %18
  %20 = xor i16 %19, %14
  %21 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %28

23:                                               ; preds = %1
  %24 = fptoui half %4 to i16
  %25 = call spir_func i32 @__builtin_generic_class_f16.104(i16 noundef zeroext %24) #39
  %26 = icmp eq i32 %25, 0
  %27 = select i1 %26, i16 32256, i16 %20
  br label %28

28:                                               ; preds = %23, %1
  %29 = phi i16 [ %20, %1 ], [ %27, %23 ]
  %30 = bitcast i16 %29 to half
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret half %30
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func i32 @__builtin_generic_class_f16.104(i16 noundef zeroext %0) unnamed_addr #25 {
  %2 = and i16 %0, 32767
  %3 = icmp eq i16 %2, 0
  br i1 %3, label %12, label %4

4:                                                ; preds = %1
  %5 = zext i16 %0 to i32
  %6 = and i32 %5, 31744
  %7 = icmp eq i32 %6, 0
  %8 = and i32 %5, 1023
  %9 = icmp ne i32 %8, 0
  %10 = and i1 %7, %9
  %11 = sext i1 %10 to i32
  br label %12

12:                                               ; preds = %4, %1
  %13 = phi i32 [ -1, %1 ], [ %11, %4 ]
  ret i32 %13
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_sinb_f64(double noundef %0, i32 noundef %1, double noundef %2) local_unnamed_addr #21 {
  %4 = alloca %struct.redret, align 8
  %5 = alloca %struct.scret, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4) #39
  call spir_func void @__ocmlpriv_trigred_f64(ptr dead_on_unwind nonnull writable sret(%struct.redret) align 8 %4, double noundef %0) #43
  %6 = getelementptr inbounds %struct.redret, ptr %4, i64 0, i32 1
  %7 = load double, ptr %6, align 8, !tbaa !31
  %8 = fcmp olt double %7, %2
  %9 = getelementptr inbounds %struct.redret, ptr %4, i64 0, i32 2
  %10 = load i32, ptr %9, align 8, !tbaa !34
  %11 = sext i1 %8 to i32
  %12 = sub i32 %10, %1
  %13 = add i32 %12, %11
  %14 = select i1 %8, i32 -2147483648, i32 0
  %15 = xor i32 %14, -1075240453
  %16 = insertelement <2 x i32> <i32 1413754136, i32 poison>, i32 %15, i64 1
  %17 = bitcast <2 x i32> %16 to double
  %18 = xor i32 %14, -1132354010
  %19 = insertelement <2 x i32> <i32 856972295, i32 poison>, i32 %18, i64 1
  %20 = bitcast <2 x i32> %19 to double
  %21 = fsub double %17, %2
  %22 = fsub double %17, %21
  %23 = fsub double %22, %2
  %24 = fadd double %23, %20
  %25 = fadd double %21, %24
  %26 = fsub double %25, %21
  %27 = fsub double %24, %26
  %28 = fadd double %7, %25
  %29 = fsub double %28, %25
  %30 = fsub double %7, %29
  %31 = load double, ptr %4, align 8, !tbaa !33
  %32 = fadd double %31, %27
  %33 = fadd double %30, %32
  %34 = fadd double %28, %33
  %35 = fsub double %34, %28
  %36 = fsub double %33, %35
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %5) #39
  call spir_func void @__ocmlpriv_sincosred2_f64(ptr dead_on_unwind nonnull writable sret(%struct.scret) align 8 %5, double noundef %34, double noundef %36) #43
  %37 = and i32 %13, 1
  %38 = icmp eq i32 %37, 0
  %39 = load double, ptr %5, align 8
  %40 = getelementptr inbounds %struct.scret, ptr %5, i64 0, i32 1
  %41 = load double, ptr %40, align 8
  %42 = select i1 %38, double %39, double %41
  %43 = bitcast double %42 to <2 x i32>
  %44 = shl i32 %13, 30
  %45 = and i32 %44, -2147483648
  %46 = extractelement <2 x i32> %43, i64 1
  %47 = xor i32 %46, %45
  %48 = insertelement <2 x i32> %43, i32 %47, i64 1
  %49 = bitcast <2 x i32> %48 to double
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %5) #39
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4) #39
  ret double %49
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_sinb_f32(float noundef %0, i32 noundef %1, float noundef %2) local_unnamed_addr #21 {
  %4 = alloca %struct.redret.0, align 4
  %5 = alloca %struct.scret.1, align 4
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #39
  call spir_func void @__ocmlpriv_trigred_f32(ptr dead_on_unwind nonnull writable sret(%struct.redret.0) align 4 %4, float noundef %0) #43
  %6 = load float, ptr %4, align 4, !tbaa !38
  %7 = fcmp olt float %6, %2
  %8 = getelementptr inbounds %struct.redret.0, ptr %4, i64 0, i32 1
  %9 = load i32, ptr %8, align 4, !tbaa !40
  %10 = sext i1 %7 to i32
  %11 = sub i32 %9, %1
  %12 = add i32 %11, %10
  %13 = fsub float %6, %2
  %14 = select i1 %7, float 0x3FE921FB60000000, float 0xBFE921FB60000000
  %15 = fadd float %13, %14
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5) #39
  call spir_func void @__ocmlpriv_sincosred_f32(ptr dead_on_unwind nonnull writable sret(%struct.scret.1) align 4 %5, float noundef %15) #43
  %16 = and i32 %12, 1
  %17 = icmp eq i32 %16, 0
  %18 = getelementptr inbounds %struct.scret.1, ptr %5, i64 0, i32 1
  %19 = load float, ptr %18, align 4
  %20 = load float, ptr %5, align 4
  %21 = select i1 %17, float %20, float %19
  %22 = bitcast float %21 to i32
  %23 = shl i32 %12, 30
  %24 = and i32 %23, -2147483648
  %25 = xor i32 %24, %22
  %26 = bitcast i32 %25 to float
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5) #39
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #39
  ret float %26
}

; Function Attrs: convergent mustprogress norecurse nounwind willreturn memory(argmem: write)
define protected spir_func <2 x half> @__ocml_sincos_2f16(<2 x half> noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #37 {
  %3 = alloca %struct.redret.2, align 2
  %4 = alloca %struct.scret.3, align 2
  %5 = alloca %struct.redret.2, align 2
  %6 = alloca %struct.scret.3, align 2
  %7 = extractelement <2 x half> %0, i64 0
  %8 = tail call half @llvm.fabs.f16(half %7)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  call spir_func void @__ocmlpriv_trigred_f16(ptr dead_on_unwind nonnull writable sret(%struct.redret.2) align 2 %5, half noundef %8) #43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6) #39
  %9 = load half, ptr %5, align 2, !tbaa !45
  call spir_func void @__ocmlpriv_sincosred_f16(ptr dead_on_unwind nonnull writable sret(%struct.scret.3) align 2 %6, half noundef %9) #43
  %10 = getelementptr inbounds %struct.redret.2, ptr %5, i64 0, i32 1
  %11 = load i16, ptr %10, align 2, !tbaa !51
  %12 = icmp sgt i16 %11, 1
  %13 = select i1 %12, i16 -32768, i16 0
  %14 = and i16 %11, 1
  %15 = icmp eq i16 %14, 0
  %16 = getelementptr inbounds %struct.scret.3, ptr %6, i64 0, i32 1
  %17 = load half, ptr %16, align 2
  %18 = load half, ptr %6, align 2
  %19 = select i1 %15, half %18, half %17
  %20 = bitcast half %19 to i16
  %21 = bitcast half %7 to i16
  %22 = and i16 %21, -32768
  %23 = xor i16 %22, %20
  %24 = xor i16 %23, %13
  %25 = fneg half %18
  %26 = select i1 %15, half %17, half %25
  %27 = bitcast half %26 to i16
  %28 = xor i16 %13, %27
  %29 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %31, label %37

31:                                               ; preds = %2
  %32 = fptoui half %8 to i16
  %33 = call spir_func i32 @__builtin_generic_class_f16.109(i16 noundef zeroext %32) #39
  %34 = icmp eq i32 %33, 0
  %35 = select i1 %34, i16 32256, i16 %28
  %36 = select i1 %34, i16 32256, i16 %24
  br label %37

37:                                               ; preds = %2, %31
  %38 = phi i16 [ %28, %2 ], [ %35, %31 ]
  %39 = phi i16 [ %24, %2 ], [ %36, %31 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6) #39
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %40 = extractelement <2 x half> %0, i64 1
  %41 = call half @llvm.fabs.f16(half %40)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  call spir_func void @__ocmlpriv_trigred_f16(ptr dead_on_unwind nonnull writable sret(%struct.redret.2) align 2 %3, half noundef %41) #43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %42 = load half, ptr %3, align 2, !tbaa !45
  call spir_func void @__ocmlpriv_sincosred_f16(ptr dead_on_unwind nonnull writable sret(%struct.scret.3) align 2 %4, half noundef %42) #43
  %43 = getelementptr inbounds %struct.redret.2, ptr %3, i64 0, i32 1
  %44 = load i16, ptr %43, align 2, !tbaa !51
  %45 = icmp sgt i16 %44, 1
  %46 = select i1 %45, i16 -32768, i16 0
  %47 = and i16 %44, 1
  %48 = icmp eq i16 %47, 0
  %49 = getelementptr inbounds %struct.scret.3, ptr %4, i64 0, i32 1
  %50 = load half, ptr %49, align 2
  %51 = load half, ptr %4, align 2
  %52 = select i1 %48, half %51, half %50
  %53 = bitcast half %52 to i16
  %54 = bitcast half %40 to i16
  %55 = and i16 %54, -32768
  %56 = xor i16 %55, %53
  %57 = xor i16 %56, %46
  %58 = fneg half %51
  %59 = select i1 %48, half %50, half %58
  %60 = bitcast half %59 to i16
  %61 = xor i16 %46, %60
  br i1 %30, label %62, label %68

62:                                               ; preds = %37
  %63 = fptoui half %41 to i16
  %64 = call spir_func i32 @__builtin_generic_class_f16.109(i16 noundef zeroext %63) #39
  %65 = icmp eq i32 %64, 0
  %66 = select i1 %65, i16 32256, i16 %61
  %67 = select i1 %65, i16 32256, i16 %57
  br label %68

68:                                               ; preds = %37, %62
  %69 = phi i16 [ %61, %37 ], [ %66, %62 ]
  %70 = phi i16 [ %57, %37 ], [ %67, %62 ]
  %71 = insertelement <2 x i16> poison, i16 %39, i64 0
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %72 = insertelement <2 x i16> %71, i16 %70, i64 1
  %73 = bitcast <2 x i16> %72 to <2 x half>
  %74 = insertelement <2 x i16> poison, i16 %38, i64 0
  %75 = insertelement <2 x i16> %74, i16 %69, i64 1
  store <2 x i16> %75, ptr %1, align 4, !tbaa !14
  ret <2 x half> %73
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func i32 @__builtin_generic_class_f16.109(i16 noundef zeroext %0) unnamed_addr #25 {
  %2 = and i16 %0, 32767
  %3 = icmp eq i16 %2, 0
  br i1 %3, label %12, label %4

4:                                                ; preds = %1
  %5 = zext i16 %0 to i32
  %6 = and i32 %5, 31744
  %7 = icmp eq i32 %6, 0
  %8 = and i32 %5, 1023
  %9 = icmp ne i32 %8, 0
  %10 = and i1 %7, %9
  %11 = sext i1 %10 to i32
  br label %12

12:                                               ; preds = %4, %1
  %13 = phi i32 [ -1, %1 ], [ %11, %4 ]
  ret i32 %13
}

; Function Attrs: convergent mustprogress norecurse nounwind willreturn memory(argmem: write)
define protected spir_func half @__ocml_sincos_f16(half noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #37 {
  %3 = alloca %struct.redret.2, align 2
  %4 = alloca %struct.scret.3, align 2
  %5 = tail call half @llvm.fabs.f16(half %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  call spir_func void @__ocmlpriv_trigred_f16(ptr dead_on_unwind nonnull writable sret(%struct.redret.2) align 2 %3, half noundef %5) #43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %6 = load half, ptr %3, align 2, !tbaa !45
  call spir_func void @__ocmlpriv_sincosred_f16(ptr dead_on_unwind nonnull writable sret(%struct.scret.3) align 2 %4, half noundef %6) #43
  %7 = getelementptr inbounds %struct.redret.2, ptr %3, i64 0, i32 1
  %8 = load i16, ptr %7, align 2, !tbaa !51
  %9 = icmp sgt i16 %8, 1
  %10 = select i1 %9, i16 -32768, i16 0
  %11 = and i16 %8, 1
  %12 = icmp eq i16 %11, 0
  %13 = getelementptr inbounds %struct.scret.3, ptr %4, i64 0, i32 1
  %14 = load half, ptr %13, align 2
  %15 = load half, ptr %4, align 2
  %16 = select i1 %12, half %15, half %14
  %17 = bitcast half %16 to i16
  %18 = bitcast half %0 to i16
  %19 = and i16 %18, -32768
  %20 = xor i16 %19, %17
  %21 = xor i16 %20, %10
  %22 = fneg half %15
  %23 = select i1 %12, half %14, half %22
  %24 = bitcast half %23 to i16
  %25 = xor i16 %10, %24
  %26 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %28, label %34

28:                                               ; preds = %2
  %29 = fptoui half %5 to i16
  %30 = call spir_func i32 @__builtin_generic_class_f16.109(i16 noundef zeroext %29) #39
  %31 = icmp eq i32 %30, 0
  %32 = select i1 %31, i16 32256, i16 %25
  %33 = select i1 %31, i16 32256, i16 %21
  br label %34

34:                                               ; preds = %28, %2
  %35 = phi i16 [ %25, %2 ], [ %32, %28 ]
  %36 = phi i16 [ %21, %2 ], [ %33, %28 ]
  store i16 %35, ptr %1, align 2, !tbaa !57
  %37 = bitcast i16 %36 to half
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  ret half %37
}

; Function Attrs: convergent mustprogress norecurse nounwind willreturn memory(argmem: write)
define protected spir_func double @__ocml_sincospi_f64(double noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #27 {
  %3 = alloca double, align 8
  %4 = alloca %struct.redret.8, align 8
  %5 = alloca %struct.scret, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %4) #39
  %6 = tail call double @llvm.fabs.f64(double %0)
  call spir_func void @__ocmlpriv_trigpired_f64(ptr dead_on_unwind nonnull writable sret(%struct.redret.8) align 8 %4, double noundef %6) #43
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %5) #39
  %7 = load double, ptr %4, align 8, !tbaa !53
  call spir_func void @__ocmlpriv_sincospired_f64(ptr dead_on_unwind nonnull writable sret(%struct.scret) align 8 %5, double noundef %7) #43
  %8 = getelementptr inbounds %struct.redret.8, ptr %4, i64 0, i32 1
  %9 = load i32, ptr %8, align 8, !tbaa !55
  %10 = icmp sgt i32 %9, 1
  %11 = select i1 %10, i32 -2147483648, i32 0
  %12 = and i32 %9, 1
  %13 = icmp eq i32 %12, 0
  %14 = load double, ptr %5, align 8
  %15 = getelementptr inbounds %struct.scret, ptr %5, i64 0, i32 1
  %16 = load double, ptr %15, align 8
  %17 = select i1 %13, double %16, double %14
  %18 = bitcast double %17 to <2 x i32>
  %19 = bitcast double %0 to <2 x i32>
  %20 = extractelement <2 x i32> %19, i64 1
  %21 = and i32 %20, -2147483648
  %22 = extractelement <2 x i32> %18, i64 1
  %23 = xor i32 %21, %22
  %24 = xor i32 %23, %11
  %25 = insertelement <2 x i32> %18, i32 %24, i64 1
  %26 = fneg double %16
  %27 = select i1 %13, double %14, double %26
  %28 = bitcast double %27 to <2 x i32>
  %29 = extractelement <2 x i32> %28, i64 1
  %30 = xor i32 %29, %11
  %31 = insertelement <2 x i32> %28, i32 %30, i64 1
  %32 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %34, label %42

34:                                               ; preds = %2
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3)
  store double %0, ptr %3, align 8, !tbaa !19
  %35 = addrspacecast ptr %3 to ptr addrspace(4)
  %36 = load i128, ptr addrspace(4) %35, align 8, !tbaa !29
  switch i128 %36, label %38 [
    i128 9218868437227405312, label %37
    i128 18442240474082181120, label %37
  ]

37:                                               ; preds = %34, %34
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  br label %41

38:                                               ; preds = %34
  %39 = and i128 %36, 9221120237041090560
  %40 = icmp eq i128 %39, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3)
  br i1 %40, label %42, label %41

41:                                               ; preds = %38, %37
  br label %42

42:                                               ; preds = %41, %38, %2
  %43 = phi <2 x i32> [ %31, %2 ], [ <i32 0, i32 2146959360>, %41 ], [ %31, %38 ]
  %44 = phi <2 x i32> [ %25, %2 ], [ <i32 0, i32 2146959360>, %41 ], [ %25, %38 ]
  store <2 x i32> %43, ptr %1, align 8, !tbaa !19
  %45 = bitcast <2 x i32> %44 to double
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %5) #39
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %4) #39
  ret double %45
}

; Function Attrs: convergent mustprogress norecurse nounwind willreturn memory(argmem: write)
define protected spir_func float @__ocml_sincospi_f32(float noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #27 {
  %3 = alloca float, align 8
  %4 = alloca %struct.redret.0, align 4
  %5 = alloca %struct.scret.1, align 4
  %6 = tail call float @llvm.fabs.f32(float %0)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4) #39
  call spir_func void @__ocmlpriv_trigpired_f32(ptr dead_on_unwind nonnull writable sret(%struct.redret.0) align 4 %4, float noundef %6) #43
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %5) #39
  %7 = load float, ptr %4, align 4, !tbaa !38
  call spir_func void @__ocmlpriv_sincospired_f32(ptr dead_on_unwind nonnull writable sret(%struct.scret.1) align 4 %5, float noundef %7) #43
  %8 = getelementptr inbounds %struct.redret.0, ptr %4, i64 0, i32 1
  %9 = load i32, ptr %8, align 4, !tbaa !40
  %10 = icmp sgt i32 %9, 1
  %11 = select i1 %10, i32 -2147483648, i32 0
  %12 = and i32 %9, 1
  %13 = icmp eq i32 %12, 0
  %14 = getelementptr inbounds %struct.scret.1, ptr %5, i64 0, i32 1
  %15 = load float, ptr %14, align 4
  %16 = load float, ptr %5, align 4
  %17 = select i1 %13, float %16, float %15
  %18 = bitcast float %17 to i32
  %19 = bitcast float %6 to i32
  %20 = bitcast float %0 to i32
  %21 = xor i32 %19, %20
  %22 = xor i32 %21, %18
  %23 = xor i32 %22, %11
  %24 = bitcast i32 %23 to float
  %25 = fneg float %16
  %26 = select i1 %13, float %15, float %25
  %27 = bitcast float %26 to i32
  %28 = xor i32 %11, %27
  %29 = bitcast i32 %28 to float
  %30 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %32, label %47

32:                                               ; preds = %2
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3)
  store float %6, ptr %3, align 8, !tbaa !16
  %33 = addrspacecast ptr %3 to ptr addrspace(4)
  %34 = load i64, ptr addrspace(4) %33, align 8, !tbaa !12
  %35 = and i64 %34, 2147483647
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %37, label %38

37:                                               ; preds = %32
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  br label %47

38:                                               ; preds = %32
  %39 = and i64 %34, 2139095040
  %40 = icmp ne i64 %39, 0
  %41 = and i64 %34, 8388607
  %42 = icmp eq i64 %41, 0
  %43 = or i1 %40, %42
  %44 = freeze i1 %43
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3)
  %45 = select i1 %44, float 0x7FF8000000000000, float %29
  %46 = select i1 %44, float 0x7FF8000000000000, float %24
  br label %47

47:                                               ; preds = %38, %37, %2
  %48 = phi float [ %29, %2 ], [ %29, %37 ], [ %45, %38 ]
  %49 = phi float [ %24, %2 ], [ %24, %37 ], [ %46, %38 ]
  store float %48, ptr %1, align 4, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %5) #39
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4) #39
  ret float %49
}

; Function Attrs: convergent mustprogress norecurse nounwind willreturn memory(argmem: write)
define protected spir_func <2 x half> @__ocml_sincospi_2f16(<2 x half> noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #37 {
  %3 = alloca %struct.redret.2, align 2
  %4 = alloca %struct.scret.3, align 2
  %5 = alloca %struct.redret.2, align 2
  %6 = alloca %struct.scret.3, align 2
  %7 = extractelement <2 x half> %0, i64 0
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %5) #39
  %8 = tail call half @llvm.fabs.f16(half %7)
  call spir_func void @__ocmlpriv_trigpired_f16(ptr dead_on_unwind nonnull writable sret(%struct.redret.2) align 2 %5, half noundef %8) #43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %6) #39
  %9 = load half, ptr %5, align 2, !tbaa !45
  call spir_func void @__ocmlpriv_sincospired_f16(ptr dead_on_unwind nonnull writable sret(%struct.scret.3) align 2 %6, half noundef %9) #43
  %10 = getelementptr inbounds %struct.redret.2, ptr %5, i64 0, i32 1
  %11 = load i16, ptr %10, align 2, !tbaa !51
  %12 = icmp sgt i16 %11, 1
  %13 = select i1 %12, i16 -32768, i16 0
  %14 = and i16 %11, 1
  %15 = icmp eq i16 %14, 0
  %16 = getelementptr inbounds %struct.scret.3, ptr %6, i64 0, i32 1
  %17 = load half, ptr %16, align 2
  %18 = load half, ptr %6, align 2
  %19 = select i1 %15, half %18, half %17
  %20 = bitcast half %19 to i16
  %21 = bitcast half %7 to i16
  %22 = and i16 %21, -32768
  %23 = xor i16 %22, %20
  %24 = xor i16 %23, %13
  %25 = fneg half %18
  %26 = select i1 %15, half %17, half %25
  %27 = bitcast half %26 to i16
  %28 = xor i16 %13, %27
  %29 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %31, label %37

31:                                               ; preds = %2
  %32 = fptoui half %7 to i16
  %33 = call spir_func i32 @__builtin_generic_class_f16.110(i16 noundef zeroext %32) #39
  %34 = icmp eq i32 %33, 0
  %35 = select i1 %34, i16 %28, i16 32256
  %36 = select i1 %34, i16 %24, i16 32256
  br label %37

37:                                               ; preds = %2, %31
  %38 = phi i16 [ %28, %2 ], [ %35, %31 ]
  %39 = phi i16 [ %24, %2 ], [ %36, %31 ]
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %6) #39
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %5) #39
  %40 = extractelement <2 x half> %0, i64 1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %41 = call half @llvm.fabs.f16(half %40)
  call spir_func void @__ocmlpriv_trigpired_f16(ptr dead_on_unwind nonnull writable sret(%struct.redret.2) align 2 %3, half noundef %41) #43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %42 = load half, ptr %3, align 2, !tbaa !45
  call spir_func void @__ocmlpriv_sincospired_f16(ptr dead_on_unwind nonnull writable sret(%struct.scret.3) align 2 %4, half noundef %42) #43
  %43 = getelementptr inbounds %struct.redret.2, ptr %3, i64 0, i32 1
  %44 = load i16, ptr %43, align 2, !tbaa !51
  %45 = icmp sgt i16 %44, 1
  %46 = select i1 %45, i16 -32768, i16 0
  %47 = and i16 %44, 1
  %48 = icmp eq i16 %47, 0
  %49 = getelementptr inbounds %struct.scret.3, ptr %4, i64 0, i32 1
  %50 = load half, ptr %49, align 2
  %51 = load half, ptr %4, align 2
  %52 = select i1 %48, half %51, half %50
  %53 = bitcast half %52 to i16
  %54 = bitcast half %40 to i16
  %55 = and i16 %54, -32768
  %56 = xor i16 %55, %53
  %57 = xor i16 %56, %46
  %58 = fneg half %51
  %59 = select i1 %48, half %50, half %58
  %60 = bitcast half %59 to i16
  %61 = xor i16 %46, %60
  br i1 %30, label %62, label %68

62:                                               ; preds = %37
  %63 = fptoui half %40 to i16
  %64 = call spir_func i32 @__builtin_generic_class_f16.110(i16 noundef zeroext %63) #39
  %65 = icmp eq i32 %64, 0
  %66 = select i1 %65, i16 %61, i16 32256
  %67 = select i1 %65, i16 %57, i16 32256
  br label %68

68:                                               ; preds = %37, %62
  %69 = phi i16 [ %61, %37 ], [ %66, %62 ]
  %70 = phi i16 [ %57, %37 ], [ %67, %62 ]
  %71 = insertelement <2 x i16> poison, i16 %39, i64 0
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  %72 = insertelement <2 x i16> %71, i16 %70, i64 1
  %73 = bitcast <2 x i16> %72 to <2 x half>
  %74 = insertelement <2 x i16> poison, i16 %38, i64 0
  %75 = insertelement <2 x i16> %74, i16 %69, i64 1
  store <2 x i16> %75, ptr %1, align 4, !tbaa !14
  ret <2 x half> %73
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16.110(i16 noundef zeroext %0) unnamed_addr #25 {
  switch i16 %0, label %2 [
    i16 31744, label %6
    i16 -1024, label %6
  ]

2:                                                ; preds = %1
  %3 = and i16 %0, 32256
  %4 = icmp ne i16 %3, 0
  %5 = sext i1 %4 to i32
  br label %6

6:                                                ; preds = %2, %1, %1
  %7 = phi i32 [ -1, %1 ], [ -1, %1 ], [ %5, %2 ]
  ret i32 %7
}

; Function Attrs: convergent mustprogress norecurse nounwind willreturn memory(argmem: write)
define protected spir_func half @__ocml_sincospi_f16(half noundef %0, ptr nocapture noundef writeonly %1) local_unnamed_addr #37 {
  %3 = alloca %struct.redret.2, align 2
  %4 = alloca %struct.scret.3, align 2
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %5 = tail call half @llvm.fabs.f16(half %0)
  call spir_func void @__ocmlpriv_trigpired_f16(ptr dead_on_unwind nonnull writable sret(%struct.redret.2) align 2 %3, half noundef %5) #43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %4) #39
  %6 = load half, ptr %3, align 2, !tbaa !45
  call spir_func void @__ocmlpriv_sincospired_f16(ptr dead_on_unwind nonnull writable sret(%struct.scret.3) align 2 %4, half noundef %6) #43
  %7 = getelementptr inbounds %struct.redret.2, ptr %3, i64 0, i32 1
  %8 = load i16, ptr %7, align 2, !tbaa !51
  %9 = icmp sgt i16 %8, 1
  %10 = select i1 %9, i16 -32768, i16 0
  %11 = and i16 %8, 1
  %12 = icmp eq i16 %11, 0
  %13 = getelementptr inbounds %struct.scret.3, ptr %4, i64 0, i32 1
  %14 = load half, ptr %13, align 2
  %15 = load half, ptr %4, align 2
  %16 = select i1 %12, half %15, half %14
  %17 = bitcast half %16 to i16
  %18 = bitcast half %0 to i16
  %19 = and i16 %18, -32768
  %20 = xor i16 %19, %17
  %21 = xor i16 %20, %10
  %22 = fneg half %15
  %23 = select i1 %12, half %14, half %22
  %24 = bitcast half %23 to i16
  %25 = xor i16 %10, %24
  %26 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %28, label %34

28:                                               ; preds = %2
  %29 = fptoui half %0 to i16
  %30 = call spir_func i32 @__builtin_generic_class_f16.110(i16 noundef zeroext %29) #39
  %31 = icmp eq i32 %30, 0
  %32 = select i1 %31, i16 %25, i16 32256
  %33 = select i1 %31, i16 %21, i16 32256
  br label %34

34:                                               ; preds = %28, %2
  %35 = phi i16 [ %25, %2 ], [ %32, %28 ]
  %36 = phi i16 [ %21, %2 ], [ %33, %28 ]
  store i16 %35, ptr %1, align 2, !tbaa !57
  %37 = bitcast i16 %36 to half
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %4) #39
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  ret half %37
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_sincosred2_f32(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.scret.1) align 4 %0, float noundef %1, float noundef %2) local_unnamed_addr #30 {
  %4 = fmul float %1, %1
  %5 = fmul float %4, 5.000000e-01
  %6 = fsub float 1.000000e+00, %5
  %7 = fsub float 1.000000e+00, %6
  %8 = fsub float %7, %5
  %9 = fmul float %4, %4
  %10 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %4, float noundef 0xBE923C5E00000000, float noundef 0x3EFA00E980000000) #38
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %4, float noundef %10, float noundef 0xBF56C16B20000000) #38
  %12 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %4, float noundef %11, float noundef 0x3FA5555560000000) #38
  %13 = fneg float %2
  %14 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %1, float noundef %13, float noundef %8) #38
  %15 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %9, float noundef %12, float noundef %14) #38
  %16 = fadd float %6, %15
  %17 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %4, float noundef 0x3EC6DBC3A0000000, float noundef 0xBF2A0139E0000000) #38
  %18 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %4, float noundef %17, float noundef 0x3F811110E0000000) #38
  %19 = fneg float %4
  %20 = fmul float %19, %1
  %21 = fmul float %2, 5.000000e-01
  %22 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %20, float noundef %18, float noundef %21) #38
  %23 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %4, float noundef %22, float noundef %13) #38
  %24 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %20, float noundef 0xBFC5555560000000, float noundef %23) #38
  %25 = fsub float %1, %24
  %26 = getelementptr inbounds %struct.scret.1, ptr %0, i64 0, i32 1
  store float %16, ptr %26, align 4, !tbaa !41
  store float %25, ptr %0, align 4, !tbaa !43
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define protected spir_func void @__ocmlpriv_sincosred_f64(ptr dead_on_unwind noalias nocapture writable writeonly sret(%struct.scret) align 8 %0, double noundef %1) local_unnamed_addr #29 {
  %3 = fmul double %1, %1
  %4 = fmul double %3, 5.000000e-01
  %5 = fsub double 1.000000e+00, %4
  %6 = fsub double 1.000000e+00, %5
  %7 = fsub double %6, %4
  %8 = fmul double %3, %3
  %9 = tail call double @llvm.fma.f64(double %3, double 0xBDA907DB46CC5E42, double 0x3E21EEB69037AB78)
  %10 = tail call double @llvm.fma.f64(double %3, double %9, double 0xBE927E4FA17F65F6)
  %11 = tail call double @llvm.fma.f64(double %3, double %10, double 0x3EFA01A019F4EC90)
  %12 = tail call double @llvm.fma.f64(double %3, double %11, double 0xBF56C16C16C16967)
  %13 = tail call double @llvm.fma.f64(double %3, double %12, double 0x3FA5555555555555)
  %14 = tail call double @llvm.fma.f64(double %8, double %13, double %7)
  %15 = fadd double %5, %14
  %16 = fmul double %3, %1
  %17 = tail call double @llvm.fma.f64(double %3, double 0x3DE5E0B2F9A43BB8, double 0xBE5AE600B42FDFA7)
  %18 = tail call double @llvm.fma.f64(double %3, double %17, double 0x3EC71DE3796CDE01)
  %19 = tail call double @llvm.fma.f64(double %3, double %18, double 0xBF2A01A019E83E5C)
  %20 = tail call double @llvm.fma.f64(double %3, double %19, double 0x3F81111111110BB3)
  %21 = tail call double @llvm.fma.f64(double %3, double %20, double 0xBFC5555555555555)
  %22 = tail call double @llvm.fma.f64(double %16, double %21, double %1)
  %23 = getelementptr inbounds %struct.scret, ptr %0, i64 0, i32 1
  store double %15, ptr %23, align 8, !tbaa !35
  store double %22, ptr %0, align 8, !tbaa !37
  ret void
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_sinh_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fadd double %2, 0xBFE62E42FEFA39EF
  %4 = fsub double %3, %2
  %5 = fsub double %4, %3
  %6 = fadd double %2, %5
  %7 = fadd double %4, 0x3FE62E42FEFA39EF
  %8 = fsub double %6, %7
  %9 = fadd double %8, 0xBC7ABC9E3B39803F
  %10 = fadd double %3, %9
  %11 = fsub double %3, %10
  %12 = fadd double %9, %11
  %13 = insertelement <2 x double> poison, double %12, i64 0
  %14 = insertelement <2 x double> %13, double %10, i64 1
  %15 = tail call spir_func <2 x double> @__ocmlpriv_epexpep_f64(<2 x double> noundef %14) #38
  %16 = extractelement <2 x double> %15, i64 1
  %17 = fptrunc double %16 to float
  %18 = tail call spir_func float @_Z12native_recipf(float noundef %17) #38
  %19 = fpext float %18 to double
  %20 = fneg double %16
  %21 = tail call double @llvm.fma.f64(double %20, double %19, double 1.000000e+00)
  %22 = tail call double @llvm.fma.f64(double %21, double %19, double %19)
  %23 = tail call double @llvm.fma.f64(double %20, double %22, double 1.000000e+00)
  %24 = tail call double @llvm.fma.f64(double %23, double %22, double %22)
  %25 = fmul double %16, %24
  %26 = fneg double %25
  %27 = tail call double @llvm.fma.f64(double %24, double %16, double %26)
  %28 = extractelement <2 x double> %15, i64 0
  %29 = tail call double @llvm.fma.f64(double %24, double %28, double %27)
  %30 = fadd double %25, %29
  %31 = fsub double %30, %25
  %32 = fsub double 1.000000e+00, %30
  %33 = fsub double 1.000000e+00, %32
  %34 = fsub double %33, %30
  %35 = fsub double %31, %29
  %36 = fadd double %35, %34
  %37 = fadd double %32, %36
  %38 = fsub double %32, %37
  %39 = fadd double %36, %38
  %40 = fmul double %24, %37
  %41 = fmul double %16, %40
  %42 = fneg double %41
  %43 = tail call double @llvm.fma.f64(double %40, double %16, double %42)
  %44 = tail call double @llvm.fma.f64(double %40, double %28, double %43)
  %45 = fadd double %41, %44
  %46 = fsub double %45, %41
  %47 = fsub double %37, %45
  %48 = fsub double %37, %47
  %49 = fsub double %48, %45
  %50 = fadd double %39, %49
  %51 = fsub double %46, %44
  %52 = fadd double %51, %50
  %53 = fadd double %47, %52
  %54 = fmul double %24, %53
  %55 = fadd double %24, %40
  %56 = fsub double %55, %24
  %57 = fsub double %40, %56
  %58 = fadd double %57, %54
  %59 = fadd double %55, %58
  %60 = fsub double %59, %55
  %61 = fsub double %58, %60
  %62 = tail call spir_func double @_Z5ldexpdi(double noundef %59, i32 noundef -2) #38
  %63 = tail call spir_func double @_Z5ldexpdi(double noundef %61, i32 noundef -2) #38
  %64 = fsub double %16, %62
  %65 = fsub double %16, %64
  %66 = fsub double %65, %62
  %67 = fadd double %28, %66
  %68 = fsub double %67, %63
  %69 = fadd double %64, %68
  %70 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %71 = icmp eq i8 %70, 0
  %72 = fcmp oge double %2, 0x408633CE8FB9F87E
  %73 = and i1 %72, %71
  %74 = select i1 %73, double 0x7FF0000000000000, double %69
  %75 = fcmp olt double %2, 0x3E40000000000000
  %76 = select i1 %75, double %2, double %74
  %77 = tail call double @llvm.copysign.f64(double %76, double %0)
  ret double %77
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_sinh_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = fadd float %2, 0xBFE62E4300000000
  %4 = fsub float %3, %2
  %5 = fsub float %4, %3
  %6 = fadd float %2, %5
  %7 = fadd float %4, 0x3FE62E4300000000
  %8 = fsub float %6, %7
  %9 = fadd float %8, 0x3E205C6100000000
  %10 = fadd float %3, %9
  %11 = fsub float %3, %10
  %12 = fadd float %9, %11
  %13 = insertelement <2 x float> poison, float %12, i64 0
  %14 = insertelement <2 x float> %13, float %10, i64 1
  %15 = tail call spir_func <2 x float> @__ocmlpriv_epexpep_f32(<2 x float> noundef %14) #38
  %16 = extractelement <2 x float> %15, i64 1
  %17 = tail call spir_func float @_Z12native_recipf(float noundef %16) #38
  %18 = fmul float %16, %17
  %19 = load i32, ptr addrspace(2) @__oclc_ISA_version, align 4
  %20 = freeze i32 %19
  %21 = icmp sgt i32 %20, 8999
  br i1 %21, label %22, label %27

22:                                               ; preds = %1
  %23 = fneg float %18
  %24 = tail call float @llvm.fma.f32(float %17, float %16, float %23)
  %25 = insertelement <2 x float> poison, float %24, i64 0
  %26 = insertelement <2 x float> %25, float %18, i64 1
  br label %49

27:                                               ; preds = %1
  switch i32 %20, label %28 [
    i32 8001, label %42
    i32 7001, label %42
  ]

28:                                               ; preds = %27
  %29 = bitcast float %17 to i32
  %30 = and i32 %29, -4096
  %31 = bitcast i32 %30 to float
  %32 = fsub float %17, %31
  %33 = bitcast float %16 to i32
  %34 = and i32 %33, -4096
  %35 = bitcast i32 %34 to float
  %36 = fsub float %16, %35
  %37 = fneg float %18
  %38 = tail call float @llvm.fmuladd.f32(float %31, float %35, float %37)
  %39 = tail call float @llvm.fmuladd.f32(float %31, float %36, float %38)
  %40 = tail call float @llvm.fmuladd.f32(float %32, float %35, float %39)
  %41 = tail call float @llvm.fmuladd.f32(float %32, float %36, float %40)
  br label %45

42:                                               ; preds = %27, %27
  %43 = fneg float %18
  %44 = tail call float @llvm.fma.f32(float %17, float %16, float %43)
  br label %45

45:                                               ; preds = %42, %28
  %46 = phi float [ %44, %42 ], [ %41, %28 ]
  %47 = insertelement <2 x float> poison, float %46, i64 0
  %48 = insertelement <2 x float> %47, float %18, i64 1
  switch i32 %20, label %55 [
    i32 8001, label %49
    i32 7001, label %49
  ]

49:                                               ; preds = %45, %45, %22
  %50 = phi <2 x float> [ %48, %45 ], [ %48, %45 ], [ %26, %22 ]
  %51 = phi float [ %46, %45 ], [ %46, %45 ], [ %24, %22 ]
  %52 = extractelement <2 x float> %15, i64 0
  %53 = tail call float @llvm.fma.f32(float %17, float %52, float %51)
  %54 = insertelement <2 x float> %50, float %53, i64 0
  br label %59

55:                                               ; preds = %45
  %56 = extractelement <2 x float> %15, i64 0
  %57 = tail call float @llvm.fmuladd.f32(float %17, float %56, float %46)
  %58 = insertelement <2 x float> %48, float %57, i64 0
  br label %59

59:                                               ; preds = %55, %49
  %60 = phi <2 x float> [ %54, %49 ], [ %58, %55 ]
  %61 = extractelement <2 x float> %60, i64 1
  %62 = extractelement <2 x float> %60, i64 0
  %63 = fadd float %61, %62
  %64 = fsub float %63, %61
  %65 = fsub float 1.000000e+00, %63
  %66 = fsub float 1.000000e+00, %65
  %67 = fsub float %66, %63
  %68 = fsub float %64, %62
  %69 = fadd float %68, %67
  %70 = fadd float %65, %69
  %71 = fmul float %17, %70
  %72 = fmul float %16, %71
  br i1 %21, label %73, label %78

73:                                               ; preds = %59
  %74 = fneg float %72
  %75 = tail call float @llvm.fma.f32(float %71, float %16, float %74)
  %76 = insertelement <2 x float> poison, float %75, i64 0
  %77 = insertelement <2 x float> %76, float %72, i64 1
  br label %100

78:                                               ; preds = %59
  switch i32 %20, label %79 [
    i32 8001, label %93
    i32 7001, label %93
  ]

79:                                               ; preds = %78
  %80 = bitcast float %71 to i32
  %81 = and i32 %80, -4096
  %82 = bitcast i32 %81 to float
  %83 = fsub float %71, %82
  %84 = bitcast float %16 to i32
  %85 = and i32 %84, -4096
  %86 = bitcast i32 %85 to float
  %87 = fsub float %16, %86
  %88 = fneg float %72
  %89 = tail call float @llvm.fmuladd.f32(float %82, float %86, float %88)
  %90 = tail call float @llvm.fmuladd.f32(float %82, float %87, float %89)
  %91 = tail call float @llvm.fmuladd.f32(float %83, float %86, float %90)
  %92 = tail call float @llvm.fmuladd.f32(float %83, float %87, float %91)
  br label %96

93:                                               ; preds = %78, %78
  %94 = fneg float %72
  %95 = tail call float @llvm.fma.f32(float %71, float %16, float %94)
  br label %96

96:                                               ; preds = %93, %79
  %97 = phi float [ %95, %93 ], [ %92, %79 ]
  %98 = insertelement <2 x float> poison, float %97, i64 0
  %99 = insertelement <2 x float> %98, float %72, i64 1
  switch i32 %20, label %106 [
    i32 8001, label %100
    i32 7001, label %100
  ]

100:                                              ; preds = %96, %96, %73
  %101 = phi <2 x float> [ %99, %96 ], [ %99, %96 ], [ %77, %73 ]
  %102 = phi float [ %97, %96 ], [ %97, %96 ], [ %75, %73 ]
  %103 = extractelement <2 x float> %15, i64 0
  %104 = tail call float @llvm.fma.f32(float %71, float %103, float %102)
  %105 = insertelement <2 x float> %101, float %104, i64 0
  br label %110

106:                                              ; preds = %96
  %107 = extractelement <2 x float> %15, i64 0
  %108 = tail call float @llvm.fmuladd.f32(float %71, float %107, float %97)
  %109 = insertelement <2 x float> %99, float %108, i64 0
  br label %110

110:                                              ; preds = %100, %106
  %111 = phi float [ %103, %100 ], [ %107, %106 ]
  %112 = phi <2 x float> [ %105, %100 ], [ %109, %106 ]
  %113 = fsub float %65, %70
  %114 = fadd float %69, %113
  %115 = extractelement <2 x float> %112, i64 1
  %116 = extractelement <2 x float> %112, i64 0
  %117 = fadd float %115, %116
  %118 = fsub float %117, %115
  %119 = fsub float %70, %117
  %120 = fsub float %70, %119
  %121 = fsub float %120, %117
  %122 = fadd float %114, %121
  %123 = fsub float %118, %116
  %124 = fadd float %123, %122
  %125 = fadd float %119, %124
  %126 = fmul float %17, %125
  %127 = fadd float %17, %71
  %128 = fsub float %127, %17
  %129 = fsub float %71, %128
  %130 = fadd float %129, %126
  %131 = fadd float %127, %130
  %132 = fsub float %131, %127
  %133 = fsub float %130, %132
  %134 = tail call spir_func float @_Z5ldexpfi(float noundef %131, i32 noundef -2) #38
  %135 = tail call spir_func float @_Z5ldexpfi(float noundef %133, i32 noundef -2) #38
  %136 = fsub float %16, %134
  %137 = fsub float %16, %136
  %138 = fsub float %137, %134
  %139 = fadd float %111, %138
  %140 = fsub float %139, %135
  %141 = fadd float %136, %140
  %142 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %143 = icmp eq i8 %142, 0
  %144 = fcmp ogt float %2, 0x40565A9F80000000
  %145 = and i1 %144, %143
  %146 = select i1 %145, float 0x7FF0000000000000, float %141
  %147 = fcmp olt float %2, 0x3F30000000000000
  %148 = select i1 %147, float %2, float %146
  %149 = tail call float @llvm.copysign.f32(float %148, float %0)
  ret float %149
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_sinh_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = fmul float %3, 0x3FF7154760000000
  %5 = tail call float @llvm.exp2.f32(float %4)
  %6 = fneg float %4
  %7 = tail call float @llvm.exp2.f32(float %6)
  %8 = fsub float %5, %7
  %9 = fmul float %8, 5.000000e-01
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> poison, half %10, i64 0
  %12 = extractelement <2 x half> %0, i64 1
  %13 = fpext half %12 to float
  %14 = fmul float %13, 0x3FF7154760000000
  %15 = tail call float @llvm.exp2.f32(float %14)
  %16 = fneg float %14
  %17 = tail call float @llvm.exp2.f32(float %16)
  %18 = fsub float %15, %17
  %19 = fmul float %18, 5.000000e-01
  %20 = fptrunc float %19 to half
  %21 = insertelement <2 x half> %11, half %20, i64 1
  ret <2 x half> %21
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocml_sinh_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = fpext half %0 to float
  %3 = fmul float %2, 0x3FF7154760000000
  %4 = tail call float @llvm.exp2.f32(float %3)
  %5 = fneg float %3
  %6 = tail call float @llvm.exp2.f32(float %5)
  %7 = fsub float %4, %6
  %8 = fmul float %7, 5.000000e-01
  %9 = fptrunc float %8 to half
  ret half %9
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_sinpi_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_sinpi_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_sinpi_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_sinpi_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = alloca %struct.redret.2, align 2
  %3 = alloca %struct.scret.3, align 2
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %4 = tail call half @llvm.fabs.f16(half %0)
  call spir_func void @__ocmlpriv_trigpired_f16(ptr dead_on_unwind nonnull writable sret(%struct.redret.2) align 2 %2, half noundef %4) #43
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %3) #39
  %5 = load half, ptr %2, align 2, !tbaa !45
  call spir_func void @__ocmlpriv_sincospired_f16(ptr dead_on_unwind nonnull writable sret(%struct.scret.3) align 2 %3, half noundef %5) #43
  %6 = getelementptr inbounds %struct.redret.2, ptr %2, i64 0, i32 1
  %7 = load i16, ptr %6, align 2, !tbaa !51
  %8 = and i16 %7, 1
  %9 = icmp eq i16 %8, 0
  %10 = load half, ptr %3, align 2
  %11 = getelementptr inbounds %struct.scret.3, ptr %3, i64 0, i32 1
  %12 = load half, ptr %11, align 2
  %13 = select i1 %9, half %10, half %12
  %14 = bitcast half %13 to i16
  %15 = icmp sgt i16 %7, 1
  %16 = select i1 %15, i16 -32768, i16 0
  %17 = bitcast half %0 to i16
  %18 = and i16 %17, -32768
  %19 = xor i16 %16, %18
  %20 = xor i16 %19, %14
  %21 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %28

23:                                               ; preds = %1
  %24 = fptoui half %0 to i16
  %25 = call spir_func i32 @__builtin_generic_class_f16.127(i16 noundef zeroext %24) #39
  %26 = icmp eq i32 %25, 0
  %27 = select i1 %26, i16 %20, i16 32256
  br label %28

28:                                               ; preds = %23, %1
  %29 = phi i16 [ %20, %1 ], [ %27, %23 ]
  %30 = bitcast i16 %29 to half
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %3) #39
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret half %30
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16.127(i16 noundef zeroext %0) unnamed_addr #25 {
  switch i16 %0, label %2 [
    i16 31744, label %6
    i16 -1024, label %6
  ]

2:                                                ; preds = %1
  %3 = and i16 %0, 32256
  %4 = icmp ne i16 %3, 0
  %5 = sext i1 %4 to i32
  br label %6

6:                                                ; preds = %2, %1, %1
  %7 = phi i32 [ -1, %1 ], [ -1, %1 ], [ %5, %2 ]
  ret i32 %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_sqrt_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = fcmp olt double %0, 0x1000000000000000
  %3 = select i1 %2, double 0x4FF0000000000000, double 1.000000e+00
  %4 = fmul double %3, %0
  %5 = fptrunc double %4 to float
  %6 = tail call spir_func float @_Z12native_rsqrtf(float noundef %5) #38
  %7 = fpext float %6 to double
  %8 = fmul double %4, %7
  %9 = fmul double %7, 5.000000e-01
  %10 = fneg double %9
  %11 = tail call double @llvm.fma.f64(double %10, double %8, double 5.000000e-01)
  %12 = tail call double @llvm.fma.f64(double %9, double %11, double %9)
  %13 = tail call double @llvm.fma.f64(double %8, double %11, double %8)
  %14 = fneg double %13
  %15 = tail call double @llvm.fma.f64(double %14, double %13, double %4)
  %16 = tail call double @llvm.fma.f64(double %15, double %12, double %13)
  %17 = fneg double %16
  %18 = tail call double @llvm.fma.f64(double %17, double %16, double %4)
  %19 = tail call double @llvm.fma.f64(double %18, double %12, double %16)
  %20 = select i1 %2, double 0x37F0000000000000, double 1.000000e+00
  %21 = fmul double %20, %19
  %22 = tail call i1 @llvm.is.fpclass.f64(double %4, i32 608)
  %23 = select i1 %22, double %4, double %21
  ret double %23
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_sqrt_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = load i8, ptr addrspace(2) @__oclc_correctly_rounded_sqrt32, align 1, !tbaa !25, !range !27, !noundef !28
  %4 = icmp eq i8 %3, 0
  br i1 %4, label %48, label %5

5:                                                ; preds = %1
  %6 = fcmp olt float %0, 0x39F0000000000000
  %7 = select i1 %6, float 0x41F0000000000000, float 1.000000e+00
  %8 = fmul float %7, %0
  %9 = load i8, ptr addrspace(2) @__oclc_daz_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %26

11:                                               ; preds = %5
  %12 = tail call float @llvm.sqrt.f32(float %8), !fpmath !18
  %13 = bitcast float %12 to i32
  %14 = add nsw i32 %13, -1
  %15 = bitcast i32 %14 to float
  %16 = add nsw i32 %13, 1
  %17 = bitcast i32 %16 to float
  %18 = fneg float %15
  %19 = tail call float @llvm.fma.f32(float %18, float %12, float %8)
  %20 = fneg float %17
  %21 = tail call float @llvm.fma.f32(float %20, float %12, float %8)
  %22 = fcmp ole float %19, 0.000000e+00
  %23 = select i1 %22, float %15, float %12
  %24 = fcmp ogt float %21, 0.000000e+00
  %25 = select i1 %24, float %17, float %23
  br label %37

26:                                               ; preds = %5
  %27 = tail call spir_func float @_Z12native_rsqrtf(float noundef %8) #38
  %28 = fmul float %8, %27
  %29 = fmul float %27, 5.000000e-01
  %30 = fneg float %29
  %31 = tail call float @llvm.fma.f32(float %30, float %28, float 5.000000e-01)
  %32 = tail call float @llvm.fma.f32(float %29, float %31, float %29)
  %33 = tail call float @llvm.fma.f32(float %28, float %31, float %28)
  %34 = fneg float %33
  %35 = tail call float @llvm.fma.f32(float %34, float %33, float %8)
  %36 = tail call float @llvm.fma.f32(float %35, float %32, float %33)
  br label %37

37:                                               ; preds = %26, %11
  %38 = phi float [ %36, %26 ], [ %25, %11 ]
  %39 = select i1 %6, float 0x3EF0000000000000, float 1.000000e+00
  %40 = fmul float %39, %38
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %8, ptr %2, align 8, !tbaa !16
  %41 = addrspacecast ptr %2 to ptr addrspace(4)
  %42 = load i64, ptr addrspace(4) %41, align 8, !tbaa !12
  %43 = icmp ne i64 %42, 2139095040
  %44 = and i64 %42, 2147483647
  %45 = icmp ne i64 %44, 0
  %46 = and i1 %43, %45
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %47 = select i1 %46, float %40, float %8
  br label %50

48:                                               ; preds = %1
  %49 = tail call float @llvm.sqrt.f32(float %0), !fpmath !18
  br label %50

50:                                               ; preds = %48, %37
  %51 = phi float [ %47, %37 ], [ %49, %48 ]
  ret float %51
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_sqrt_2f16(<2 x half> noundef %0) local_unnamed_addr #23 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call noundef half @llvm.sqrt.f16(half %2)
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call noundef half @llvm.sqrt.f16(half %5)
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_sqrt_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.sqrt.f16(half %0)
  ret half %2
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_tan_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca %struct.redret, align 8
  %4 = tail call double @llvm.fabs.f64(double %0)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3) #39
  call spir_func void @__ocmlpriv_trigred_f64(ptr dead_on_unwind nonnull writable sret(%struct.redret) align 8 %3, double noundef %4) #43
  %5 = getelementptr inbounds %struct.redret, ptr %3, i64 0, i32 1
  %6 = load double, ptr %5, align 8, !tbaa !31
  %7 = load double, ptr %3, align 8, !tbaa !33
  %8 = getelementptr inbounds %struct.redret, ptr %3, i64 0, i32 2
  %9 = load i32, ptr %8, align 8, !tbaa !34
  %10 = and i32 %9, 1
  %11 = call spir_func double @__ocmlpriv_tanred2_f64(double noundef %6, double noundef %7, i32 noundef %10) #38
  %12 = bitcast double %11 to <2 x i32>
  %13 = bitcast double %0 to <2 x i32>
  %14 = extractelement <2 x i32> %13, i64 1
  %15 = and i32 %14, -2147483648
  %16 = extractelement <2 x i32> %12, i64 1
  %17 = xor i32 %16, %15
  %18 = insertelement <2 x i32> %12, i32 %17, i64 1
  %19 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %35

21:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %4, ptr %2, align 8, !tbaa !19
  %22 = addrspacecast ptr %2 to ptr addrspace(4)
  %23 = load i128, ptr addrspace(4) %22, align 8, !tbaa !29
  %24 = and i128 %23, 9223372036854775807
  %25 = icmp eq i128 %24, 0
  br i1 %25, label %26, label %27

26:                                               ; preds = %21
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  br label %35

27:                                               ; preds = %21
  %28 = and i128 %23, 9218868437227405312
  %29 = icmp ne i128 %28, 0
  %30 = and i128 %23, 4503599627370495
  %31 = icmp eq i128 %30, 0
  %32 = or i1 %29, %31
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %33 = freeze i1 %32
  %34 = select i1 %33, <2 x i32> <i32 0, i32 2146959360>, <2 x i32> %18
  br label %35

35:                                               ; preds = %27, %26, %1
  %36 = phi <2 x i32> [ %18, %1 ], [ %18, %26 ], [ %34, %27 ]
  %37 = bitcast <2 x i32> %36 to double
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3) #39
  ret double %37
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_tanred2_f64(double noundef %0, double noundef %1, i32 noundef %2) local_unnamed_addr #21 {
  %4 = fmul double %0, %0
  %5 = fneg double %4
  %6 = tail call double @llvm.fma.f64(double %0, double %0, double %5)
  %7 = fmul double %1, 2.000000e+00
  %8 = tail call double @llvm.fma.f64(double %0, double %7, double %6)
  %9 = fadd double %4, %8
  %10 = tail call double @llvm.fma.f64(double %9, double 0x3EF5E089C751C08C, double 0xBF078809A9A29F71)
  %11 = tail call double @llvm.fma.f64(double %9, double %10, double 0x3F17746F90A8AAE0)
  %12 = tail call double @llvm.fma.f64(double %9, double %11, double 0xBEFBB44DA6FBF144)
  %13 = tail call double @llvm.fma.f64(double %9, double %12, double 0x3F21E634A7943ACF)
  %14 = tail call double @llvm.fma.f64(double %9, double %13, double 0x3F2D250FDEB68FEB)
  %15 = tail call double @llvm.fma.f64(double %9, double %14, double 0x3F437FD9B58C4D95)
  %16 = tail call double @llvm.fma.f64(double %9, double %15, double 0x3F57D5AF15120E2C)
  %17 = tail call double @llvm.fma.f64(double %9, double %16, double 0x3F6D6D93E09491DF)
  %18 = tail call double @llvm.fma.f64(double %9, double %17, double 0x3F8226E12033784D)
  %19 = tail call double @llvm.fma.f64(double %9, double %18, double 0x3F9664F49AC36AE2)
  %20 = tail call double @llvm.fma.f64(double %9, double %19, double 0x3FABA1BA1B451C21)
  %21 = tail call double @llvm.fma.f64(double %9, double %20, double 0x3FC11111111185B7)
  %22 = tail call double @llvm.fma.f64(double %9, double %21, double 0x3FD55555555554EE)
  %23 = fmul double %9, %22
  %24 = fmul double %23, %0
  %25 = fneg double %24
  %26 = tail call double @llvm.fma.f64(double %0, double %23, double %25)
  %27 = fadd double %24, %0
  %28 = fsub double %27, %0
  %29 = fsub double %24, %28
  %30 = fadd double %26, %1
  %31 = fadd double %30, %29
  %32 = fadd double %27, %31
  %33 = fsub double %32, %27
  %34 = fsub double %31, %33
  %35 = fptrunc double %32 to float
  %36 = tail call spir_func float @_Z12native_recipf(float noundef %35) #38
  %37 = fpext float %36 to double
  %38 = fneg double %32
  %39 = tail call double @llvm.fma.f64(double %38, double %37, double 1.000000e+00)
  %40 = tail call double @llvm.fma.f64(double %39, double %37, double %37)
  %41 = tail call double @llvm.fma.f64(double %38, double %40, double 1.000000e+00)
  %42 = tail call double @llvm.fma.f64(double %41, double %40, double %40)
  %43 = fmul double %32, %42
  %44 = fneg double %43
  %45 = tail call double @llvm.fma.f64(double %42, double %32, double %44)
  %46 = tail call double @llvm.fma.f64(double %42, double %34, double %45)
  %47 = fadd double %43, %46
  %48 = fsub double %47, %43
  %49 = fsub double 1.000000e+00, %47
  %50 = fsub double 1.000000e+00, %49
  %51 = fsub double %50, %47
  %52 = fsub double %48, %46
  %53 = fadd double %52, %51
  %54 = fadd double %49, %53
  %55 = fmul double %42, %54
  %56 = fadd double %42, %55
  %57 = icmp eq i32 %2, 0
  %58 = fneg double %56
  %59 = select i1 %57, double %32, double %58
  ret double %59
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_tan_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca %struct.redret.0, align 4
  %4 = tail call float @llvm.fabs.f32(float %0)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #39
  call spir_func void @__ocmlpriv_trigred_f32(ptr dead_on_unwind nonnull writable sret(%struct.redret.0) align 4 %3, float noundef %4) #43
  %5 = load float, ptr %3, align 4, !tbaa !38
  %6 = getelementptr inbounds %struct.redret.0, ptr %3, i64 0, i32 1
  %7 = load i32, ptr %6, align 4, !tbaa !40
  %8 = and i32 %7, 1
  %9 = call spir_func float @__ocmlpriv_tanred_f32(float noundef %5, i32 noundef %8) #38
  %10 = bitcast float %9 to i32
  %11 = bitcast float %0 to i32
  %12 = bitcast float %4 to i32
  %13 = xor i32 %12, %11
  %14 = xor i32 %13, %10
  %15 = bitcast i32 %14 to float
  %16 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %18, label %32

18:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %4, ptr %2, align 8, !tbaa !16
  %19 = addrspacecast ptr %2 to ptr addrspace(4)
  %20 = load i64, ptr addrspace(4) %19, align 8, !tbaa !12
  %21 = and i64 %20, 2147483647
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %23, label %24

23:                                               ; preds = %18
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %32

24:                                               ; preds = %18
  %25 = and i64 %20, 2139095040
  %26 = icmp ne i64 %25, 0
  %27 = and i64 %20, 8388607
  %28 = icmp eq i64 %27, 0
  %29 = or i1 %26, %28
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %30 = freeze i1 %29
  %31 = select i1 %30, float 0x7FF8000000000000, float %15
  br label %32

32:                                               ; preds = %24, %23, %1
  %33 = phi float [ %15, %1 ], [ %15, %23 ], [ %31, %24 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #39
  ret float %33
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_tanred_f32(float noundef %0, i32 noundef %1) local_unnamed_addr #21 {
  %3 = fmul float %0, %0
  %4 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef 0xBF919DBA60000000, float noundef 0x3FD8A8B0E0000000) #38
  %5 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef 0x3F92E29000000000, float noundef 0xBFE07266E0000000) #38
  %6 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %5, float noundef 0x3FF27E84A0000000) #38
  %7 = tail call spir_func float @_Z12native_recipf(float noundef %6) #38
  %8 = fmul float %4, %7
  %9 = fmul float %3, %8
  %10 = tail call float @llvm.fma.f32(float %9, float %0, float %0)
  %11 = fsub float %10, %0
  %12 = fneg float %11
  %13 = tail call float @llvm.fma.f32(float %9, float %0, float %12)
  %14 = tail call spir_func float @_Z12native_recipf(float noundef %10) #38
  %15 = fneg float %14
  %16 = tail call float @llvm.fma.f32(float %10, float %15, float 1.000000e+00)
  %17 = tail call float @llvm.fma.f32(float %13, float %15, float %16)
  %18 = tail call float @llvm.fma.f32(float %17, float %15, float %15)
  %19 = icmp eq i32 %1, 0
  %20 = select i1 %19, float %10, float %18
  ret float %20
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_tan_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_tan_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_tan_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_tan_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = alloca %struct.redret.2, align 2
  %3 = tail call half @llvm.fabs.f16(half %0)
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  call spir_func void @__ocmlpriv_trigred_f16(ptr dead_on_unwind nonnull writable sret(%struct.redret.2) align 2 %2, half noundef %3) #43
  %4 = load half, ptr %2, align 2, !tbaa !45
  %5 = getelementptr inbounds %struct.redret.2, ptr %2, i64 0, i32 1
  %6 = load i16, ptr %5, align 2, !tbaa !51
  %7 = and i16 %6, 1
  %8 = call spir_func half @__ocmlpriv_tanred_f16(half noundef %4, i16 noundef signext %7) #38
  %9 = bitcast half %8 to i16
  %10 = bitcast half %0 to i16
  %11 = and i16 %10, -32768
  %12 = xor i16 %11, %9
  %13 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %15, label %20

15:                                               ; preds = %1
  %16 = fptoui half %3 to i16
  %17 = call spir_func i32 @__builtin_generic_class_f16.136(i16 noundef zeroext %16) #39
  %18 = icmp eq i32 %17, 0
  %19 = select i1 %18, i16 32256, i16 %12
  br label %20

20:                                               ; preds = %15, %1
  %21 = phi i16 [ %12, %1 ], [ %19, %15 ]
  %22 = bitcast i16 %21 to half
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret half %22
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocmlpriv_tanred_f16(half noundef %0, i16 noundef signext %1) local_unnamed_addr #23 {
  %3 = fmul half %0, %0
  %4 = tail call half @llvm.fma.f16(half %3, half 0xH2DE5, half 0xH2F8F)
  %5 = tail call half @llvm.fma.f16(half %3, half %4, half 0xH355C)
  %6 = fmul half %3, %5
  %7 = tail call half @llvm.fma.f16(half %0, half %6, half %0)
  %8 = fdiv half 0xHBC00, %7
  %9 = icmp eq i16 %1, 0
  %10 = select i1 %9, half %7, half %8
  ret half %10
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func i32 @__builtin_generic_class_f16.136(i16 noundef zeroext %0) unnamed_addr #25 {
  %2 = and i16 %0, 32767
  %3 = icmp eq i16 %2, 0
  br i1 %3, label %12, label %4

4:                                                ; preds = %1
  %5 = zext i16 %0 to i32
  %6 = and i32 %5, 31744
  %7 = icmp eq i32 %6, 0
  %8 = and i32 %5, 1023
  %9 = icmp ne i32 %8, 0
  %10 = and i1 %7, %9
  %11 = sext i1 %10 to i32
  br label %12

12:                                               ; preds = %4, %1
  %13 = phi i32 [ -1, %1 ], [ %11, %4 ]
  ret i32 %13
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_tanh_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = insertelement <2 x double> <double 0.000000e+00, double poison>, double %2, i64 1
  %4 = tail call spir_func <2 x double> @__ocmlpriv_epexpep_f64(<2 x double> noundef %3) #38
  %5 = extractelement <2 x double> %4, i64 1
  %6 = fptrunc double %5 to float
  %7 = tail call spir_func float @_Z12native_recipf(float noundef %6) #38
  %8 = fpext float %7 to double
  %9 = fneg double %5
  %10 = tail call double @llvm.fma.f64(double %9, double %8, double 1.000000e+00)
  %11 = tail call double @llvm.fma.f64(double %10, double %8, double %8)
  %12 = tail call double @llvm.fma.f64(double %9, double %11, double 1.000000e+00)
  %13 = tail call double @llvm.fma.f64(double %12, double %11, double %11)
  %14 = fmul double %5, %13
  %15 = fneg double %14
  %16 = tail call double @llvm.fma.f64(double %13, double %5, double %15)
  %17 = extractelement <2 x double> %4, i64 0
  %18 = tail call double @llvm.fma.f64(double %13, double %17, double %16)
  %19 = fadd double %14, %18
  %20 = fsub double %19, %14
  %21 = fsub double 1.000000e+00, %19
  %22 = fsub double 1.000000e+00, %21
  %23 = fsub double %22, %19
  %24 = fsub double %20, %18
  %25 = fadd double %24, %23
  %26 = fadd double %21, %25
  %27 = fsub double %21, %26
  %28 = fadd double %25, %27
  %29 = fmul double %13, %26
  %30 = fmul double %5, %29
  %31 = fneg double %30
  %32 = tail call double @llvm.fma.f64(double %29, double %5, double %31)
  %33 = tail call double @llvm.fma.f64(double %29, double %17, double %32)
  %34 = fadd double %30, %33
  %35 = fsub double %34, %30
  %36 = fsub double %26, %34
  %37 = fsub double %26, %36
  %38 = fsub double %37, %34
  %39 = fadd double %28, %38
  %40 = fsub double %35, %33
  %41 = fadd double %40, %39
  %42 = fadd double %36, %41
  %43 = fmul double %13, %42
  %44 = fadd double %13, %29
  %45 = fsub double %44, %13
  %46 = fsub double %29, %45
  %47 = fadd double %46, %43
  %48 = fadd double %44, %47
  %49 = fsub double %48, %44
  %50 = fsub double %47, %49
  %51 = fsub double %5, %48
  %52 = fsub double %5, %51
  %53 = fsub double %52, %48
  %54 = fadd double %17, %53
  %55 = fsub double %54, %50
  %56 = fadd double %51, %55
  %57 = fsub double %56, %51
  %58 = fsub double %55, %57
  %59 = fadd double %5, %48
  %60 = fsub double %59, %5
  %61 = fsub double %48, %60
  %62 = fadd double %17, %50
  %63 = fadd double %62, %61
  %64 = fadd double %59, %63
  %65 = fsub double %64, %59
  %66 = fsub double %63, %65
  %67 = fptrunc double %64 to float
  %68 = tail call spir_func float @_Z12native_recipf(float noundef %67) #38
  %69 = fpext float %68 to double
  %70 = fneg double %64
  %71 = tail call double @llvm.fma.f64(double %70, double %69, double 1.000000e+00)
  %72 = tail call double @llvm.fma.f64(double %71, double %69, double %69)
  %73 = tail call double @llvm.fma.f64(double %70, double %72, double 1.000000e+00)
  %74 = tail call double @llvm.fma.f64(double %73, double %72, double %72)
  %75 = fmul double %56, %74
  %76 = fmul double %64, %75
  %77 = fneg double %76
  %78 = tail call double @llvm.fma.f64(double %75, double %64, double %77)
  %79 = tail call double @llvm.fma.f64(double %75, double %66, double %78)
  %80 = fadd double %76, %79
  %81 = fsub double %80, %76
  %82 = fsub double %79, %81
  %83 = fsub double %56, %80
  %84 = fsub double %56, %83
  %85 = fsub double %84, %80
  %86 = fsub double %85, %82
  %87 = fadd double %58, %86
  %88 = fadd double %83, %87
  %89 = fmul double %74, %88
  %90 = fadd double %75, %89
  %91 = fcmp ogt double %2, 1.906250e+01
  %92 = select i1 %91, double 1.000000e+00, double %90
  %93 = fcmp olt double %2, 0x3E40000000000000
  %94 = select i1 %93, double %2, double %92
  %95 = tail call double @llvm.copysign.f64(double %94, double %0)
  ret double %95
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_tanh_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = fcmp olt float %2, 6.250000e-01
  br i1 %3, label %4, label %12

4:                                                ; preds = %1
  %5 = fmul float %0, %0
  %6 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef 0xBF7758E7A0000000, float noundef 0x3F95211920000000) #38
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef %6, float noundef 0xBFAB8389C0000000) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef %7, float noundef 0x3FC1107040000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef %8, float noundef 0xBFD5555320000000) #38
  %10 = fmul float %2, %9
  %11 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %5, float noundef %10, float noundef %2) #38
  br label %19

12:                                               ; preds = %1
  %13 = fmul float %2, 2.000000e+00
  %14 = tail call spir_func float @__ocml_exp_f32(float noundef %13) #38
  %15 = fadd float %14, 1.000000e+00
  %16 = tail call spir_func float @_Z12native_recipf(float noundef %15) #38
  %17 = fmul float %16, 2.000000e+00
  %18 = fsub float 1.000000e+00, %17
  br label %19

19:                                               ; preds = %12, %4
  %20 = phi float [ %11, %4 ], [ %18, %12 ]
  %21 = tail call float @llvm.copysign.f32(float %20, float %0)
  ret float %21
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_tanh_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = fmul float %3, 0x3FF7154760000000
  %5 = tail call float @llvm.exp2.f32(float %4)
  %6 = fneg float %4
  %7 = tail call float @llvm.exp2.f32(float %6)
  %8 = tail call half @llvm.copysign.f16(half 0xH3C00, half %2)
  %9 = fsub float %5, %7
  %10 = fadd float %5, %7
  %11 = tail call spir_func float @_Z12native_recipf(float noundef %10) #38
  %12 = fmul float %9, %11
  %13 = fptrunc float %12 to half
  %14 = tail call half @llvm.fabs.f16(half %2)
  %15 = fcmp ogt half %14, 0xH4480
  %16 = select i1 %15, half %8, half %13
  %17 = insertelement <2 x half> poison, half %16, i64 0
  %18 = extractelement <2 x half> %0, i64 1
  %19 = fpext half %18 to float
  %20 = fmul float %19, 0x3FF7154760000000
  %21 = tail call float @llvm.exp2.f32(float %20)
  %22 = fneg float %20
  %23 = tail call float @llvm.exp2.f32(float %22)
  %24 = tail call half @llvm.copysign.f16(half 0xH3C00, half %18)
  %25 = fsub float %21, %23
  %26 = fadd float %21, %23
  %27 = tail call spir_func float @_Z12native_recipf(float noundef %26) #38
  %28 = fmul float %25, %27
  %29 = fptrunc float %28 to half
  %30 = tail call half @llvm.fabs.f16(half %18)
  %31 = fcmp ogt half %30, 0xH4480
  %32 = select i1 %31, half %24, half %29
  %33 = insertelement <2 x half> %17, half %32, i64 1
  ret <2 x half> %33
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_tanh_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = fmul float %2, 0x3FF7154760000000
  %4 = tail call float @llvm.exp2.f32(float %3)
  %5 = fneg float %3
  %6 = tail call float @llvm.exp2.f32(float %5)
  %7 = tail call half @llvm.copysign.f16(half 0xH3C00, half %0)
  %8 = fsub float %4, %6
  %9 = fadd float %4, %6
  %10 = tail call spir_func float @_Z12native_recipf(float noundef %9) #38
  %11 = fmul float %8, %10
  %12 = fptrunc float %11 to half
  %13 = tail call half @llvm.fabs.f16(half %0)
  %14 = fcmp ogt half %13, 0xH4480
  %15 = select i1 %14, half %7, half %12
  ret half %15
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_tanpi_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = alloca %struct.redret.8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %3) #39
  %4 = tail call double @llvm.fabs.f64(double %0)
  call spir_func void @__ocmlpriv_trigpired_f64(ptr dead_on_unwind nonnull writable sret(%struct.redret.8) align 8 %3, double noundef %4) #43
  %5 = load double, ptr %3, align 8, !tbaa !53
  %6 = getelementptr inbounds %struct.redret.8, ptr %3, i64 0, i32 1
  %7 = load i32, ptr %6, align 8, !tbaa !55
  %8 = and i32 %7, 1
  %9 = call spir_func double @__ocmlpriv_tanpired_f64(double noundef %5, i32 noundef %8) #38
  %10 = bitcast double %9 to <2 x i32>
  %11 = add i32 %7, -1
  %12 = icmp ult i32 %11, 2
  %13 = fcmp oeq double %5, 0.000000e+00
  %14 = and i1 %13, %12
  %15 = select i1 %14, i32 -2147483648, i32 0
  %16 = extractelement <2 x i32> %10, i64 1
  %17 = bitcast double %0 to <2 x i32>
  %18 = extractelement <2 x i32> %17, i64 1
  %19 = and i32 %18, -2147483648
  %20 = xor i32 %16, %19
  %21 = xor i32 %20, %15
  %22 = insertelement <2 x i32> %10, i32 %21, i64 1
  %23 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %24 = icmp eq i8 %23, 0
  br i1 %24, label %25, label %33

25:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %0, ptr %2, align 8, !tbaa !19
  %26 = addrspacecast ptr %2 to ptr addrspace(4)
  %27 = load i128, ptr addrspace(4) %26, align 8, !tbaa !29
  switch i128 %27, label %29 [
    i128 9218868437227405312, label %28
    i128 18442240474082181120, label %28
  ]

28:                                               ; preds = %25, %25
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  br label %33

29:                                               ; preds = %25
  %30 = and i128 %27, 9221120237041090560
  %31 = icmp eq i128 %30, 0
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %32 = select i1 %31, <2 x i32> %22, <2 x i32> <i32 0, i32 2146959360>
  br label %33

33:                                               ; preds = %29, %28, %1
  %34 = phi <2 x i32> [ %22, %1 ], [ <i32 0, i32 2146959360>, %28 ], [ %32, %29 ]
  %35 = bitcast <2 x i32> %34 to double
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %3) #39
  ret double %35
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func double @__ocmlpriv_tanpired_f64(double noundef %0, i32 noundef %1) local_unnamed_addr #23 {
  %3 = fmul double %0, %0
  %4 = tail call double @llvm.fma.f64(double %3, double 0x41F3FAD0A71EA6D1, double 0xC1D11A76AC97377B)
  %5 = tail call double @llvm.fma.f64(double %3, double %4, double 0x41ABA2BCACA6DA1B)
  %6 = tail call double @llvm.fma.f64(double %3, double %5, double 0xC1579E8E2D7AAF57)
  %7 = tail call double @llvm.fma.f64(double %3, double %6, double 0x414C1C1102E46ECC)
  %8 = tail call double @llvm.fma.f64(double %3, double %7, double 0x41231291BBCB5588)
  %9 = tail call double @llvm.fma.f64(double %3, double %8, double 0x410486B2D6BB3DB2)
  %10 = tail call double @llvm.fma.f64(double %3, double %9, double 0x40E45BE1B46FF156)
  %11 = tail call double @llvm.fma.f64(double %3, double %10, double 0x40C45F61B419C746)
  %12 = tail call double @llvm.fma.f64(double %3, double %11, double 0x40A45F311045A4FF)
  %13 = tail call double @llvm.fma.f64(double %3, double %12, double 0x40845F4739A998C7)
  %14 = tail call double @llvm.fma.f64(double %3, double %13, double 0x40645FFF9B243050)
  %15 = tail call double @llvm.fma.f64(double %3, double %14, double 0x404466BC6775CF74)
  %16 = tail call double @llvm.fma.f64(double %3, double %15, double 0x4024ABBCE625BE8B)
  %17 = fmul double %3, %0
  %18 = fmul double %17, %16
  %19 = tail call double @llvm.fma.f64(double %0, double 0x400921FB54442D18, double %18)
  %20 = fdiv double -1.000000e+00, %19
  %21 = icmp eq i32 %1, 0
  %22 = select i1 %21, double %19, double %20
  ret double %22
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_tanpi_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = alloca %struct.redret.0, align 4
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %3) #39
  %4 = tail call float @llvm.fabs.f32(float %0)
  call spir_func void @__ocmlpriv_trigpired_f32(ptr dead_on_unwind nonnull writable sret(%struct.redret.0) align 4 %3, float noundef %4) #43
  %5 = load float, ptr %3, align 4, !tbaa !38
  %6 = getelementptr inbounds %struct.redret.0, ptr %3, i64 0, i32 1
  %7 = load i32, ptr %6, align 4, !tbaa !40
  %8 = and i32 %7, 1
  %9 = call spir_func float @__ocmlpriv_tanpired_f32(float noundef %5, i32 noundef %8) #38
  %10 = bitcast float %9 to i32
  %11 = add i32 %7, -1
  %12 = icmp ult i32 %11, 2
  %13 = fcmp oeq float %5, 0.000000e+00
  %14 = and i1 %13, %12
  %15 = select i1 %14, i32 -2147483648, i32 0
  %16 = bitcast float %0 to i32
  %17 = and i32 %16, -2147483648
  %18 = xor i32 %17, %10
  %19 = xor i32 %18, %15
  %20 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %30

22:                                               ; preds = %1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %0, ptr %2, align 8, !tbaa !16
  %23 = addrspacecast ptr %2 to ptr addrspace(4)
  %24 = load i64, ptr addrspace(4) %23, align 8, !tbaa !12
  switch i64 %24, label %26 [
    i64 2139095040, label %25
    i64 -8388608, label %25
  ]

25:                                               ; preds = %22, %22
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  br label %30

26:                                               ; preds = %22
  %27 = and i64 %24, 2143289344
  %28 = icmp eq i64 %27, 0
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %29 = select i1 %28, i32 %19, i32 2143289344
  br label %30

30:                                               ; preds = %26, %25, %1
  %31 = phi i32 [ %19, %1 ], [ 2143289344, %25 ], [ %29, %26 ]
  %32 = bitcast i32 %31 to float
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %3) #39
  ret float %32
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocmlpriv_tanpired_f32(float noundef %0, i32 noundef %1) local_unnamed_addr #21 {
  %3 = fmul float %0, %0
  %4 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef 0x40F7D2BD40000000, float noundef 0x40BA4D3060000000) #38
  %5 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %4, float noundef 0x40A4350040000000) #38
  %6 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %5, float noundef 0x4084B69260000000) #38
  %7 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %6, float noundef 0x406451E220000000) #38
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %7, float noundef 0x404467A9C0000000) #38
  %9 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %3, float noundef %8, float noundef 0x4024ABB6A0000000) #38
  %10 = fmul float %3, %0
  %11 = fmul float %10, %9
  %12 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef 0x400921FB60000000, float noundef %11) #38
  %13 = fdiv float -1.000000e+00, %12
  %14 = icmp eq i32 %1, 0
  %15 = select i1 %14, float %12, float %13
  ret float %15
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_tanpi_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = tail call spir_func half @__ocml_tanpi_f16(half noundef %2) #38
  %4 = insertelement <2 x half> poison, half %3, i64 0
  %5 = extractelement <2 x half> %0, i64 1
  %6 = tail call spir_func half @__ocml_tanpi_f16(half noundef %5) #38
  %7 = insertelement <2 x half> %4, half %6, i64 1
  ret <2 x half> %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_tanpi_f16(half noundef %0) local_unnamed_addr #24 {
  %2 = alloca %struct.redret.2, align 2
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2) #39
  %3 = tail call half @llvm.fabs.f16(half %0)
  call spir_func void @__ocmlpriv_trigpired_f16(ptr dead_on_unwind nonnull writable sret(%struct.redret.2) align 2 %2, half noundef %3) #43
  %4 = load half, ptr %2, align 2, !tbaa !45
  %5 = getelementptr inbounds %struct.redret.2, ptr %2, i64 0, i32 1
  %6 = load i16, ptr %5, align 2, !tbaa !51
  %7 = and i16 %6, 1
  %8 = call spir_func half @__ocmlpriv_tanpired_f16(half noundef %4, i16 noundef signext %7) #38
  %9 = bitcast half %8 to i16
  %10 = add i16 %6, -1
  %11 = icmp ult i16 %10, 2
  %12 = fcmp oeq half %4, 0xH0000
  %13 = and i1 %12, %11
  %14 = select i1 %13, i16 -32768, i16 0
  %15 = bitcast half %0 to i16
  %16 = and i16 %15, -32768
  %17 = xor i16 %16, %9
  %18 = xor i16 %17, %14
  %19 = load i8, ptr addrspace(2) @__oclc_finite_only_opt, align 1, !tbaa !25, !range !27, !noundef !28
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %26

21:                                               ; preds = %1
  %22 = fptoui half %0 to i16
  %23 = call spir_func i32 @__builtin_generic_class_f16.137(i16 noundef zeroext %22) #39
  %24 = icmp eq i32 %23, 0
  %25 = select i1 %24, i16 %18, i16 32256
  br label %26

26:                                               ; preds = %21, %1
  %27 = phi i16 [ %18, %1 ], [ %25, %21 ]
  %28 = bitcast i16 %27 to half
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2) #39
  ret half %28
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func half @__ocmlpriv_tanpired_f16(half noundef %0, i16 noundef signext %1) local_unnamed_addr #23 {
  %3 = fmul half %0, %0
  %4 = tail call half @llvm.fma.f16(half %3, half 0xH5CF6, half 0xH4FF9)
  %5 = tail call half @llvm.fma.f16(half %3, half %4, half 0xH4942)
  %6 = fmul half %3, %0
  %7 = fmul half %6, %5
  %8 = tail call half @llvm.fma.f16(half %0, half 0xH4248, half %7)
  %9 = fdiv half 0xHBC00, %8
  %10 = icmp eq i16 %1, 0
  %11 = select i1 %10, half %8, half %9
  ret half %11
}

; Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define internal spir_func noundef i32 @__builtin_generic_class_f16.137(i16 noundef zeroext %0) unnamed_addr #25 {
  switch i16 %0, label %2 [
    i16 31744, label %6
    i16 -1024, label %6
  ]

2:                                                ; preds = %1
  %3 = and i16 %0, 32256
  %4 = icmp ne i16 %3, 0
  %5 = sext i1 %4 to i32
  br label %6

6:                                                ; preds = %2, %1, %1
  %7 = phi i32 [ -1, %1 ], [ -1, %1 ], [ %5, %2 ]
  ret i32 %7
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_tgamma_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = tail call double @llvm.fabs.f64(double %0)
  %3 = fcmp ogt double %2, 0x3F40000000000000
  br i1 %3, label %4, label %137

4:                                                ; preds = %1
  %5 = fcmp olt double %2, 4.500000e+00
  br i1 %5, label %6, label %17

6:                                                ; preds = %4
  %7 = fcmp olt double %2, 1.000000e+00
  br i1 %7, label %8, label %10

8:                                                ; preds = %6
  %9 = fadd double %2, 1.000000e+00
  br label %26

10:                                               ; preds = %6
  %11 = fcmp uge double %2, 3.000000e+00
  %12 = fcmp olt double %2, 4.000000e+00
  %13 = and i1 %11, %12
  %14 = fadd double %2, -1.000000e+00
  %15 = select i1 %13, double %14, double %2
  %16 = select i1 %13, double %14, double 1.000000e+00
  br label %26

17:                                               ; preds = %4
  %18 = fcmp olt double %2, 5.500000e+00
  br i1 %18, label %19, label %22

19:                                               ; preds = %17
  %20 = tail call double @llvm.fma.f64(double %0, double %0, double %2)
  %21 = fadd double %2, 2.000000e+00
  br label %26

22:                                               ; preds = %17
  %23 = fcmp olt double %2, 6.500000e+00
  br i1 %23, label %24, label %26

24:                                               ; preds = %22
  %25 = fadd double %2, 1.000000e+00
  br label %26

26:                                               ; preds = %10, %19, %24, %22, %8
  %27 = phi double [ %9, %8 ], [ %21, %19 ], [ %25, %24 ], [ %2, %22 ], [ %15, %10 ]
  %28 = phi double [ %2, %8 ], [ %20, %19 ], [ %2, %24 ], [ 1.000000e+00, %22 ], [ 1.000000e+00, %10 ]
  %29 = phi double [ 1.000000e+00, %8 ], [ 1.000000e+00, %19 ], [ 1.000000e+00, %24 ], [ 1.000000e+00, %22 ], [ %16, %10 ]
  %30 = fcmp olt double %0, 0.000000e+00
  br i1 %30, label %31, label %35

31:                                               ; preds = %26
  %32 = fneg double %0
  %33 = tail call spir_func double @__ocml_sinpi_f64(double noundef %0) #38
  %34 = fmul double %33, %32
  br label %35

35:                                               ; preds = %31, %26
  %36 = phi double [ %34, %31 ], [ 1.000000e+00, %26 ]
  %37 = fneg double %27
  %38 = tail call spir_func double @__ocml_exp_f64(double noundef %37) #38
  %39 = fcmp olt double %27, 4.500000e+00
  br i1 %39, label %40, label %77

40:                                               ; preds = %35
  %41 = tail call double @llvm.fma.f64(double %27, double 0x40F4AB1F6E83DCE9, double 0x4110D0CE4500BC82)
  %42 = tail call double @llvm.fma.f64(double %27, double %41, double 0x411AE4AFD120301F)
  %43 = tail call double @llvm.fma.f64(double %27, double %42, double 0x4115082AF927D6F4)
  %44 = tail call double @llvm.fma.f64(double %27, double %43, double 0x410012DB432D213B)
  %45 = tail call double @llvm.fma.f64(double %27, double %44, double 0x40D0878904CC0A98)
  %46 = tail call double @llvm.fma.f64(double %27, double %45, double 0x407294FE7CB03F7E)
  %47 = fmul double %29, %46
  %48 = tail call double @llvm.fma.f64(double %27, double 0x40E07DB4866AD8C9, double 0x40FA259259D8939B)
  %49 = tail call double @llvm.fma.f64(double %27, double %48, double 0x41045A9F332EF3D7)
  %50 = tail call double @llvm.fma.f64(double %27, double %49, double 0x40FE19DE58C591E1)
  %51 = tail call double @llvm.fma.f64(double %27, double %50, double 0x40E47E912BCE5459)
  %52 = tail call double @llvm.fma.f64(double %27, double %51, double 0x40A98DE345ECF69C)
  %53 = tail call double @llvm.fma.f64(double %27, double %52, double 0xC02AAE2055F91864)
  %54 = tail call double @llvm.fma.f64(double %27, double %53, double 1.000000e+00)
  %55 = fmul double %28, %54
  %56 = fadd double %27, 5.000000e-01
  %57 = tail call spir_func double @__ocml_powr_f64(double noundef %27, double noundef %56) #38
  %58 = fcmp ult double %0, 0.000000e+00
  br i1 %58, label %63, label %59

59:                                               ; preds = %40
  %60 = fmul double %38, %57
  %61 = fdiv double %47, %55
  %62 = fmul double %61, %60
  br label %143

63:                                               ; preds = %40
  %64 = fmul double %55, 0x400921FB54442D18
  %65 = fmul double %36, %38
  %66 = fmul double %65, %57
  %67 = fmul double %47, %66
  %68 = fdiv double %64, %67
  %69 = fptosi double %0 to i64
  %70 = sitofp i64 %69 to double
  %71 = fsub double %0, %70
  %72 = bitcast double %2 to i64
  %73 = icmp eq i64 %72, 9218868437227405312
  %74 = select i1 %73, double 0.000000e+00, double %71
  %75 = fcmp oeq double %74, 0.000000e+00
  %76 = select i1 %75, double 0x7FF8000000000000, double %68
  br label %143

77:                                               ; preds = %35
  %78 = fdiv double 1.000000e+00, %27
  %79 = tail call double @llvm.fma.f64(double %78, double 0x3FDCCD75F8F2C906, double 0xBF797AFD9D48525D)
  %80 = tail call double @llvm.fma.f64(double %78, double %79, double 0xBFB2F2ACB5BF5FFD)
  %81 = tail call double @llvm.fma.f64(double %78, double %80, double 0x3F562F0E23FD0C19)
  %82 = tail call double @llvm.fma.f64(double %78, double %81, double 0x3F906FA254FEA952)
  %83 = tail call double @llvm.fma.f64(double %78, double %82, double 0xBF3AB27FA22C15A8)
  %84 = tail call double @llvm.fma.f64(double %78, double %83, double 0xBF73A7E4383F8766)
  %85 = tail call double @llvm.fma.f64(double %78, double %84, double 0x3F27ABEDB872AF00)
  %86 = tail call double @llvm.fma.f64(double %78, double %85, double 0x3F613D0F7D32582E)
  %87 = tail call double @llvm.fma.f64(double %78, double %86, double 0xBF20FDEA4648ED9D)
  %88 = tail call double @llvm.fma.f64(double %78, double %87, double 0xBF5851C7286C560C)
  %89 = tail call double @llvm.fma.f64(double %78, double %88, double 0x3F26E8BA6CCAF74E)
  %90 = tail call double @llvm.fma.f64(double %78, double %89, double 0x3F601985A7C9E683)
  %91 = tail call double @llvm.fma.f64(double %78, double %90, double 0xBF42D92340CE801F)
  %92 = tail call double @llvm.fma.f64(double %78, double %91, double 0xBF7B8792FC787C5E)
  %93 = tail call double @llvm.fma.f64(double %78, double %92, double 0x3F81D32D71BE5B93)
  %94 = tail call double @llvm.fma.f64(double %78, double %93, double 0x3FCABCC42A9D895D)
  %95 = tail call double @llvm.fma.f64(double %78, double %94, double 0x40040D931FF62706)
  %96 = tail call double @llvm.fma.f64(double %27, double 5.000000e-01, double -2.500000e-01)
  %97 = tail call spir_func double @__ocml_powr_f64(double noundef %27, double noundef %96) #38
  %98 = fcmp ult double %0, 0.000000e+00
  br i1 %98, label %106, label %99

99:                                               ; preds = %77
  %100 = fmul double %38, %97
  %101 = fmul double %97, %100
  %102 = fmul double %95, %101
  %103 = fdiv double %102, %28
  %104 = fcmp ogt double %0, 0x406573FAE561F647
  %105 = select i1 %104, double 0x7FF0000000000000, double %103
  br label %143

106:                                              ; preds = %77
  br i1 %30, label %107, label %143

107:                                              ; preds = %106
  %108 = fcmp ult double %0, -1.705000e+02
  br i1 %108, label %116, label %109

109:                                              ; preds = %107
  %110 = fmul double %28, 0x400921FB54442D18
  %111 = fmul double %38, %97
  %112 = fmul double %97, %111
  %113 = fmul double %95, %112
  %114 = fmul double %36, %113
  %115 = fdiv double %110, %114
  br label %127

116:                                              ; preds = %107
  %117 = fcmp ult double %0, -1.840000e+02
  br i1 %117, label %125, label %118

118:                                              ; preds = %116
  %119 = fmul double %28, 0x400921FB54442D18
  %120 = fmul double %38, %97
  %121 = fmul double %95, %120
  %122 = fdiv double %119, %121
  %123 = fmul double %36, %97
  %124 = fdiv double %122, %123
  br label %127

125:                                              ; preds = %116
  %126 = tail call double @llvm.copysign.f64(double 0.000000e+00, double %36)
  br label %127

127:                                              ; preds = %118, %125, %109
  %128 = phi double [ %115, %109 ], [ %124, %118 ], [ %126, %125 ]
  %129 = fptosi double %0 to i64
  %130 = sitofp i64 %129 to double
  %131 = fsub double %0, %130
  %132 = bitcast double %2 to i64
  %133 = icmp eq i64 %132, 9218868437227405312
  %134 = select i1 %133, double 0.000000e+00, double %131
  %135 = fcmp oeq double %134, 0.000000e+00
  %136 = select i1 %135, double 0x7FF8000000000000, double %128
  br label %143

137:                                              ; preds = %1
  %138 = tail call double @llvm.fma.f64(double %0, double 0x3FEF6A51055096B5, double 0xBFED0A118F324B63)
  %139 = tail call double @llvm.fma.f64(double %0, double %138, double 0x3FEFA658C23B1578)
  %140 = tail call double @llvm.fma.f64(double %0, double %139, double 0xBFE2788CFC6FB619)
  %141 = fdiv double 1.000000e+00, %0
  %142 = fadd double %141, %140
  br label %143

143:                                              ; preds = %63, %59, %106, %127, %99, %137
  %144 = phi double [ %142, %137 ], [ %62, %59 ], [ %76, %63 ], [ %105, %99 ], [ %136, %127 ], [ %0, %106 ]
  ret double %144
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_tgamma_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = tail call float @llvm.fabs.f32(float %0)
  %3 = fcmp ogt float %2, 1.562500e-02
  br i1 %3, label %4, label %59

4:                                                ; preds = %1
  %5 = fcmp olt float %0, 1.000000e+00
  br i1 %5, label %6, label %10

6:                                                ; preds = %4
  %7 = fadd float %2, 3.000000e+00
  %8 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %7, float noundef %2, float noundef 2.000000e+00) #38
  %9 = fmul float %2, %8
  br label %19

10:                                               ; preds = %4
  %11 = fcmp olt float %2, 2.000000e+00
  br i1 %11, label %12, label %15

12:                                               ; preds = %10
  %13 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %2, float noundef %2, float noundef %2) #38
  %14 = fadd float %2, 2.000000e+00
  br label %19

15:                                               ; preds = %10
  %16 = fcmp olt float %2, 3.000000e+00
  br i1 %16, label %17, label %19

17:                                               ; preds = %15
  %18 = fadd float %2, 1.000000e+00
  br label %19

19:                                               ; preds = %12, %17, %15, %6
  %20 = phi float [ %9, %6 ], [ %13, %12 ], [ %2, %17 ], [ 1.000000e+00, %15 ]
  %21 = phi float [ %7, %6 ], [ %14, %12 ], [ %18, %17 ], [ %2, %15 ]
  %22 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %21, float noundef 5.000000e-01, float noundef -2.500000e-01) #38
  %23 = tail call spir_func float @__ocml_powr_f32(float noundef %21, float noundef %22) #38
  %24 = fneg float %21
  %25 = tail call spir_func float @__ocml_exp_f32(float noundef %24) #38
  %26 = tail call spir_func float @_Z12native_recipf(float noundef %21) #38
  %27 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %26, float noundef 0xBF65F72680000000, float noundef 0x3F6C71C720000000) #38
  %28 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %26, float noundef %27, float noundef 0x3FB5555560000000) #38
  %29 = fmul float %26, %28
  %30 = fcmp ogt float %0, 0.000000e+00
  br i1 %30, label %31, label %40

31:                                               ; preds = %19
  %32 = fmul float %25, 0x40040D9320000000
  %33 = fmul float %23, %32
  %34 = fmul float %23, %33
  %35 = tail call spir_func float @_Z12native_recipf(float noundef %20) #38
  %36 = fmul float %34, %35
  %37 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %36, float noundef %29, float noundef %36) #38
  %38 = fcmp ogt float %0, 0x40418521E0000000
  %39 = select i1 %38, float 0x7FF0000000000000, float %37
  br label %66

40:                                               ; preds = %19
  %41 = tail call spir_func float @__ocml_sinpi_f32(float noundef %0) #38
  %42 = fmul float %41, %0
  %43 = fmul float %25, %42
  %44 = fmul float %23, %43
  %45 = fmul float %23, %44
  %46 = fmul float %20, 0xBFF40D9320000000
  %47 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %45, float noundef %29, float noundef %45) #38
  %48 = fdiv float %46, %47, !fpmath !15
  %49 = fcmp olt float %0, -4.200000e+01
  %50 = select i1 %49, float 0.000000e+00, float %48
  %51 = fptosi float %0 to i32
  %52 = sitofp i32 %51 to float
  %53 = fsub float %0, %52
  %54 = bitcast float %2 to i32
  %55 = icmp eq i32 %54, 2139095040
  %56 = select i1 %55, float 0.000000e+00, float %53
  %57 = fcmp oeq float %56, 0.000000e+00
  %58 = select i1 %57, float 0x7FF8000000000000, float %50
  br label %66

59:                                               ; preds = %1
  %60 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef 0x3FEF6A5100000000, float noundef 0xBFED0A1180000000) #38
  %61 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef %60, float noundef 0x3FEFA658C0000000) #38
  %62 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %0, float noundef %61, float noundef 0xBFE2788D00000000) #38
  %63 = fmul float %0, 4.000000e+00
  %64 = tail call spir_func float @_Z12native_recipf(float noundef %63) #38
  %65 = tail call float @llvm.fmuladd.f32(float %64, float 4.000000e+00, float %62)
  br label %66

66:                                               ; preds = %31, %40, %59
  %67 = phi float [ %65, %59 ], [ %39, %31 ], [ %58, %40 ]
  ret float %67
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_tgamma_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_tgamma_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_tgamma_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_tgamma_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_tgamma_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef double @__ocml_trunc_f64(double noundef %0) local_unnamed_addr #23 {
  %2 = tail call double @llvm.trunc.f64(double %0)
  ret double %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef float @__ocml_trunc_f32(float noundef %0) local_unnamed_addr #23 {
  %2 = tail call float @llvm.trunc.f32(float %0)
  ret float %2
}

; Function Attrs: convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef <2 x half> @__ocml_trunc_2f16(<2 x half> noundef %0) local_unnamed_addr #31 {
  %2 = tail call spir_func <2 x half> @llvm.trunc.v2f16(<2 x half> noundef %0) #38
  ret <2 x half> %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define protected spir_func noundef half @__ocml_trunc_f16(half noundef %0) local_unnamed_addr #23 {
  %2 = tail call half @llvm.trunc.f16(half %0)
  ret half %2
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_y0_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = fcmp ugt double %0, 0x4029180000000000
  br i1 %3, label %108, label %4

4:                                                ; preds = %1
  %5 = fcmp olt double %0, 2.000000e+00
  br i1 %5, label %6, label %26

6:                                                ; preds = %4
  %7 = fcmp olt double %0, 8.125000e-01
  br i1 %7, label %8, label %18

8:                                                ; preds = %6
  %9 = fcmp olt double %0, 3.125000e-01
  br i1 %9, label %48, label %10

10:                                               ; preds = %8
  %11 = fcmp olt double %0, 4.375000e-01
  br i1 %11, label %48, label %12

12:                                               ; preds = %10
  %13 = fcmp olt double %0, 5.625000e-01
  br i1 %13, label %48, label %14

14:                                               ; preds = %12
  %15 = fcmp olt double %0, 6.875000e-01
  %16 = select i1 %15, double 5.625000e-01, double 6.875000e-01
  %17 = select i1 %15, ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 45), ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 60)
  br label %48

18:                                               ; preds = %6
  %19 = fcmp olt double %0, 1.000000e+00
  br i1 %19, label %48, label %20

20:                                               ; preds = %18
  %21 = fcmp olt double %0, 1.250000e+00
  br i1 %21, label %48, label %22

22:                                               ; preds = %20
  %23 = fcmp olt double %0, 1.625000e+00
  %24 = select i1 %23, double 1.250000e+00, double 1.625000e+00
  %25 = select i1 %23, ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 105), ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 120)
  br label %48

26:                                               ; preds = %4
  %27 = fcmp olt double %0, 0x4019100000000000
  br i1 %27, label %28, label %39

28:                                               ; preds = %26
  %29 = fcmp olt double %0, 2.531250e+00
  br i1 %29, label %48, label %30

30:                                               ; preds = %28
  %31 = fcmp olt double %0, 3.000000e+00
  br i1 %31, label %48, label %32

32:                                               ; preds = %30
  %33 = fcmp olt double %0, 0x400BE00000000000
  br i1 %33, label %48, label %34

34:                                               ; preds = %32
  %35 = fcmp olt double %0, 0x4012D00000000000
  %36 = select i1 %35, double 0xBC9F06AE7804384E, double 0x3CBDFE7BAC228E8C
  %37 = select i1 %35, double 0x400FA9534D98569C, double 0x4015B7FE4E87B02E
  %38 = select i1 %35, ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 180), ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 195)
  br label %48

39:                                               ; preds = %26
  %40 = fcmp olt double %0, 7.843750e+00
  br i1 %40, label %48, label %41

41:                                               ; preds = %39
  %42 = fcmp olt double %0, 0x4022D80000000000
  br i1 %42, label %48, label %43

43:                                               ; preds = %41
  %44 = fcmp olt double %0, 0x4025F80000000000
  %45 = select i1 %44, double 0xBCCCB49FF791C495, double 0x3C80FC786CE06080
  %46 = select i1 %44, double 0x402471D735A47D58, double 0x40277F9138D43206
  %47 = select i1 %44, ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 240), ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 255)
  br label %48

48:                                               ; preds = %43, %41, %39, %34, %32, %30, %28, %22, %20, %18, %14, %12, %10, %8
  %49 = phi double [ 0.000000e+00, %8 ], [ 0.000000e+00, %10 ], [ 0.000000e+00, %12 ], [ 0.000000e+00, %14 ], [ 0x3C7EA9D270347F83, %18 ], [ 0.000000e+00, %20 ], [ 0.000000e+00, %22 ], [ 0xBC8BD1E50D219BFD, %28 ], [ 0.000000e+00, %30 ], [ 0.000000e+00, %32 ], [ %36, %34 ], [ 0xBC99774A495F56CF, %39 ], [ 0x3CB479CC068D9046, %41 ], [ %45, %43 ]
  %50 = phi double [ 0.000000e+00, %8 ], [ 3.125000e-01, %10 ], [ 4.375000e-01, %12 ], [ %16, %14 ], [ 0x3FEC982EB8D417EA, %18 ], [ 1.000000e+00, %20 ], [ %24, %22 ], [ 0x400193BED4DFF243, %28 ], [ 2.531250e+00, %30 ], [ 3.000000e+00, %32 ], [ %37, %34 ], [ 0x401C581DC4E72103, %39 ], [ 0x40213127AE6169B4, %41 ], [ %46, %43 ]
  %51 = phi ptr addrspace(2) [ @__ocmltbl_M64_Y0, %8 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 15), %10 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 30), %12 ], [ %17, %14 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 75), %18 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 90), %20 ], [ %25, %22 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 135), %28 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 150), %30 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 165), %32 ], [ %38, %34 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 210), %39 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y0, i64 0, i64 225), %41 ], [ %47, %43 ]
  %52 = fcmp olt double %0, 3.125000e-01
  br i1 %52, label %53, label %59

53:                                               ; preds = %48
  %54 = tail call spir_func double @__ocml_j0_f64(double noundef %0) #38
  %55 = fmul double %54, 0x3FE45F306DC9C883
  %56 = tail call spir_func double @__ocml_log_f64(double noundef %0) #38
  %57 = fmul double %55, %56
  %58 = fmul double %0, %0
  br label %59

59:                                               ; preds = %53, %48
  %60 = phi double [ %57, %53 ], [ 0.000000e+00, %48 ]
  %61 = phi double [ %58, %53 ], [ %0, %48 ]
  %62 = fsub double %61, %50
  %63 = fsub double %62, %49
  %64 = getelementptr inbounds double, ptr addrspace(2) %51, i64 14
  %65 = load double, ptr addrspace(2) %64, align 8, !tbaa !19
  %66 = getelementptr inbounds double, ptr addrspace(2) %51, i64 13
  %67 = load double, ptr addrspace(2) %66, align 8, !tbaa !19
  %68 = tail call double @llvm.fma.f64(double %63, double %65, double %67)
  %69 = getelementptr inbounds double, ptr addrspace(2) %51, i64 12
  %70 = load double, ptr addrspace(2) %69, align 8, !tbaa !19
  %71 = tail call double @llvm.fma.f64(double %63, double %68, double %70)
  %72 = getelementptr inbounds double, ptr addrspace(2) %51, i64 11
  %73 = load double, ptr addrspace(2) %72, align 8, !tbaa !19
  %74 = tail call double @llvm.fma.f64(double %63, double %71, double %73)
  %75 = getelementptr inbounds double, ptr addrspace(2) %51, i64 10
  %76 = load double, ptr addrspace(2) %75, align 8, !tbaa !19
  %77 = tail call double @llvm.fma.f64(double %63, double %74, double %76)
  %78 = getelementptr inbounds double, ptr addrspace(2) %51, i64 9
  %79 = load double, ptr addrspace(2) %78, align 8, !tbaa !19
  %80 = tail call double @llvm.fma.f64(double %63, double %77, double %79)
  %81 = getelementptr inbounds double, ptr addrspace(2) %51, i64 8
  %82 = load double, ptr addrspace(2) %81, align 8, !tbaa !19
  %83 = tail call double @llvm.fma.f64(double %63, double %80, double %82)
  %84 = getelementptr inbounds double, ptr addrspace(2) %51, i64 7
  %85 = load double, ptr addrspace(2) %84, align 8, !tbaa !19
  %86 = tail call double @llvm.fma.f64(double %63, double %83, double %85)
  %87 = getelementptr inbounds double, ptr addrspace(2) %51, i64 6
  %88 = load double, ptr addrspace(2) %87, align 8, !tbaa !19
  %89 = tail call double @llvm.fma.f64(double %63, double %86, double %88)
  %90 = getelementptr inbounds double, ptr addrspace(2) %51, i64 5
  %91 = load double, ptr addrspace(2) %90, align 8, !tbaa !19
  %92 = tail call double @llvm.fma.f64(double %63, double %89, double %91)
  %93 = getelementptr inbounds double, ptr addrspace(2) %51, i64 4
  %94 = load double, ptr addrspace(2) %93, align 8, !tbaa !19
  %95 = tail call double @llvm.fma.f64(double %63, double %92, double %94)
  %96 = getelementptr inbounds double, ptr addrspace(2) %51, i64 3
  %97 = load double, ptr addrspace(2) %96, align 8, !tbaa !19
  %98 = tail call double @llvm.fma.f64(double %63, double %95, double %97)
  %99 = getelementptr inbounds double, ptr addrspace(2) %51, i64 2
  %100 = load double, ptr addrspace(2) %99, align 8, !tbaa !19
  %101 = tail call double @llvm.fma.f64(double %63, double %98, double %100)
  %102 = getelementptr inbounds double, ptr addrspace(2) %51, i64 1
  %103 = load double, ptr addrspace(2) %102, align 8, !tbaa !19
  %104 = tail call double @llvm.fma.f64(double %63, double %101, double %103)
  %105 = load double, ptr addrspace(2) %51, align 8, !tbaa !19
  %106 = tail call double @llvm.fma.f64(double %63, double %104, double %105)
  %107 = fadd double %60, %106
  br label %136

108:                                              ; preds = %1
  %109 = fdiv double 1.000000e+00, %0
  %110 = fmul double %109, %109
  %111 = tail call spir_func double @__ocmlpriv_bp0_f64(double noundef %110) #38
  %112 = fmul double %109, %111
  %113 = fptrunc double %109 to float
  %114 = tail call spir_func float @_Z12native_rsqrtf(float noundef %113) #38
  %115 = fpext float %114 to double
  %116 = fmul double %109, %115
  %117 = fmul double %115, 5.000000e-01
  %118 = fneg double %117
  %119 = tail call double @llvm.fma.f64(double %118, double %116, double 5.000000e-01)
  %120 = tail call double @llvm.fma.f64(double %117, double %119, double %117)
  %121 = tail call double @llvm.fma.f64(double %116, double %119, double %116)
  %122 = fneg double %121
  %123 = tail call double @llvm.fma.f64(double %122, double %121, double %109)
  %124 = tail call double @llvm.fma.f64(double %123, double %120, double %121)
  %125 = fcmp oeq double %109, 0.000000e+00
  %126 = select i1 %125, double %109, double %124
  %127 = fmul double %126, 0x3FE9884533D43651
  %128 = tail call spir_func double @__ocmlpriv_ba0_f64(double noundef %110) #38
  %129 = fmul double %128, %127
  %130 = tail call spir_func double @__ocmlpriv_sinb_f64(double noundef %0, i32 noundef 0, double noundef %112) #40
  %131 = fmul double %130, %129
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %0, ptr %2, align 8, !tbaa !19
  %132 = addrspacecast ptr %2 to ptr addrspace(4)
  %133 = load i128, ptr addrspace(4) %132, align 8, !tbaa !29
  %134 = icmp eq i128 %133, 9218868437227405312
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %135 = select i1 %134, double 0.000000e+00, double %131
  br label %136

136:                                              ; preds = %108, %59
  %137 = phi double [ %107, %59 ], [ %135, %108 ]
  ret double %137
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_y0_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = fcmp ugt float %0, 0x4029180000000000
  br i1 %3, label %90, label %4

4:                                                ; preds = %1
  %5 = fcmp olt float %0, 2.000000e+00
  br i1 %5, label %6, label %26

6:                                                ; preds = %4
  %7 = fcmp olt float %0, 8.125000e-01
  br i1 %7, label %8, label %18

8:                                                ; preds = %6
  %9 = fcmp olt float %0, 3.125000e-01
  br i1 %9, label %48, label %10

10:                                               ; preds = %8
  %11 = fcmp olt float %0, 4.375000e-01
  br i1 %11, label %48, label %12

12:                                               ; preds = %10
  %13 = fcmp olt float %0, 5.625000e-01
  br i1 %13, label %48, label %14

14:                                               ; preds = %12
  %15 = fcmp olt float %0, 6.875000e-01
  %16 = select i1 %15, float 5.625000e-01, float 6.875000e-01
  %17 = select i1 %15, ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 27), ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 36)
  br label %48

18:                                               ; preds = %6
  %19 = fcmp olt float %0, 1.000000e+00
  br i1 %19, label %48, label %20

20:                                               ; preds = %18
  %21 = fcmp olt float %0, 1.250000e+00
  br i1 %21, label %48, label %22

22:                                               ; preds = %20
  %23 = fcmp olt float %0, 1.625000e+00
  %24 = select i1 %23, float 1.250000e+00, float 1.625000e+00
  %25 = select i1 %23, ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 63), ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 72)
  br label %48

26:                                               ; preds = %4
  %27 = fcmp olt float %0, 0x4019100000000000
  br i1 %27, label %28, label %39

28:                                               ; preds = %26
  %29 = fcmp olt float %0, 2.531250e+00
  br i1 %29, label %48, label %30

30:                                               ; preds = %28
  %31 = fcmp olt float %0, 3.000000e+00
  br i1 %31, label %48, label %32

32:                                               ; preds = %30
  %33 = fcmp olt float %0, 0x400BE00000000000
  br i1 %33, label %48, label %34

34:                                               ; preds = %32
  %35 = fcmp olt float %0, 0x4012D00000000000
  %36 = select i1 %35, float 0x3E7B30AD40000000, float 0x3E8D0F6060000000
  %37 = select i1 %35, float 0x400FA95340000000, float 0x4015B7FE40000000
  %38 = select i1 %35, ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 108), ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 117)
  br label %48

39:                                               ; preds = %26
  %40 = fcmp olt float %0, 7.843750e+00
  br i1 %40, label %48, label %41

41:                                               ; preds = %39
  %42 = fcmp olt float %0, 0x4022D80000000000
  br i1 %42, label %48, label %43

43:                                               ; preds = %41
  %44 = fcmp olt float %0, 0x4025F80000000000
  %45 = select i1 %44, float 0xBE94B70560000000, float 0xBE8CAF37E0000000
  %46 = select i1 %44, float 0x402471D740000000, float 0x40277F9140000000
  %47 = select i1 %44, ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 144), ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 153)
  br label %48

48:                                               ; preds = %43, %41, %39, %34, %32, %30, %28, %22, %20, %18, %14, %12, %10, %8
  %49 = phi float [ 0.000000e+00, %8 ], [ 0.000000e+00, %10 ], [ 0.000000e+00, %12 ], [ 0.000000e+00, %14 ], [ 0xBE4CAFA060000000, %18 ], [ 0.000000e+00, %20 ], [ 0.000000e+00, %22 ], [ 0xBE76401B80000000, %28 ], [ 0.000000e+00, %30 ], [ 0.000000e+00, %32 ], [ %36, %34 ], [ 0x3E739C8400000000, %39 ], [ 0x3E9CC2D360000000, %41 ], [ %45, %43 ]
  %50 = phi float [ 0.000000e+00, %8 ], [ 3.125000e-01, %10 ], [ 4.375000e-01, %12 ], [ %16, %14 ], [ 0x3FEC982EC0000000, %18 ], [ 1.000000e+00, %20 ], [ %24, %22 ], [ 0x400193BEE0000000, %28 ], [ 2.531250e+00, %30 ], [ 3.000000e+00, %32 ], [ %37, %34 ], [ 0x401C581DC0000000, %39 ], [ 0x40213127A0000000, %41 ], [ %46, %43 ]
  %51 = phi ptr addrspace(2) [ @__ocmltbl_M32_Y0, %8 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 9), %10 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 18), %12 ], [ %17, %14 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 45), %18 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 54), %20 ], [ %25, %22 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 81), %28 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 90), %30 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 99), %32 ], [ %38, %34 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 126), %39 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y0, i64 0, i64 135), %41 ], [ %47, %43 ]
  %52 = fcmp olt float %0, 3.125000e-01
  br i1 %52, label %53, label %59

53:                                               ; preds = %48
  %54 = tail call spir_func float @__ocml_j0_f32(float noundef %0) #38
  %55 = fmul float %54, 0x3FE45F3060000000
  %56 = tail call spir_func float @__ocml_log_f32(float noundef %0) #38
  %57 = fmul float %55, %56
  %58 = fmul float %0, %0
  br label %59

59:                                               ; preds = %53, %48
  %60 = phi float [ %57, %53 ], [ 0.000000e+00, %48 ]
  %61 = phi float [ %58, %53 ], [ %0, %48 ]
  %62 = fsub float %61, %50
  %63 = fsub float %62, %49
  %64 = getelementptr inbounds float, ptr addrspace(2) %51, i64 8
  %65 = load float, ptr addrspace(2) %64, align 4, !tbaa !16
  %66 = getelementptr inbounds float, ptr addrspace(2) %51, i64 7
  %67 = load float, ptr addrspace(2) %66, align 4, !tbaa !16
  %68 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %63, float noundef %65, float noundef %67) #38
  %69 = getelementptr inbounds float, ptr addrspace(2) %51, i64 6
  %70 = load float, ptr addrspace(2) %69, align 4, !tbaa !16
  %71 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %63, float noundef %68, float noundef %70) #38
  %72 = getelementptr inbounds float, ptr addrspace(2) %51, i64 5
  %73 = load float, ptr addrspace(2) %72, align 4, !tbaa !16
  %74 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %63, float noundef %71, float noundef %73) #38
  %75 = getelementptr inbounds float, ptr addrspace(2) %51, i64 4
  %76 = load float, ptr addrspace(2) %75, align 4, !tbaa !16
  %77 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %63, float noundef %74, float noundef %76) #38
  %78 = getelementptr inbounds float, ptr addrspace(2) %51, i64 3
  %79 = load float, ptr addrspace(2) %78, align 4, !tbaa !16
  %80 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %63, float noundef %77, float noundef %79) #38
  %81 = getelementptr inbounds float, ptr addrspace(2) %51, i64 2
  %82 = load float, ptr addrspace(2) %81, align 4, !tbaa !16
  %83 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %63, float noundef %80, float noundef %82) #38
  %84 = getelementptr inbounds float, ptr addrspace(2) %51, i64 1
  %85 = load float, ptr addrspace(2) %84, align 4, !tbaa !16
  %86 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %63, float noundef %83, float noundef %85) #38
  %87 = load float, ptr addrspace(2) %51, align 4, !tbaa !16
  %88 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %63, float noundef %86, float noundef %87) #38
  %89 = fadd float %60, %88
  br label %105

90:                                               ; preds = %1
  %91 = fdiv float 1.000000e+00, %0, !fpmath !15
  %92 = fmul float %91, %91
  %93 = tail call spir_func float @__ocmlpriv_bp0_f32(float noundef %92) #38
  %94 = fmul float %91, %93
  %95 = tail call spir_func float @_Z12native_rsqrtf(float noundef %0) #38
  %96 = fmul float %95, 0x3FE9884540000000
  %97 = tail call spir_func float @__ocmlpriv_ba0_f32(float noundef %92) #38
  %98 = fmul float %96, %97
  %99 = tail call spir_func float @__ocmlpriv_sinb_f32(float noundef %0, i32 noundef 0, float noundef %94) #40
  %100 = fmul float %98, %99
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %0, ptr %2, align 8, !tbaa !16
  %101 = addrspacecast ptr %2 to ptr addrspace(4)
  %102 = load i64, ptr addrspace(4) %101, align 8, !tbaa !12
  %103 = icmp eq i64 %102, 2139095040
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %104 = select i1 %103, float 0.000000e+00, float %100
  br label %105

105:                                              ; preds = %90, %59
  %106 = phi float [ %89, %59 ], [ %104, %90 ]
  ret float %106
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_y0_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_y0_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_y0_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_y0_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_y0_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func double @__ocml_y1_f64(double noundef %0) local_unnamed_addr #21 {
  %2 = alloca double, align 8
  %3 = fcmp ugt double %0, 1.256250e+01
  br i1 %3, label %117, label %4

4:                                                ; preds = %1
  %5 = fcmp olt double %0, 2.312500e+00
  br i1 %5, label %6, label %27

6:                                                ; preds = %4
  %7 = fcmp olt double %0, 1.218750e+00
  br i1 %7, label %8, label %18

8:                                                ; preds = %6
  %9 = fcmp olt double %0, 5.000000e-01
  br i1 %9, label %49, label %10

10:                                               ; preds = %8
  %11 = fcmp olt double %0, 6.250000e-01
  br i1 %11, label %49, label %12

12:                                               ; preds = %10
  %13 = fcmp olt double %0, 7.500000e-01
  br i1 %13, label %49, label %14

14:                                               ; preds = %12
  %15 = fcmp olt double %0, 9.375000e-01
  %16 = select i1 %15, double 7.500000e-01, double 9.375000e-01
  %17 = select i1 %15, ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 45), ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 60)
  br label %49

18:                                               ; preds = %6
  %19 = fcmp olt double %0, 1.531250e+00
  br i1 %19, label %49, label %20

20:                                               ; preds = %18
  %21 = fcmp olt double %0, 1.843750e+00
  br i1 %21, label %49, label %22

22:                                               ; preds = %20
  %23 = fcmp olt double %0, 0x4000A00000000000
  %24 = select i1 %23, double 0.000000e+00, double 0xBC8BD1E50D219BFD
  %25 = select i1 %23, double 1.843750e+00, double 0x400193BED4DFF243
  %26 = select i1 %23, ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 105), ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 120)
  br label %49

27:                                               ; preds = %4
  %28 = fcmp olt double %0, 6.187500e+00
  br i1 %28, label %29, label %40

29:                                               ; preds = %27
  %30 = fcmp olt double %0, 0x4005E00000000000
  br i1 %30, label %49, label %31

31:                                               ; preds = %29
  %32 = fcmp olt double %0, 3.156250e+00
  br i1 %32, label %49, label %33

33:                                               ; preds = %31
  %34 = fcmp olt double %0, 0x4010D00000000000
  br i1 %34, label %49, label %35

35:                                               ; preds = %33
  %36 = fcmp olt double %0, 4.687500e+00
  %37 = select i1 %36, double 0.000000e+00, double 0x3CBDFE7BAC228E8C
  %38 = select i1 %36, double 0x4010D00000000000, double 0x4015B7FE4E87B02E
  %39 = select i1 %36, ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 180), ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 195)
  br label %49

40:                                               ; preds = %27
  %41 = fcmp olt double %0, 0x401F140000000000
  br i1 %41, label %49, label %42

42:                                               ; preds = %40
  %43 = fcmp olt double %0, 0x4022B80000000000
  br i1 %43, label %49, label %44

44:                                               ; preds = %42
  %45 = fcmp olt double %0, 1.093750e+01
  %46 = select i1 %45, double 0x3CC8F4BA5D68E440, double 0x3C80FC786CE06080
  %47 = select i1 %45, double 0x40243F2EE51E8C7E, double 0x40277F9138D43206
  %48 = select i1 %45, ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 240), ptr addrspace(2) getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 255)
  br label %49

49:                                               ; preds = %44, %42, %40, %35, %33, %31, %29, %22, %20, %18, %14, %12, %10, %8
  %50 = phi double [ 0.000000e+00, %8 ], [ 0.000000e+00, %10 ], [ 0.000000e+00, %12 ], [ 0.000000e+00, %14 ], [ 0.000000e+00, %18 ], [ 0.000000e+00, %20 ], [ %24, %22 ], [ 0.000000e+00, %29 ], [ 0.000000e+00, %31 ], [ 0x3C53BAC0714E4129, %33 ], [ %37, %35 ], [ 0x3CA7960B6B1C46AC, %40 ], [ 0x3CB479CC068D9046, %42 ], [ %46, %44 ]
  %51 = phi double [ 0.000000e+00, %8 ], [ 5.000000e-01, %10 ], [ 6.250000e-01, %12 ], [ %16, %14 ], [ 1.218750e+00, %18 ], [ 1.531250e+00, %20 ], [ %25, %22 ], [ 2.312500e+00, %29 ], [ 0x4005E00000000000, %31 ], [ 0x400D76D4AFFBA175, %33 ], [ %38, %35 ], [ 0x401BC41890588553, %40 ], [ 0x40213127AE6169B4, %42 ], [ %47, %44 ]
  %52 = phi ptr addrspace(2) [ @__ocmltbl_M64_Y1, %8 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 15), %10 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 30), %12 ], [ %17, %14 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 75), %18 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 90), %20 ], [ %26, %22 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 135), %29 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 150), %31 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 165), %33 ], [ %39, %35 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 210), %40 ], [ getelementptr inbounds ([0 x double], ptr addrspace(2) @__ocmltbl_M64_Y1, i64 0, i64 225), %42 ], [ %48, %44 ]
  %53 = fmul double %0, %0
  %54 = fsub double %0, %51
  %55 = fsub double %54, %50
  %56 = fcmp olt double %0, 5.000000e-01
  %57 = select i1 %56, double %53, double %55
  %58 = getelementptr inbounds double, ptr addrspace(2) %52, i64 14
  %59 = load double, ptr addrspace(2) %58, align 8, !tbaa !19
  %60 = getelementptr inbounds double, ptr addrspace(2) %52, i64 13
  %61 = load double, ptr addrspace(2) %60, align 8, !tbaa !19
  %62 = tail call double @llvm.fma.f64(double %57, double %59, double %61)
  %63 = getelementptr inbounds double, ptr addrspace(2) %52, i64 12
  %64 = load double, ptr addrspace(2) %63, align 8, !tbaa !19
  %65 = tail call double @llvm.fma.f64(double %57, double %62, double %64)
  %66 = getelementptr inbounds double, ptr addrspace(2) %52, i64 11
  %67 = load double, ptr addrspace(2) %66, align 8, !tbaa !19
  %68 = tail call double @llvm.fma.f64(double %57, double %65, double %67)
  %69 = getelementptr inbounds double, ptr addrspace(2) %52, i64 10
  %70 = load double, ptr addrspace(2) %69, align 8, !tbaa !19
  %71 = tail call double @llvm.fma.f64(double %57, double %68, double %70)
  %72 = getelementptr inbounds double, ptr addrspace(2) %52, i64 9
  %73 = load double, ptr addrspace(2) %72, align 8, !tbaa !19
  %74 = tail call double @llvm.fma.f64(double %57, double %71, double %73)
  %75 = getelementptr inbounds double, ptr addrspace(2) %52, i64 8
  %76 = load double, ptr addrspace(2) %75, align 8, !tbaa !19
  %77 = tail call double @llvm.fma.f64(double %57, double %74, double %76)
  %78 = getelementptr inbounds double, ptr addrspace(2) %52, i64 7
  %79 = load double, ptr addrspace(2) %78, align 8, !tbaa !19
  %80 = tail call double @llvm.fma.f64(double %57, double %77, double %79)
  %81 = getelementptr inbounds double, ptr addrspace(2) %52, i64 6
  %82 = load double, ptr addrspace(2) %81, align 8, !tbaa !19
  %83 = tail call double @llvm.fma.f64(double %57, double %80, double %82)
  %84 = getelementptr inbounds double, ptr addrspace(2) %52, i64 5
  %85 = load double, ptr addrspace(2) %84, align 8, !tbaa !19
  %86 = tail call double @llvm.fma.f64(double %57, double %83, double %85)
  %87 = getelementptr inbounds double, ptr addrspace(2) %52, i64 4
  %88 = load double, ptr addrspace(2) %87, align 8, !tbaa !19
  %89 = tail call double @llvm.fma.f64(double %57, double %86, double %88)
  %90 = getelementptr inbounds double, ptr addrspace(2) %52, i64 3
  %91 = load double, ptr addrspace(2) %90, align 8, !tbaa !19
  %92 = tail call double @llvm.fma.f64(double %57, double %89, double %91)
  %93 = getelementptr inbounds double, ptr addrspace(2) %52, i64 2
  %94 = load double, ptr addrspace(2) %93, align 8, !tbaa !19
  %95 = tail call double @llvm.fma.f64(double %57, double %92, double %94)
  %96 = getelementptr inbounds double, ptr addrspace(2) %52, i64 1
  %97 = load double, ptr addrspace(2) %96, align 8, !tbaa !19
  %98 = tail call double @llvm.fma.f64(double %57, double %95, double %97)
  %99 = load double, ptr addrspace(2) %52, align 8, !tbaa !19
  %100 = tail call double @llvm.fma.f64(double %57, double %98, double %99)
  br i1 %56, label %101, label %145

101:                                              ; preds = %49
  %102 = fcmp olt double %0, 0x3DE0000000000000
  br i1 %102, label %103, label %106

103:                                              ; preds = %101
  %104 = tail call double @llvm.fabs.f64(double %0)
  %105 = fdiv double 0xBFE45F306DC9C883, %104
  br label %113

106:                                              ; preds = %101
  %107 = tail call spir_func double @__ocml_j1_f64(double noundef %0) #38
  %108 = tail call spir_func double @__ocml_log_f64(double noundef %0) #38
  %109 = fdiv double -1.000000e+00, %0
  %110 = tail call double @llvm.fmuladd.f64(double %107, double %108, double %109)
  %111 = fmul double %110, 0x3FE45F306DC9C883
  %112 = tail call double @llvm.fma.f64(double %100, double %0, double %111)
  br label %113

113:                                              ; preds = %106, %103
  %114 = phi double [ %105, %103 ], [ %112, %106 ]
  %115 = fcmp olt double %0, 0.000000e+00
  %116 = select i1 %115, double 0x7FF8000000000000, double %114
  br label %145

117:                                              ; preds = %1
  %118 = fdiv double 1.000000e+00, %0
  %119 = fmul double %118, %118
  %120 = tail call spir_func double @__ocmlpriv_bp1_f64(double noundef %119) #38
  %121 = fmul double %118, %120
  %122 = fptrunc double %118 to float
  %123 = tail call spir_func float @_Z12native_rsqrtf(float noundef %122) #38
  %124 = fpext float %123 to double
  %125 = fmul double %118, %124
  %126 = fmul double %124, 5.000000e-01
  %127 = fneg double %126
  %128 = tail call double @llvm.fma.f64(double %127, double %125, double 5.000000e-01)
  %129 = tail call double @llvm.fma.f64(double %126, double %128, double %126)
  %130 = tail call double @llvm.fma.f64(double %125, double %128, double %125)
  %131 = fneg double %130
  %132 = tail call double @llvm.fma.f64(double %131, double %130, double %118)
  %133 = tail call double @llvm.fma.f64(double %132, double %129, double %130)
  %134 = fcmp oeq double %118, 0.000000e+00
  %135 = select i1 %134, double %118, double %133
  %136 = fmul double %135, 0x3FE9884533D43651
  %137 = tail call spir_func double @__ocmlpriv_ba1_f64(double noundef %119) #38
  %138 = fmul double %137, %136
  %139 = tail call spir_func double @__ocmlpriv_sinb_f64(double noundef %0, i32 noundef 1, double noundef %121) #40
  %140 = fmul double %139, %138
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %2)
  store double %0, ptr %2, align 8, !tbaa !19
  %141 = addrspacecast ptr %2 to ptr addrspace(4)
  %142 = load i128, ptr addrspace(4) %141, align 8, !tbaa !29
  %143 = icmp eq i128 %142, 9218868437227405312
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %2)
  %144 = select i1 %143, double 0.000000e+00, double %140
  br label %145

145:                                              ; preds = %49, %113, %117
  %146 = phi double [ %144, %117 ], [ %116, %113 ], [ %100, %49 ]
  ret double %146
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func float @__ocml_y1_f32(float noundef %0) local_unnamed_addr #21 {
  %2 = alloca float, align 8
  %3 = fcmp ugt float %0, 1.256250e+01
  br i1 %3, label %99, label %4

4:                                                ; preds = %1
  %5 = fcmp olt float %0, 2.312500e+00
  br i1 %5, label %6, label %27

6:                                                ; preds = %4
  %7 = fcmp olt float %0, 1.218750e+00
  br i1 %7, label %8, label %18

8:                                                ; preds = %6
  %9 = fcmp olt float %0, 5.000000e-01
  br i1 %9, label %49, label %10

10:                                               ; preds = %8
  %11 = fcmp olt float %0, 6.250000e-01
  br i1 %11, label %49, label %12

12:                                               ; preds = %10
  %13 = fcmp olt float %0, 7.500000e-01
  br i1 %13, label %49, label %14

14:                                               ; preds = %12
  %15 = fcmp olt float %0, 9.375000e-01
  %16 = select i1 %15, float 7.500000e-01, float 9.375000e-01
  %17 = select i1 %15, ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 27), ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 36)
  br label %49

18:                                               ; preds = %6
  %19 = fcmp olt float %0, 1.531250e+00
  br i1 %19, label %49, label %20

20:                                               ; preds = %18
  %21 = fcmp olt float %0, 1.843750e+00
  br i1 %21, label %49, label %22

22:                                               ; preds = %20
  %23 = fcmp olt float %0, 0x4000A00000000000
  %24 = select i1 %23, float 0.000000e+00, float 0xBE76401B80000000
  %25 = select i1 %23, float 1.843750e+00, float 0x400193BEE0000000
  %26 = select i1 %23, ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 63), ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 72)
  br label %49

27:                                               ; preds = %4
  %28 = fcmp olt float %0, 6.187500e+00
  br i1 %28, label %29, label %40

29:                                               ; preds = %27
  %30 = fcmp olt float %0, 0x4005E00000000000
  br i1 %30, label %49, label %31

31:                                               ; preds = %29
  %32 = fcmp olt float %0, 3.156250e+00
  br i1 %32, label %49, label %33

33:                                               ; preds = %31
  %34 = fcmp olt float %0, 0x4010D00000000000
  br i1 %34, label %49, label %35

35:                                               ; preds = %33
  %36 = fcmp olt float %0, 4.687500e+00
  %37 = select i1 %36, float 0.000000e+00, float 0x3E8D0F6060000000
  %38 = select i1 %36, float 0x4010D00000000000, float 0x4015B7FE40000000
  %39 = select i1 %36, ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 108), ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 117)
  br label %49

40:                                               ; preds = %27
  %41 = fcmp olt float %0, 0x401F140000000000
  br i1 %41, label %49, label %42

42:                                               ; preds = %40
  %43 = fcmp olt float %0, 0x4022B80000000000
  br i1 %43, label %49, label %44

44:                                               ; preds = %42
  %45 = fcmp olt float %0, 1.093750e+01
  %46 = select i1 %45, float 0x3E847A3200000000, float 0xBE8CAF37E0000000
  %47 = select i1 %45, float 0x40243F2EE0000000, float 0x40277F9140000000
  %48 = select i1 %45, ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 144), ptr addrspace(2) getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 153)
  br label %49

49:                                               ; preds = %44, %42, %40, %35, %33, %31, %29, %22, %20, %18, %14, %12, %10, %8
  %50 = phi float [ 0.000000e+00, %8 ], [ 0.000000e+00, %10 ], [ 0.000000e+00, %12 ], [ 0.000000e+00, %14 ], [ 0.000000e+00, %18 ], [ 0.000000e+00, %20 ], [ %24, %22 ], [ 0.000000e+00, %29 ], [ 0.000000e+00, %31 ], [ 0x3E7FF742E0000000, %33 ], [ %37, %35 ], [ 0xBE8F4EF560000000, %40 ], [ 0x3E9CC2D360000000, %42 ], [ %46, %44 ]
  %51 = phi float [ 0.000000e+00, %8 ], [ 5.000000e-01, %10 ], [ 6.250000e-01, %12 ], [ %16, %14 ], [ 1.218750e+00, %18 ], [ 1.531250e+00, %20 ], [ %25, %22 ], [ 2.312500e+00, %29 ], [ 0x4005E00000000000, %31 ], [ 0x400D76D4A0000000, %33 ], [ %38, %35 ], [ 0x401BC418A0000000, %40 ], [ 0x40213127A0000000, %42 ], [ %47, %44 ]
  %52 = phi ptr addrspace(2) [ @__ocmltbl_M32_Y1, %8 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 9), %10 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 18), %12 ], [ %17, %14 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 45), %18 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 54), %20 ], [ %26, %22 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 81), %29 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 90), %31 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 99), %33 ], [ %39, %35 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 126), %40 ], [ getelementptr inbounds ([0 x float], ptr addrspace(2) @__ocmltbl_M32_Y1, i64 0, i64 135), %42 ], [ %48, %44 ]
  %53 = fmul float %0, %0
  %54 = fsub float %0, %51
  %55 = fsub float %54, %50
  %56 = fcmp olt float %0, 5.000000e-01
  %57 = select i1 %56, float %53, float %55
  %58 = getelementptr inbounds float, ptr addrspace(2) %52, i64 8
  %59 = load float, ptr addrspace(2) %58, align 4, !tbaa !16
  %60 = getelementptr inbounds float, ptr addrspace(2) %52, i64 7
  %61 = load float, ptr addrspace(2) %60, align 4, !tbaa !16
  %62 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %57, float noundef %59, float noundef %61) #38
  %63 = getelementptr inbounds float, ptr addrspace(2) %52, i64 6
  %64 = load float, ptr addrspace(2) %63, align 4, !tbaa !16
  %65 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %57, float noundef %62, float noundef %64) #38
  %66 = getelementptr inbounds float, ptr addrspace(2) %52, i64 5
  %67 = load float, ptr addrspace(2) %66, align 4, !tbaa !16
  %68 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %57, float noundef %65, float noundef %67) #38
  %69 = getelementptr inbounds float, ptr addrspace(2) %52, i64 4
  %70 = load float, ptr addrspace(2) %69, align 4, !tbaa !16
  %71 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %57, float noundef %68, float noundef %70) #38
  %72 = getelementptr inbounds float, ptr addrspace(2) %52, i64 3
  %73 = load float, ptr addrspace(2) %72, align 4, !tbaa !16
  %74 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %57, float noundef %71, float noundef %73) #38
  %75 = getelementptr inbounds float, ptr addrspace(2) %52, i64 2
  %76 = load float, ptr addrspace(2) %75, align 4, !tbaa !16
  %77 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %57, float noundef %74, float noundef %76) #38
  %78 = getelementptr inbounds float, ptr addrspace(2) %52, i64 1
  %79 = load float, ptr addrspace(2) %78, align 4, !tbaa !16
  %80 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %57, float noundef %77, float noundef %79) #38
  %81 = load float, ptr addrspace(2) %52, align 4, !tbaa !16
  %82 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %57, float noundef %80, float noundef %81) #38
  br i1 %56, label %83, label %114

83:                                               ; preds = %49
  %84 = fcmp olt float %0, 0x3EB0000000000000
  br i1 %84, label %85, label %88

85:                                               ; preds = %83
  %86 = tail call float @llvm.fabs.f32(float %0)
  %87 = fdiv float 0xBFE45F3060000000, %86, !fpmath !15
  br label %95

88:                                               ; preds = %83
  %89 = tail call spir_func float @__ocml_j1_f32(float noundef %0) #38
  %90 = tail call spir_func float @__ocml_log_f32(float noundef %0) #38
  %91 = fdiv float -1.000000e+00, %0
  %92 = tail call float @llvm.fmuladd.f32(float %89, float %90, float %91)
  %93 = fmul float %92, 0x3FE45F3060000000
  %94 = tail call spir_func float @__ocml_fmuladd_f32(float noundef %82, float noundef %0, float noundef %93) #38
  br label %95

95:                                               ; preds = %88, %85
  %96 = phi float [ %87, %85 ], [ %94, %88 ]
  %97 = fcmp olt float %0, 0.000000e+00
  %98 = select i1 %97, float 0x7FF8000000000000, float %96
  br label %114

99:                                               ; preds = %1
  %100 = fdiv float 1.000000e+00, %0, !fpmath !15
  %101 = fmul float %100, %100
  %102 = tail call spir_func float @__ocmlpriv_bp1_f32(float noundef %101) #38
  %103 = fmul float %100, %102
  %104 = tail call spir_func float @_Z12native_rsqrtf(float noundef %0) #38
  %105 = fmul float %104, 0x3FE9884540000000
  %106 = tail call spir_func float @__ocmlpriv_ba1_f32(float noundef %101) #38
  %107 = fmul float %105, %106
  %108 = tail call spir_func float @__ocmlpriv_sinb_f32(float noundef %0, i32 noundef 1, float noundef %103) #40
  %109 = fmul float %107, %108
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %2)
  store float %0, ptr %2, align 8, !tbaa !16
  %110 = addrspacecast ptr %2 to ptr addrspace(4)
  %111 = load i64, ptr addrspace(4) %110, align 8, !tbaa !12
  %112 = icmp eq i64 %111, 2139095040
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %2)
  %113 = select i1 %112, float 0.000000e+00, float %109
  br label %114

114:                                              ; preds = %49, %95, %99
  %115 = phi float [ %113, %99 ], [ %98, %95 ], [ %82, %49 ]
  ret float %115
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func <2 x half> @__ocml_y1_2f16(<2 x half> noundef %0) local_unnamed_addr #21 {
  %2 = extractelement <2 x half> %0, i64 0
  %3 = fpext half %2 to float
  %4 = tail call spir_func float @__ocml_y1_f32(float noundef %3) #38
  %5 = fptrunc float %4 to half
  %6 = insertelement <2 x half> poison, half %5, i64 0
  %7 = extractelement <2 x half> %0, i64 1
  %8 = fpext half %7 to float
  %9 = tail call spir_func float @__ocml_y1_f32(float noundef %8) #38
  %10 = fptrunc float %9 to half
  %11 = insertelement <2 x half> %6, half %10, i64 1
  ret <2 x half> %11
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn memory(none)
define protected spir_func half @__ocml_y1_f16(half noundef %0) local_unnamed_addr #21 {
  %2 = fpext half %0 to float
  %3 = tail call spir_func float @__ocml_y1_f32(float noundef %2) #38
  %4 = fptrunc float %3 to half
  ret half %4
}

attributes #0 = { convergent noinline norecurse nounwind optnone "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #2 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #3 = { convergent nofree norecurse nounwind memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #4 = { convergent mustprogress nofree nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #6 = { convergent mustprogress nofree norecurse nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #7 = { nofree norecurse nosync nounwind memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #8 = { convergent nofree norecurse nounwind memory(read, inaccessiblemem: none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #9 = { convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #10 = { convergent norecurse nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #11 = { convergent nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #12 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #13 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #14 = { nofree norecurse nosync nounwind memory(argmem: readwrite) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #15 = { convergent nofree nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #16 = { convergent nofree norecurse nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #17 = { convergent mustprogress nofree norecurse nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #18 = { convergent mustprogress nofree nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #19 = { mustprogress nofree nosync nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #20 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #21 = { convergent mustprogress nofree norecurse nounwind willreturn memory(none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #22 = { convergent mustprogress nofree nounwind willreturn memory(none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #23 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #24 = { convergent mustprogress nofree norecurse nounwind willreturn memory(none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+16-bit-insts" }
attributes #25 = { inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #26 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+16-bit-insts" }
attributes #27 = { convergent mustprogress norecurse nounwind willreturn memory(argmem: write) "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #28 = { convergent mustprogress norecurse nounwind willreturn memory(argmem: readwrite) "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #29 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #30 = { convergent mustprogress nofree norecurse nounwind willreturn memory(argmem: write) "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #31 = { convergent mustprogress nofree norecurse nosync nounwind willreturn memory(none) "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #32 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+16-bit-insts" }
attributes #33 = { convergent inlinehint norecurse nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #34 = { convergent mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+16-bit-insts" }
attributes #35 = { convergent norecurse nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
attributes #36 = { convergent norecurse nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+16-bit-insts" }
attributes #37 = { convergent mustprogress norecurse nounwind willreturn memory(argmem: write) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+16-bit-insts" }
attributes #38 = { convergent nounwind willreturn memory(none) }
attributes #39 = { nounwind }
attributes #40 = { convergent nounwind }
attributes #41 = { convergent nounwind willreturn memory(read) }
attributes #42 = { nounwind willreturn memory(none) }
attributes #43 = { convergent nounwind willreturn memory(argmem: readwrite) }
attributes #44 = { nounwind willreturn memory(read) }

!opencl.ocl.version = !{!0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0}
!llvm.ident = !{!1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1}
!llvm.module.flags = !{!2, !3}

!0 = !{i32 2, i32 0}
!1 = !{!"clang version 18.1.8"}
!2 = !{i32 1, !"wchar_size", i32 4}
!3 = !{i32 7, !"frame-pointer", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"int", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C/C++ TBAA"}
!8 = !{!9, !9, i64 0}
!9 = !{!"any pointer", !6, i64 0}
!10 = !{i64 0, i64 65}
!11 = !{i64 0, i64 64}
!12 = !{!13, !13, i64 0}
!13 = !{!"long", !6, i64 0}
!14 = !{!6, !6, i64 0}
!15 = !{float 2.500000e+00}
!16 = !{!17, !17, i64 0}
!17 = !{!"float", !6, i64 0}
!18 = !{float 3.000000e+00}
!19 = !{!20, !20, i64 0}
!20 = !{!"double", !6, i64 0}
!21 = distinct !{!21, !22, !23}
!22 = !{!"llvm.loop.isvectorized", i32 1}
!23 = !{!"llvm.loop.unroll.runtime.disable"}
!24 = distinct !{!24, !22}
!25 = !{!26, !26, i64 0}
!26 = !{!"bool", !6, i64 0}
!27 = !{i8 0, i8 2}
!28 = !{}
!29 = !{!30, !30, i64 0}
!30 = !{!"long long", !6, i64 0}
!31 = !{!32, !20, i64 8}
!32 = !{!"redret", !20, i64 0, !20, i64 8, !5, i64 16}
!33 = !{!32, !20, i64 0}
!34 = !{!32, !5, i64 16}
!35 = !{!36, !20, i64 8}
!36 = !{!"scret", !20, i64 0, !20, i64 8}
!37 = !{!36, !20, i64 0}
!38 = !{!39, !17, i64 0}
!39 = !{!"redret", !17, i64 0, !5, i64 4}
!40 = !{!39, !5, i64 4}
!41 = !{!42, !17, i64 4}
!42 = !{!"scret", !17, i64 0, !17, i64 4}
!43 = !{!42, !17, i64 0}
!44 = !{i32 0, i32 33}
!45 = !{!46, !47, i64 0}
!46 = !{!"redret", !47, i64 0, !48, i64 2}
!47 = !{!"half", !6, i64 0}
!48 = !{!"short", !6, i64 0}
!49 = !{!50, !47, i64 0}
!50 = !{!"scret", !47, i64 0, !47, i64 2}
!51 = !{!46, !48, i64 2}
!52 = !{!50, !47, i64 2}
!53 = !{!54, !20, i64 0}
!54 = !{!"redret", !20, i64 0, !5, i64 8}
!55 = !{!54, !5, i64 8}
!56 = !{i32 -1, i32 1}
!57 = !{!47, !47, i64 0}
!58 = !{!59}
!59 = distinct !{!59, !60, !"__ocml_lgamma_r_impl_f64: argument 0"}
!60 = distinct !{!60, !"__ocml_lgamma_r_impl_f64"}
!61 = !{!62}
!62 = distinct !{!62, !63, !"__ocml_lgamma_r_impl_f32: argument 0"}
!63 = distinct !{!63, !"__ocml_lgamma_r_impl_f32"}
